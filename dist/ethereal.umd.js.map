{"version":3,"file":"ethereal.umd.js","sources":["../src/utils.ts","../src/metrics/QuickHull.js","../src/metrics/ConvexGeometry.ts","../src/metrics/SimplifyModifier.js","../src/metrics/SpatialMetrics.ts","../src/layout/Layout.ts","../node_modules/@popmotion/easing/dist/easing.es.js","../src/layout/Transitioner.ts","../node_modules/three-mesh-bvh/src/Utils/ThreeIntersectionUtilities.js","../node_modules/three-mesh-bvh/src/Utils/ArrayBoxUtilities.js","../node_modules/three-mesh-bvh/src/Utils/SeparatingAxisBounds.js","../node_modules/three-mesh-bvh/src/Utils/MathUtilities.js","../node_modules/three-mesh-bvh/src/Utils/SeparatingAxisTriangle.js","../node_modules/three-mesh-bvh/src/Utils/OrientedBox.js","../node_modules/three-mesh-bvh/src/MeshBVHNode.js","../node_modules/three-mesh-bvh/src/Utils/RayIntersectTriUtlities.js","../node_modules/three-mesh-bvh/src/Constants.js","../node_modules/three-mesh-bvh/src/BVHConstructionContext.js","../node_modules/three-mesh-bvh/src/MeshBVH.js","../node_modules/three-mesh-bvh/src/MeshBVHVisualizer.js","../node_modules/three-mesh-bvh/src/index.js","../src/THREE_Extensions.ts","../src/layout/LayoutHelper.ts","../src/adaptivity/Behavior.ts","../src/adaptivity/AdaptivityManager.ts","../src/adaptivity/AdaptiveOcclusionBehavior.ts"],"sourcesContent":["import * as THREE from 'three'\n\nexport const V_00 = Object.freeze(new THREE.Vector2)\nexport const V_11 = Object.freeze(new THREE.Vector2)\nexport const V_000 = Object.freeze(new THREE.Vector3)\nexport const V_100 = Object.freeze(new THREE.Vector3(1,0,0))\nexport const V_010 = Object.freeze(new THREE.Vector3(0,1,0))\nexport const V_001 = Object.freeze(new THREE.Vector3(0,0,1))\nexport const V_111 = Object.freeze(new THREE.Vector3(1,1,1))\nexport const Q_IDENTITY = Object.freeze(new THREE.Quaternion)\n\nconst next = Promise.resolve()\n\nexport class Pool<T> {\n\n  constructor(private _factory:() => T, private _reset:(t:T) => T) {}\n\n  private _pool = [] as T[]\n  private _unpooled = new Set<T>()\n  private _nextAutoPool?:Promise<void>\n\n  get() { \n    const object = this._pool.pop() || this._reset(this._factory())\n    this._unpooled.add(object)\n    if (!this._nextAutoPool) this._nextAutoPool = next.then(this._autoPool)\n    return object\n  }\n\n  pool(o:T) {\n    this._pool.push(o)\n    this._unpooled.delete(o)\n    this._reset(o)\n  }\n\n  private _poolAll() {\n    if (this._unpooled.size === 0) return\n    for (const o of this._unpooled) this.pool(o)\n  }\n\n  private _autoPool = () => {\n    this._nextAutoPool = undefined\n    this._poolAll()\n  }\n}\n\nexport const vectors2 = new Pool<THREE.Vector2>(\n  () => new THREE.Vector2, \n  (vec) => vec.set(0,0)\n)\n\nexport const vectors = new Pool<THREE.Vector3>(\n    () => new THREE.Vector3, \n    (vec) => vec.set(0,0,0)\n)\n\nexport const vectors4 = new Pool<THREE.Vector4>(\n    () => new THREE.Vector4, \n    (vec) => vec.set(0,0,0,1)\n)\n\nexport const quaternions = new Pool<THREE.Quaternion>(\n    () => new THREE.Quaternion, \n    (quat) => quat.set(0,0,0,1)\n)\n\nexport const matrices3 = new Pool<THREE.Matrix3>(\n  () => new THREE.Matrix3, \n  (mat) => mat.identity()\n)\n\nexport const matrices = new Pool<THREE.Matrix4>(\n    () => new THREE.Matrix4, \n    (mat) => mat.identity()\n)\n\nexport function traverse(\n  object: THREE.Object3D,\n  each: (node: THREE.Object3D) => boolean,\n  bind?: any\n) {\n  if (!each.call(bind, object)) return\n  for (let child of object.children) {\n    traverse(child, each, bind)\n  }\n}","import * as THREE from 'three'\n\n/**\n * @author Mugen87 / https://github.com/Mugen87\n *\n * Ported from: https://github.com/maurizzzio/quickhull3d/ by Mauricio Poppe (https://github.com/maurizzzio)\n *\n */\n\n\nvar Visible = 0;\nvar Deleted = 1;\n\nvar v1 = new THREE.Vector3();\n\nexport function QuickHull() {\n\n\tthis.tolerance = - 1;\n\n\tthis.faces = []; // the generated faces of the convex hull\n\tthis.newFaces = []; // this array holds the faces that are generated within a single iteration\n\n\t// the vertex lists work as follows:\n\t//\n\t// let 'a' and 'b' be 'Face' instances\n\t// let 'v' be points wrapped as instance of 'Vertex'\n\t//\n\t//     [v, v, ..., v, v, v, ...]\n\t//      ^             ^\n\t//      |             |\n\t//  a.outside     b.outside\n\t//\n\tthis.assigned = new VertexList();\n\tthis.unassigned = new VertexList();\n\n\tthis.vertices = []; \t// vertices of the hull (internal representation of given geometry data)\n\n}\n\nObject.assign( QuickHull.prototype, {\n\n\tsetFromPoints: function ( points ) {\n\n\t\tif ( Array.isArray( points ) !== true ) {\n\n\t\t\tconsole.error( 'THREE.QuickHull: Points parameter is not an array.' );\n\n\t\t}\n\n\t\tif ( points.length < 4 ) {\n\n\t\t\tconsole.error( 'THREE.QuickHull: The algorithm needs at least four points.' );\n\n\t\t}\n\n\t\tthis.makeEmpty();\n\n\t\tfor ( var i = 0, l = points.length; i < l; i ++ ) {\n\n\t\t\tthis.vertices.push( new VertexNode( points[ i ] ) );\n\n\t\t}\n\n\t\tthis.compute();\n\n\t\treturn this;\n\n\t},\n\n\tsetFromObject: function ( object ) {\n\n\t\tvar points = [];\n\n\t\tobject.updateMatrixWorld( true );\n\n\t\tobject.traverse( function ( node ) {\n\n\t\t\tvar i, l, point;\n\n\t\t\tvar geometry = node.geometry;\n\n\t\t\tif ( geometry !== undefined ) {\n\n\t\t\t\tif ( geometry.isGeometry ) {\n\n\t\t\t\t\tvar vertices = geometry.vertices;\n\n\t\t\t\t\tfor ( i = 0, l = vertices.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tpoint = vertices[ i ].clone();\n\t\t\t\t\t\tpoint.applyMatrix4( node.matrixWorld );\n\n\t\t\t\t\t\tpoints.push( point );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( geometry.isBufferGeometry ) {\n\n\t\t\t\t\tvar attribute = geometry.attributes.position;\n\n\t\t\t\t\tif ( attribute !== undefined ) {\n\n\t\t\t\t\t\tfor ( i = 0, l = attribute.count; i < l; i ++ ) {\n\n\t\t\t\t\t\t\tpoint = new THREE.Vector3();\n\n\t\t\t\t\t\t\tpoint.fromBufferAttribute( attribute, i ).applyMatrix4( node.matrixWorld );\n\n\t\t\t\t\t\t\tpoints.push( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} );\n\n\t\treturn this.setFromPoints( points );\n\n\t},\n\n\tcontainsPoint: function ( point ) {\n\n\t\tvar faces = this.faces;\n\n\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\t\tvar face = faces[ i ];\n\n\t\t\t// compute signed distance and check on what half space the point lies\n\n\t\t\tif ( face.distanceToPoint( point ) > this.tolerance ) return false;\n\n\t\t}\n\n\t\treturn true;\n\n\t},\n\n\tintersectRay: function ( ray, target ) {\n\n\t\t// based on \"Fast Ray-Convex Polyhedron Intersection\"  by Eric Haines, GRAPHICS GEMS II\n\n\t\tvar faces = this.faces;\n\n\t\tvar tNear = - Infinity;\n\t\tvar tFar = Infinity;\n\n\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\t\tvar face = faces[ i ];\n\n\t\t\t// interpret faces as planes for the further computation\n\n\t\t\tvar vN = face.distanceToPoint( ray.origin );\n\t\t\tvar vD = face.normal.dot( ray.direction );\n\n\t\t\t// if the origin is on the positive side of a plane (so the plane can \"see\" the origin) and\n\t\t\t// the ray is turned away or parallel to the plane, there is no intersection\n\n\t\t\tif ( vN > 0 && vD >= 0 ) return null;\n\n\t\t\t// compute the distance from the rayâ€™s origin to the intersection with the plane\n\n\t\t\tvar t = ( vD !== 0 ) ? ( - vN / vD ) : 0;\n\n\t\t\t// only proceed if the distance is positive. a negative distance means the intersection point\n\t\t\t// lies \"behind\" the origin\n\n\t\t\tif ( t <= 0 ) continue;\n\n\t\t\t// now categorized plane as front-facing or back-facing\n\n\t\t\tif ( vD > 0 ) {\n\n\t\t\t\t//  plane faces away from the ray, so this plane is a back-face\n\n\t\t\t\ttFar = Math.min( t, tFar );\n\n\t\t\t} else {\n\n\t\t\t\t// front-face\n\n\t\t\t\ttNear = Math.max( t, tNear );\n\n\t\t\t}\n\n\t\t\tif ( tNear > tFar ) {\n\n\t\t\t\t// if tNear ever is greater than tFar, the ray must miss the convex hull\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// evaluate intersection point\n\n\t\t// always try tNear first since its the closer intersection point\n\n\t\tif ( tNear !== - Infinity ) {\n\n\t\t\tray.at( tNear, target );\n\n\t\t} else {\n\n\t\t\tray.at( tFar, target );\n\n\t\t}\n\n\t\treturn target;\n\n\t},\n\n\tintersectsRay: function ( ray ) {\n\n\t\treturn this.intersectRay( ray, v1 ) !== null;\n\n\t},\n\n\tmakeEmpty: function () {\n\n\t\tthis.faces = [];\n\t\tthis.vertices = [];\n\n\t\treturn this;\n\n\t},\n\n\t// Adds a vertex to the 'assigned' list of vertices and assigns it to the given face\n\n\taddVertexToFace: function ( vertex, face ) {\n\n\t\tvertex.face = face;\n\n\t\tif ( face.outside === null ) {\n\n\t\t\tthis.assigned.append( vertex );\n\n\t\t} else {\n\n\t\t\tthis.assigned.insertBefore( face.outside, vertex );\n\n\t\t}\n\n\t\tface.outside = vertex;\n\n\t\treturn this;\n\n\t},\n\n\t// Removes a vertex from the 'assigned' list of vertices and from the given face\n\n\tremoveVertexFromFace: function ( vertex, face ) {\n\n\t\tif ( vertex === face.outside ) {\n\n\t\t\t// fix face.outside link\n\n\t\t\tif ( vertex.next !== null && vertex.next.face === face ) {\n\n\t\t\t\t// face has at least 2 outside vertices, move the 'outside' reference\n\n\t\t\t\tface.outside = vertex.next;\n\n\t\t\t} else {\n\n\t\t\t\t// vertex was the only outside vertex that face had\n\n\t\t\t\tface.outside = null;\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.assigned.remove( vertex );\n\n\t\treturn this;\n\n\t},\n\n\t// Removes all the visible vertices that a given face is able to see which are stored in the 'assigned' vertext list\n\n\tremoveAllVerticesFromFace: function ( face ) {\n\n\t\tif ( face.outside !== null ) {\n\n\t\t\t// reference to the first and last vertex of this face\n\n\t\t\tvar start = face.outside;\n\t\t\tvar end = face.outside;\n\n\t\t\twhile ( end.next !== null && end.next.face === face ) {\n\n\t\t\t\tend = end.next;\n\n\t\t\t}\n\n\t\t\tthis.assigned.removeSubList( start, end );\n\n\t\t\t// fix references\n\n\t\t\tstart.prev = end.next = null;\n\t\t\tface.outside = null;\n\n\t\t\treturn start;\n\n\t\t}\n\n\t},\n\n\t// Removes all the visible vertices that 'face' is able to see\n\n\tdeleteFaceVertices: function ( face, absorbingFace ) {\n\n\t\tvar faceVertices = this.removeAllVerticesFromFace( face );\n\n\t\tif ( faceVertices !== undefined ) {\n\n\t\t\tif ( absorbingFace === undefined ) {\n\n\t\t\t\t// mark the vertices to be reassigned to some other face\n\n\t\t\t\tthis.unassigned.appendChain( faceVertices );\n\n\n\t\t\t} else {\n\n\t\t\t\t// if there's an absorbing face try to assign as many vertices as possible to it\n\n\t\t\t\tvar vertex = faceVertices;\n\n\t\t\t\tdo {\n\n\t\t\t\t\t// we need to buffer the subsequent vertex at this point because the 'vertex.next' reference\n\t\t\t\t\t// will be changed by upcoming method calls\n\n\t\t\t\t\tvar nextVertex = vertex.next;\n\n\t\t\t\t\tvar distance = absorbingFace.distanceToPoint( vertex.point );\n\n\t\t\t\t\t// check if 'vertex' is able to see 'absorbingFace'\n\n\t\t\t\t\tif ( distance > this.tolerance ) {\n\n\t\t\t\t\t\tthis.addVertexToFace( vertex, absorbingFace );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tthis.unassigned.append( vertex );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// now assign next vertex\n\n\t\t\t\t\tvertex = nextVertex;\n\n\t\t\t\t} while ( vertex !== null );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\t// Reassigns as many vertices as possible from the unassigned list to the new faces\n\n\tresolveUnassignedPoints: function ( newFaces ) {\n\n\t\tif ( this.unassigned.isEmpty() === false ) {\n\n\t\t\tvar vertex = this.unassigned.first();\n\n\t\t\tdo {\n\n\t\t\t\t// buffer 'next' reference, see .deleteFaceVertices()\n\n\t\t\t\tvar nextVertex = vertex.next;\n\n\t\t\t\tvar maxDistance = this.tolerance;\n\n\t\t\t\tvar maxFace = null;\n\n\t\t\t\tfor ( var i = 0; i < newFaces.length; i ++ ) {\n\n\t\t\t\t\tvar face = newFaces[ i ];\n\n\t\t\t\t\tif ( face.mark === Visible ) {\n\n\t\t\t\t\t\tvar distance = face.distanceToPoint( vertex.point );\n\n\t\t\t\t\t\tif ( distance > maxDistance ) {\n\n\t\t\t\t\t\t\tmaxDistance = distance;\n\t\t\t\t\t\t\tmaxFace = face;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( maxDistance > 1000 * this.tolerance ) break;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// 'maxFace' can be null e.g. if there are identical vertices\n\n\t\t\t\tif ( maxFace !== null ) {\n\n\t\t\t\t\tthis.addVertexToFace( vertex, maxFace );\n\n\t\t\t\t}\n\n\t\t\t\tvertex = nextVertex;\n\n\t\t\t} while ( vertex !== null );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\t// Computes the extremes of a simplex which will be the initial hull\n\n\tcomputeExtremes: function () {\n\n\t\tvar min = new THREE.Vector3();\n\t\tvar max = new THREE.Vector3();\n\n\t\tvar minVertices = [];\n\t\tvar maxVertices = [];\n\n\t\tvar i, l, j;\n\n\t\t// initially assume that the first vertex is the min/max\n\n\t\tfor ( i = 0; i < 3; i ++ ) {\n\n\t\t\tminVertices[ i ] = maxVertices[ i ] = this.vertices[ 0 ];\n\n\t\t}\n\n\t\tmin.copy( this.vertices[ 0 ].point );\n\t\tmax.copy( this.vertices[ 0 ].point );\n\n\t\t// compute the min/max vertex on all six directions\n\n\t\tfor ( i = 0, l = this.vertices.length; i < l; i ++ ) {\n\n\t\t\tvar vertex = this.vertices[ i ];\n\t\t\tvar point = vertex.point;\n\n\t\t\t// update the min coordinates\n\n\t\t\tfor ( j = 0; j < 3; j ++ ) {\n\n\t\t\t\tif ( point.getComponent( j ) < min.getComponent( j ) ) {\n\n\t\t\t\t\tmin.setComponent( j, point.getComponent( j ) );\n\t\t\t\t\tminVertices[ j ] = vertex;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// update the max coordinates\n\n\t\t\tfor ( j = 0; j < 3; j ++ ) {\n\n\t\t\t\tif ( point.getComponent( j ) > max.getComponent( j ) ) {\n\n\t\t\t\t\tmax.setComponent( j, point.getComponent( j ) );\n\t\t\t\t\tmaxVertices[ j ] = vertex;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// use min/max vectors to compute an optimal epsilon\n\n\t\tthis.tolerance = 3 * Number.EPSILON * (\n\t\t\tMath.max( Math.abs( min.x ), Math.abs( max.x ) ) +\n\t\t\tMath.max( Math.abs( min.y ), Math.abs( max.y ) ) +\n\t\t\tMath.max( Math.abs( min.z ), Math.abs( max.z ) )\n\t\t);\n\n\t\treturn { min: minVertices, max: maxVertices };\n\n\t},\n\n\t// Computes the initial simplex assigning to its faces all the points\n\t// that are candidates to form part of the hull\n\n\tcomputeInitialHull: function () {\n\n\t\tvar line3, plane, closestPoint;\n\n\t\treturn function computeInitialHull() {\n\n\t\t\tif ( line3 === undefined ) {\n\n\t\t\t\tline3 = new THREE.Line3();\n\t\t\t\tplane = new THREE.Plane();\n\t\t\t\tclosestPoint = new THREE.Vector3();\n\n\t\t\t}\n\n\t\t\tvar vertex, vertices = this.vertices;\n\t\t\tvar extremes = this.computeExtremes();\n\t\t\tvar min = extremes.min;\n\t\t\tvar max = extremes.max;\n\n\t\t\tvar v0, v1, v2, v3;\n\t\t\tvar i, l, j;\n\n\t\t\t// 1. Find the two vertices 'v0' and 'v1' with the greatest 1d separation\n\t\t\t// (max.x - min.x)\n\t\t\t// (max.y - min.y)\n\t\t\t// (max.z - min.z)\n\n\t\t\tvar distance, maxDistance = 0;\n\t\t\tvar index = 0;\n\n\t\t\tfor ( i = 0; i < 3; i ++ ) {\n\n\t\t\t\tdistance = max[ i ].point.getComponent( i ) - min[ i ].point.getComponent( i );\n\n\t\t\t\tif ( distance > maxDistance ) {\n\n\t\t\t\t\tmaxDistance = distance;\n\t\t\t\t\tindex = i;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tv0 = min[ index ];\n\t\t\tv1 = max[ index ];\n\n\t\t\t// 2. The next vertex 'v2' is the one farthest to the line formed by 'v0' and 'v1'\n\n\t\t\tmaxDistance = 0;\n\t\t\tline3.set( v0.point, v1.point );\n\n\t\t\tfor ( i = 0, l = this.vertices.length; i < l; i ++ ) {\n\n\t\t\t\tvertex = vertices[ i ];\n\n\t\t\t\tif ( vertex !== v0 && vertex !== v1 ) {\n\n\t\t\t\t\tline3.closestPointToPoint( vertex.point, true, closestPoint );\n\n\t\t\t\t\tdistance = closestPoint.distanceToSquared( vertex.point );\n\n\t\t\t\t\tif ( distance > maxDistance ) {\n\n\t\t\t\t\t\tmaxDistance = distance;\n\t\t\t\t\t\tv2 = vertex;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// 3. The next vertex 'v3' is the one farthest to the plane 'v0', 'v1', 'v2'\n\n\t\t\tmaxDistance = - 1;\n\t\t\tplane.setFromCoplanarPoints( v0.point, v1.point, v2.point );\n\n\t\t\tfor ( i = 0, l = this.vertices.length; i < l; i ++ ) {\n\n\t\t\t\tvertex = vertices[ i ];\n\n\t\t\t\tif ( vertex !== v0 && vertex !== v1 && vertex !== v2 ) {\n\n\t\t\t\t\tdistance = Math.abs( plane.distanceToPoint( vertex.point ) );\n\n\t\t\t\t\tif ( distance > maxDistance ) {\n\n\t\t\t\t\t\tmaxDistance = distance;\n\t\t\t\t\t\tv3 = vertex;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar faces = [];\n\n\t\t\tif ( plane.distanceToPoint( v3.point ) < 0 ) {\n\n\t\t\t\t// the face is not able to see the point so 'plane.normal' is pointing outside the tetrahedron\n\n\t\t\t\tfaces.push(\n\t\t\t\t\tFace.create( v0, v1, v2 ),\n\t\t\t\t\tFace.create( v3, v1, v0 ),\n\t\t\t\t\tFace.create( v3, v2, v1 ),\n\t\t\t\t\tFace.create( v3, v0, v2 )\n\t\t\t\t);\n\n\t\t\t\t// set the twin edge\n\n\t\t\t\tfor ( i = 0; i < 3; i ++ ) {\n\n\t\t\t\t\tj = ( i + 1 ) % 3;\n\n\t\t\t\t\t// join face[ i ] i > 0, with the first face\n\n\t\t\t\t\tfaces[ i + 1 ].getEdge( 2 ).setTwin( faces[ 0 ].getEdge( j ) );\n\n\t\t\t\t\t// join face[ i ] with face[ i + 1 ], 1 <= i <= 3\n\n\t\t\t\t\tfaces[ i + 1 ].getEdge( 1 ).setTwin( faces[ j + 1 ].getEdge( 0 ) );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// the face is able to see the point so 'plane.normal' is pointing inside the tetrahedron\n\n\t\t\t\tfaces.push(\n\t\t\t\t\tFace.create( v0, v2, v1 ),\n\t\t\t\t\tFace.create( v3, v0, v1 ),\n\t\t\t\t\tFace.create( v3, v1, v2 ),\n\t\t\t\t\tFace.create( v3, v2, v0 )\n\t\t\t\t);\n\n\t\t\t\t// set the twin edge\n\n\t\t\t\tfor ( i = 0; i < 3; i ++ ) {\n\n\t\t\t\t\tj = ( i + 1 ) % 3;\n\n\t\t\t\t\t// join face[ i ] i > 0, with the first face\n\n\t\t\t\t\tfaces[ i + 1 ].getEdge( 2 ).setTwin( faces[ 0 ].getEdge( ( 3 - i ) % 3 ) );\n\n\t\t\t\t\t// join face[ i ] with face[ i + 1 ]\n\n\t\t\t\t\tfaces[ i + 1 ].getEdge( 0 ).setTwin( faces[ j + 1 ].getEdge( 1 ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// the initial hull is the tetrahedron\n\n\t\t\tfor ( i = 0; i < 4; i ++ ) {\n\n\t\t\t\tthis.faces.push( faces[ i ] );\n\n\t\t\t}\n\n\t\t\t// initial assignment of vertices to the faces of the tetrahedron\n\n\t\t\tfor ( i = 0, l = vertices.length; i < l; i ++ ) {\n\n\t\t\t\tvertex = vertices[ i ];\n\n\t\t\t\tif ( vertex !== v0 && vertex !== v1 && vertex !== v2 && vertex !== v3 ) {\n\n\t\t\t\t\tmaxDistance = this.tolerance;\n\t\t\t\t\tvar maxFace = null;\n\n\t\t\t\t\tfor ( j = 0; j < 4; j ++ ) {\n\n\t\t\t\t\t\tdistance = this.faces[ j ].distanceToPoint( vertex.point );\n\n\t\t\t\t\t\tif ( distance > maxDistance ) {\n\n\t\t\t\t\t\t\tmaxDistance = distance;\n\t\t\t\t\t\t\tmaxFace = this.faces[ j ];\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( maxFace !== null ) {\n\n\t\t\t\t\t\tthis.addVertexToFace( vertex, maxFace );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\t// Removes inactive faces\n\n\treindexFaces: function () {\n\n\t\tvar activeFaces = [];\n\n\t\tfor ( var i = 0; i < this.faces.length; i ++ ) {\n\n\t\t\tvar face = this.faces[ i ];\n\n\t\t\tif ( face.mark === Visible ) {\n\n\t\t\t\tactiveFaces.push( face );\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.faces = activeFaces;\n\n\t\treturn this;\n\n\t},\n\n\t// Finds the next vertex to create faces with the current hull\n\n\tnextVertexToAdd: function () {\n\n\t\t// if the 'assigned' list of vertices is empty, no vertices are left. return with 'undefined'\n\n\t\tif ( this.assigned.isEmpty() === false ) {\n\n\t\t\tvar eyeVertex, maxDistance = 0;\n\n\t\t\t// grap the first available face and start with the first visible vertex of that face\n\n\t\t\tvar eyeFace = this.assigned.first().face;\n\t\t\tvar vertex = eyeFace.outside;\n\n\t\t\t// now calculate the farthest vertex that face can see\n\n\t\t\tdo {\n\n\t\t\t\tvar distance = eyeFace.distanceToPoint( vertex.point );\n\n\t\t\t\tif ( distance > maxDistance ) {\n\n\t\t\t\t\tmaxDistance = distance;\n\t\t\t\t\teyeVertex = vertex;\n\n\t\t\t\t}\n\n\t\t\t\tvertex = vertex.next;\n\n\t\t\t} while ( vertex !== null && vertex.face === eyeFace );\n\n\t\t\treturn eyeVertex;\n\n\t\t}\n\n\t},\n\n\t// Computes a chain of half edges in CCW order called the 'horizon'.\n\t// For an edge to be part of the horizon it must join a face that can see\n\t// 'eyePoint' and a face that cannot see 'eyePoint'.\n\n\tcomputeHorizon: function ( eyePoint, crossEdge, face, horizon ) {\n\n\t\t// moves face's vertices to the 'unassigned' vertex list\n\n\t\tthis.deleteFaceVertices( face );\n\n\t\tface.mark = Deleted;\n\n\t\tvar edge;\n\n\t\tif ( crossEdge === null ) {\n\n\t\t\tedge = crossEdge = face.getEdge( 0 );\n\n\t\t} else {\n\n\t\t\t// start from the next edge since 'crossEdge' was already analyzed\n\t\t\t// (actually 'crossEdge.twin' was the edge who called this method recursively)\n\n\t\t\tedge = crossEdge.next;\n\n\t\t}\n\n\t\tdo {\n\n\t\t\tvar twinEdge = edge.twin;\n\t\t\tvar oppositeFace = twinEdge.face;\n\n\t\t\tif ( oppositeFace.mark === Visible ) {\n\n\t\t\t\tif ( oppositeFace.distanceToPoint( eyePoint ) > this.tolerance ) {\n\n\t\t\t\t\t// the opposite face can see the vertex, so proceed with next edge\n\n\t\t\t\t\tthis.computeHorizon( eyePoint, twinEdge, oppositeFace, horizon );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// the opposite face can't see the vertex, so this edge is part of the horizon\n\n\t\t\t\t\thorizon.push( edge );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tedge = edge.next;\n\n\t\t} while ( edge !== crossEdge );\n\n\t\treturn this;\n\n\t},\n\n\t// Creates a face with the vertices 'eyeVertex.point', 'horizonEdge.tail' and 'horizonEdge.head' in CCW order\n\n\taddAdjoiningFace: function ( eyeVertex, horizonEdge ) {\n\n\t\t// all the half edges are created in ccw order thus the face is always pointing outside the hull\n\n\t\tvar face = Face.create( eyeVertex, horizonEdge.tail(), horizonEdge.head() );\n\n\t\tthis.faces.push( face );\n\n\t\t// join face.getEdge( - 1 ) with the horizon's opposite edge face.getEdge( - 1 ) = face.getEdge( 2 )\n\n\t\tface.getEdge( - 1 ).setTwin( horizonEdge.twin );\n\n\t\treturn face.getEdge( 0 ); // the half edge whose vertex is the eyeVertex\n\n\n\t},\n\n\t//  Adds 'horizon.length' faces to the hull, each face will be linked with the\n\t//  horizon opposite face and the face on the left/right\n\n\taddNewFaces: function ( eyeVertex, horizon ) {\n\n\t\tthis.newFaces = [];\n\n\t\tvar firstSideEdge = null;\n\t\tvar previousSideEdge = null;\n\n\t\tfor ( var i = 0; i < horizon.length; i ++ ) {\n\n\t\t\tvar horizonEdge = horizon[ i ];\n\n\t\t\t// returns the right side edge\n\n\t\t\tvar sideEdge = this.addAdjoiningFace( eyeVertex, horizonEdge );\n\n\t\t\tif ( firstSideEdge === null ) {\n\n\t\t\t\tfirstSideEdge = sideEdge;\n\n\t\t\t} else {\n\n\t\t\t\t// joins face.getEdge( 1 ) with previousFace.getEdge( 0 )\n\n\t\t\t\tsideEdge.next.setTwin( previousSideEdge );\n\n\t\t\t}\n\n\t\t\tthis.newFaces.push( sideEdge.face );\n\t\t\tpreviousSideEdge = sideEdge;\n\n\t\t}\n\n\t\t// perform final join of new faces\n\n\t\tfirstSideEdge.next.setTwin( previousSideEdge );\n\n\t\treturn this;\n\n\t},\n\n\t// Adds a vertex to the hull\n\n\taddVertexToHull: function ( eyeVertex ) {\n\n\t\tvar horizon = [];\n\n\t\tthis.unassigned.clear();\n\n\t\t// remove 'eyeVertex' from 'eyeVertex.face' so that it can't be added to the 'unassigned' vertex list\n\n\t\tthis.removeVertexFromFace( eyeVertex, eyeVertex.face );\n\n\t\tthis.computeHorizon( eyeVertex.point, null, eyeVertex.face, horizon );\n\n\t\tthis.addNewFaces( eyeVertex, horizon );\n\n\t\t// reassign 'unassigned' vertices to the new faces\n\n\t\tthis.resolveUnassignedPoints( this.newFaces );\n\n\t\treturn\tthis;\n\n\t},\n\n\tcleanup: function () {\n\n\t\tthis.assigned.clear();\n\t\tthis.unassigned.clear();\n\t\tthis.newFaces = [];\n\n\t\treturn this;\n\n\t},\n\n\tcompute: function () {\n\n\t\tvar vertex;\n\n\t\tthis.computeInitialHull();\n\n\t\t// add all available vertices gradually to the hull\n\n\t\twhile ( ( vertex = this.nextVertexToAdd() ) !== undefined ) {\n\n\t\t\tthis.addVertexToHull( vertex );\n\n\t\t}\n\n\t\tthis.reindexFaces();\n\n\t\tthis.cleanup();\n\n\t\treturn this;\n\n\t}\n\n} );\n\n//\n\nfunction Face() {\n\n\tthis.normal = new THREE.Vector3();\n\tthis.midpoint = new THREE.Vector3();\n\tthis.area = 0;\n\n\tthis.constant = 0; // signed distance from face to the origin\n\tthis.outside = null; // reference to a vertex in a vertex list this face can see\n\tthis.mark = Visible;\n\tthis.edge = null;\n\n}\n\nObject.assign( Face, {\n\n\tcreate: function ( a, b, c ) {\n\n\t\tvar face = new Face();\n\n\t\tvar e0 = new HalfEdge( a, face );\n\t\tvar e1 = new HalfEdge( b, face );\n\t\tvar e2 = new HalfEdge( c, face );\n\n\t\t// join edges\n\n\t\te0.next = e2.prev = e1;\n\t\te1.next = e0.prev = e2;\n\t\te2.next = e1.prev = e0;\n\n\t\t// main half edge reference\n\n\t\tface.edge = e0;\n\n\t\treturn face.compute();\n\n\t}\n\n} );\n\nObject.assign( Face.prototype, {\n\n\tgetEdge: function ( i ) {\n\n\t\tvar edge = this.edge;\n\n\t\twhile ( i > 0 ) {\n\n\t\t\tedge = edge.next;\n\t\t\ti --;\n\n\t\t}\n\n\t\twhile ( i < 0 ) {\n\n\t\t\tedge = edge.prev;\n\t\t\ti ++;\n\n\t\t}\n\n\t\treturn edge;\n\n\t},\n\n\tcompute: function () {\n\n\t\tvar triangle;\n\n\t\treturn function compute() {\n\n\t\t\tif ( triangle === undefined ) triangle = new THREE.Triangle();\n\n\t\t\tvar a = this.edge.tail();\n\t\t\tvar b = this.edge.head();\n\t\t\tvar c = this.edge.next.head();\n\n\t\t\ttriangle.set( a.point, b.point, c.point );\n\n\t\t\ttriangle.getNormal( this.normal );\n\t\t\ttriangle.getMidpoint( this.midpoint );\n\t\t\tthis.area = triangle.getArea();\n\n\t\t\tthis.constant = this.normal.dot( this.midpoint );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\tdistanceToPoint: function ( point ) {\n\n\t\treturn this.normal.dot( point ) - this.constant;\n\n\t}\n\n} );\n\n// Entity for a Doubly-Connected Edge List (DCEL).\n\nfunction HalfEdge( vertex, face ) {\n\n\tthis.vertex = vertex;\n\tthis.prev = null;\n\tthis.next = null;\n\tthis.twin = null;\n\tthis.face = face;\n\n}\n\nObject.assign( HalfEdge.prototype, {\n\n\thead: function () {\n\n\t\treturn this.vertex;\n\n\t},\n\n\ttail: function () {\n\n\t\treturn this.prev ? this.prev.vertex : null;\n\n\t},\n\n\tlength: function () {\n\n\t\tvar head = this.head();\n\t\tvar tail = this.tail();\n\n\t\tif ( tail !== null ) {\n\n\t\t\treturn tail.point.distanceTo( head.point );\n\n\t\t}\n\n\t\treturn - 1;\n\n\t},\n\n\tlengthSquared: function () {\n\n\t\tvar head = this.head();\n\t\tvar tail = this.tail();\n\n\t\tif ( tail !== null ) {\n\n\t\t\treturn tail.point.distanceToSquared( head.point );\n\n\t\t}\n\n\t\treturn - 1;\n\n\t},\n\n\tsetTwin: function ( edge ) {\n\n\t\tthis.twin = edge;\n\t\tedge.twin = this;\n\n\t\treturn this;\n\n\t}\n\n} );\n\n// A vertex as a double linked list node.\n\nfunction VertexNode( point ) {\n\n\tthis.point = point;\n\tthis.prev = null;\n\tthis.next = null;\n\tthis.face = null; // the face that is able to see this vertex\n\n}\n\n// A double linked list that contains vertex nodes.\n\nfunction VertexList() {\n\n\tthis.head = null;\n\tthis.tail = null;\n\n}\n\nObject.assign( VertexList.prototype, {\n\n\tfirst: function () {\n\n\t\treturn this.head;\n\n\t},\n\n\tlast: function () {\n\n\t\treturn this.tail;\n\n\t},\n\n\tclear: function () {\n\n\t\tthis.head = this.tail = null;\n\n\t\treturn this;\n\n\t},\n\n\t// Inserts a vertex before the target vertex\n\n\tinsertBefore: function ( target, vertex ) {\n\n\t\tvertex.prev = target.prev;\n\t\tvertex.next = target;\n\n\t\tif ( vertex.prev === null ) {\n\n\t\t\tthis.head = vertex;\n\n\t\t} else {\n\n\t\t\tvertex.prev.next = vertex;\n\n\t\t}\n\n\t\ttarget.prev = vertex;\n\n\t\treturn this;\n\n\t},\n\n\t// Inserts a vertex after the target vertex\n\n\tinsertAfter: function ( target, vertex ) {\n\n\t\tvertex.prev = target;\n\t\tvertex.next = target.next;\n\n\t\tif ( vertex.next === null ) {\n\n\t\t\tthis.tail = vertex;\n\n\t\t} else {\n\n\t\t\tvertex.next.prev = vertex;\n\n\t\t}\n\n\t\ttarget.next = vertex;\n\n\t\treturn this;\n\n\t},\n\n\t// Appends a vertex to the end of the linked list\n\n\tappend: function ( vertex ) {\n\n\t\tif ( this.head === null ) {\n\n\t\t\tthis.head = vertex;\n\n\t\t} else {\n\n\t\t\tthis.tail.next = vertex;\n\n\t\t}\n\n\t\tvertex.prev = this.tail;\n\t\tvertex.next = null; // the tail has no subsequent vertex\n\n\t\tthis.tail = vertex;\n\n\t\treturn this;\n\n\t},\n\n\t// Appends a chain of vertices where 'vertex' is the head.\n\n\tappendChain: function ( vertex ) {\n\n\t\tif ( this.head === null ) {\n\n\t\t\tthis.head = vertex;\n\n\t\t} else {\n\n\t\t\tthis.tail.next = vertex;\n\n\t\t}\n\n\t\tvertex.prev = this.tail;\n\n\t\t// ensure that the 'tail' reference points to the last vertex of the chain\n\n\t\twhile ( vertex.next !== null ) {\n\n\t\t\tvertex = vertex.next;\n\n\t\t}\n\n\t\tthis.tail = vertex;\n\n\t\treturn this;\n\n\t},\n\n\t// Removes a vertex from the linked list\n\n\tremove: function ( vertex ) {\n\n\t\tif ( vertex.prev === null ) {\n\n\t\t\tthis.head = vertex.next;\n\n\t\t} else {\n\n\t\t\tvertex.prev.next = vertex.next;\n\n\t\t}\n\n\t\tif ( vertex.next === null ) {\n\n\t\t\tthis.tail = vertex.prev;\n\n\t\t} else {\n\n\t\t\tvertex.next.prev = vertex.prev;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\t// Removes a list of vertices whose 'head' is 'a' and whose 'tail' is b\n\n\tremoveSubList: function ( a, b ) {\n\n\t\tif ( a.prev === null ) {\n\n\t\t\tthis.head = b.next;\n\n\t\t} else {\n\n\t\t\ta.prev.next = b.next;\n\n\t\t}\n\n\t\tif ( b.next === null ) {\n\n\t\t\tthis.tail = a.prev;\n\n\t\t} else {\n\n\t\t\tb.next.prev = a.prev;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tisEmpty: function () {\n\n\t\treturn this.head === null;\n\n\t}\n\n} );","/**\n * @author Mugen87 / https://github.com/Mugen87\n * \n * adapted for Typescript by Gheric Speiginer\n */\n\nimport * as THREE from 'three'\nimport {QuickHull} from './QuickHull'\n\n// ConvexGeometry\nexport class ConvexGeometry extends THREE.Geometry {\n\n    constructor(public points:THREE.Vector3[]) {\n        super()\n        this.fromBufferGeometry( new ConvexBufferGeometry( points ) );\n        this.mergeVertices();\n    }\n\n}\n\n// ConvexBufferGeometry\n\nexport class ConvexBufferGeometry extends THREE.BufferGeometry { \n\n    constructor(public points:THREE.Vector3[]) {\n        super()\n\n        // buffers\n\n        var vertices = [] as number[];\n        var normals = [] as number[];\n\n        // execute QuickHull\n\n        if ( QuickHull === undefined ) {\n\n            console.error( 'THREE.ConvexBufferGeometry: ConvexBufferGeometry relies on THREE.QuickHull' );\n\n        }\n\n        var quickHull = new (QuickHull as any)().setFromPoints( points );\n\n        // generate vertices and normals\n\n        var faces = quickHull.faces;\n\n        for ( var i = 0; i < faces.length; i ++ ) {\n\n            var face = faces[ i ];\n            var edge = face.edge;\n\n            // we move along a doubly-connected edge list to access all face points (see HalfEdge docs)\n\n            do {\n\n                var point = edge.head().point;\n\n                vertices.push( point.x, point.y, point.z );\n                normals.push( face.normal.x, face.normal.y, face.normal.z );\n\n                edge = edge.next;\n\n            } while ( edge !== face.edge );\n\n        }\n\n        // build geometry\n\n        this.addAttribute( 'position', new THREE.Float32BufferAttribute( vertices, 3 ) );\n        this.addAttribute( 'normal', new THREE.Float32BufferAttribute( normals, 3 ) );\n    }\n}","/*\n *\t@author zz85 / http://twitter.com/blurspline / http://www.lab4games.net/zz85/blog\n *\n *\tSimplification Geometry Modifier\n *    - based on code and technique\n *\t  - by Stan Melax in 1998\n *\t  - Progressive Mesh type Polygon Reduction Algorithm\n *    - http://www.melax.com/polychop/\n */\n\nimport * as THREE from 'three'\n\nexport var SimplifyModifier = function () {};\n\n( function () {\n\n\tvar cb = new THREE.Vector3(), ab = new THREE.Vector3();\n\n\tfunction pushIfUnique( array, object ) {\n\n\t\tif ( array.indexOf( object ) === - 1 ) array.push( object );\n\n\t}\n\n\tfunction removeFromArray( array, object ) {\n\n\t\tvar k = array.indexOf( object );\n\t\tif ( k > - 1 ) array.splice( k, 1 );\n\n\t}\n\n\tfunction computeEdgeCollapseCost( u, v ) {\n\n\t\t// if we collapse edge uv by moving u to v then how\n\t\t// much different will the model change, i.e. the \"error\".\n\n\t\tvar edgelength = v.position.distanceTo( u.position );\n\t\tvar curvature = 0;\n\n\t\tvar sideFaces = [];\n\t\tvar i, il = u.faces.length, face, sideFace;\n\n\t\t// find the \"sides\" triangles that are on the edge uv\n\t\tfor ( i = 0; i < il; i ++ ) {\n\n\t\t\tface = u.faces[ i ];\n\n\t\t\tif ( face.hasVertex( v ) ) {\n\n\t\t\t\tsideFaces.push( face );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// use the triangle facing most away from the sides\n\t\t// to determine our curvature term\n\t\tfor ( i = 0; i < il; i ++ ) {\n\n\t\t\tvar minCurvature = 1;\n\t\t\tface = u.faces[ i ];\n\n\t\t\tfor ( var j = 0; j < sideFaces.length; j ++ ) {\n\n\t\t\t\tsideFace = sideFaces[ j ];\n\t\t\t\t// use dot product of face normals.\n\t\t\t\tvar dotProd = face.normal.dot( sideFace.normal );\n\t\t\t\tminCurvature = Math.min( minCurvature, ( 1.001 - dotProd ) / 2 );\n\n\t\t\t}\n\n\t\t\tcurvature = Math.max( curvature, minCurvature );\n\n\t\t}\n\n\t\t// crude approach in attempt to preserve borders\n\t\t// though it seems not to be totally correct\n\t\tvar borders = 0;\n\t\tif ( sideFaces.length < 2 ) {\n\n\t\t\t// we add some arbitrary cost for borders,\n\t\t\t// borders += 10;\n\t\t\tcurvature = 1;\n\n\t\t}\n\n\t\tvar amt = edgelength * curvature + borders;\n\n\t\treturn amt;\n\n\t}\n\n\tfunction computeEdgeCostAtVertex( v ) {\n\n\t\t// compute the edge collapse cost for all edges that start\n\t\t// from vertex v.  Since we are only interested in reducing\n\t\t// the object by selecting the min cost edge at each step, we\n\t\t// only cache the cost of the least cost edge at this vertex\n\t\t// (in member variable collapse) as well as the value of the\n\t\t// cost (in member variable collapseCost).\n\n\t\tif ( v.neighbors.length === 0 ) {\n\n\t\t\t// collapse if no neighbors.\n\t\t\tv.collapseNeighbor = null;\n\t\t\tv.collapseCost = - 0.01;\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tv.collapseCost = 100000;\n\t\tv.collapseNeighbor = null;\n\n\t\t// search all neighboring edges for \"least cost\" edge\n\t\tfor ( var i = 0; i < v.neighbors.length; i ++ ) {\n\n\t\t\tvar collapseCost = computeEdgeCollapseCost( v, v.neighbors[ i ] );\n\n\t\t\tif ( ! v.collapseNeighbor ) {\n\n\t\t\t\tv.collapseNeighbor = v.neighbors[ i ];\n\t\t\t\tv.collapseCost = collapseCost;\n\t\t\t\tv.minCost = collapseCost;\n\t\t\t\tv.totalCost = 0;\n\t\t\t\tv.costCount = 0;\n\n\t\t\t}\n\n\t\t\tv.costCount ++;\n\t\t\tv.totalCost += collapseCost;\n\n\t\t\tif ( collapseCost < v.minCost ) {\n\n\t\t\t\tv.collapseNeighbor = v.neighbors[ i ];\n\t\t\t\tv.minCost = collapseCost;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// we average the cost of collapsing at this vertex\n\t\tv.collapseCost = v.totalCost / v.costCount;\n\t\t// v.collapseCost = v.minCost;\n\n\t}\n\n\tfunction removeVertex( v, vertices ) {\n\n\t\tconsole.assert( v.faces.length === 0 );\n\n\t\twhile ( v.neighbors.length ) {\n\n\t\t\tvar n = v.neighbors.pop();\n\t\t\tremoveFromArray( n.neighbors, v );\n\n\t\t}\n\n\t\tremoveFromArray( vertices, v );\n\n\t}\n\n\tfunction removeFace( f, faces ) {\n\n\t\tremoveFromArray( faces, f );\n\n\t\tif ( f.v1 ) removeFromArray( f.v1.faces, f );\n\t\tif ( f.v2 ) removeFromArray( f.v2.faces, f );\n\t\tif ( f.v3 ) removeFromArray( f.v3.faces, f );\n\n\t\t// TODO optimize this!\n\t\tvar vs = [ f.v1, f.v2, f.v3 ];\n\t\tvar v1, v2;\n\n\t\tfor ( var i = 0; i < 3; i ++ ) {\n\n\t\t\tv1 = vs[ i ];\n\t\t\tv2 = vs[ ( i + 1 ) % 3 ];\n\n\t\t\tif ( ! v1 || ! v2 ) continue;\n\n\t\t\tv1.removeIfNonNeighbor( v2 );\n\t\t\tv2.removeIfNonNeighbor( v1 );\n\n\t\t}\n\n\t}\n\n\tfunction collapse( vertices, faces, u, v ) { // u and v are pointers to vertices of an edge\n\n\t\t// Collapse the edge uv by moving vertex u onto v\n\n\t\tif ( ! v ) {\n\n\t\t\t// u is a vertex all by itself so just delete it..\n\t\t\tremoveVertex( u, vertices );\n\t\t\treturn;\n\n\t\t}\n\n\t\tvar i;\n\t\tvar tmpVertices = [];\n\n\t\tfor ( i = 0; i < u.neighbors.length; i ++ ) {\n\n\t\t\ttmpVertices.push( u.neighbors[ i ] );\n\n\t\t}\n\n\n\t\t// delete triangles on edge uv:\n\t\tfor ( i = u.faces.length - 1; i >= 0; i -- ) {\n\n\t\t\tif ( u.faces[ i ].hasVertex( v ) ) {\n\n\t\t\t\tremoveFace( u.faces[ i ], faces );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// update remaining triangles to have v instead of u\n\t\tfor ( i = u.faces.length - 1; i >= 0; i -- ) {\n\n\t\t\tu.faces[ i ].replaceVertex( u, v );\n\n\t\t}\n\n\n\t\tremoveVertex( u, vertices );\n\n\t\t// recompute the edge collapse costs in neighborhood\n\t\tfor ( i = 0; i < tmpVertices.length; i ++ ) {\n\n\t\t\tcomputeEdgeCostAtVertex( tmpVertices[ i ] );\n\n\t\t}\n\n\t}\n\n\n\n\tfunction minimumCostEdge( vertices ) {\n\n\t\t// O(n * n) approach. TODO optimize this\n\n\t\tvar least = vertices[ 0 ];\n\n\t\tfor ( var i = 0; i < vertices.length; i ++ ) {\n\n\t\t\tif ( vertices[ i ].collapseCost < least.collapseCost ) {\n\n\t\t\t\tleast = vertices[ i ];\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn least;\n\n\t}\n\n\t// we use a triangle class to represent structure of face slightly differently\n\n\tfunction Triangle( v1, v2, v3, a, b, c ) {\n\n\t\tthis.a = a;\n\t\tthis.b = b;\n\t\tthis.c = c;\n\n\t\tthis.v1 = v1;\n\t\tthis.v2 = v2;\n\t\tthis.v3 = v3;\n\n\t\tthis.normal = new THREE.Vector3();\n\n\t\tthis.computeNormal();\n\n\t\tv1.faces.push( this );\n\t\tv1.addUniqueNeighbor( v2 );\n\t\tv1.addUniqueNeighbor( v3 );\n\n\t\tv2.faces.push( this );\n\t\tv2.addUniqueNeighbor( v1 );\n\t\tv2.addUniqueNeighbor( v3 );\n\n\n\t\tv3.faces.push( this );\n\t\tv3.addUniqueNeighbor( v1 );\n\t\tv3.addUniqueNeighbor( v2 );\n\n\t}\n\n\tTriangle.prototype.computeNormal = function () {\n\n\t\tvar vA = this.v1.position;\n\t\tvar vB = this.v2.position;\n\t\tvar vC = this.v3.position;\n\n\t\tcb.subVectors( vC, vB );\n\t\tab.subVectors( vA, vB );\n\t\tcb.cross( ab ).normalize();\n\n\t\tthis.normal.copy( cb );\n\n\t};\n\n\tTriangle.prototype.hasVertex = function ( v ) {\n\n\t\treturn v === this.v1 || v === this.v2 || v === this.v3;\n\n\t};\n\n\tTriangle.prototype.replaceVertex = function ( oldv, newv ) {\n\n\t\tif ( oldv === this.v1 ) this.v1 = newv;\n\t\telse if ( oldv === this.v2 ) this.v2 = newv;\n\t\telse if ( oldv === this.v3 ) this.v3 = newv;\n\n\t\tremoveFromArray( oldv.faces, this );\n\t\tnewv.faces.push( this );\n\n\n\t\toldv.removeIfNonNeighbor( this.v1 );\n\t\tthis.v1.removeIfNonNeighbor( oldv );\n\n\t\toldv.removeIfNonNeighbor( this.v2 );\n\t\tthis.v2.removeIfNonNeighbor( oldv );\n\n\t\toldv.removeIfNonNeighbor( this.v3 );\n\t\tthis.v3.removeIfNonNeighbor( oldv );\n\n\t\tthis.v1.addUniqueNeighbor( this.v2 );\n\t\tthis.v1.addUniqueNeighbor( this.v3 );\n\n\t\tthis.v2.addUniqueNeighbor( this.v1 );\n\t\tthis.v2.addUniqueNeighbor( this.v3 );\n\n\t\tthis.v3.addUniqueNeighbor( this.v1 );\n\t\tthis.v3.addUniqueNeighbor( this.v2 );\n\n\t\tthis.computeNormal();\n\n\t};\n\n\tfunction Vertex( v, id ) {\n\n\t\tthis.position = v;\n\n\t\tthis.id = id; // old index id\n\n\t\tthis.faces = []; // faces vertex is connected\n\t\tthis.neighbors = []; // neighbouring vertices aka \"adjacentVertices\"\n\n\t\t// these will be computed in computeEdgeCostAtVertex()\n\t\tthis.collapseCost = 0; // cost of collapsing this vertex, the less the better. aka objdist\n\t\tthis.collapseNeighbor = null; // best candinate for collapsing\n\n\t}\n\n\tVertex.prototype.addUniqueNeighbor = function ( vertex ) {\n\n\t\tpushIfUnique( this.neighbors, vertex );\n\n\t};\n\n\tVertex.prototype.removeIfNonNeighbor = function ( n ) {\n\n\t\tvar neighbors = this.neighbors;\n\t\tvar faces = this.faces;\n\n\t\tvar offset = neighbors.indexOf( n );\n\t\tif ( offset === - 1 ) return;\n\t\tfor ( var i = 0; i < faces.length; i ++ ) {\n\n\t\t\tif ( faces[ i ].hasVertex( n ) ) return;\n\n\t\t}\n\n\t\tneighbors.splice( offset, 1 );\n\n\t};\n\n\tSimplifyModifier.prototype.modify = function ( geometry, count ) {\n\n\t\tif ( geometry.isBufferGeometry ) {\n\n\t\t\tgeometry = new THREE.Geometry().fromBufferGeometry( geometry );\n\n\t\t}\n\n\t\tgeometry.mergeVertices();\n\n\t\tvar oldVertices = geometry.vertices; // Three Position\n\t\tvar oldFaces = geometry.faces; // Three Face\n\n\t\t// conversion\n\t\tvar vertices = [];\n\t\tvar faces = [];\n\n\t\tvar i, il;\n\n\t\t//\n\t\t// put data of original geometry in different data structures\n\t\t//\n\n\t\t// add vertices\n\n\t\tfor ( i = 0, il = oldVertices.length; i < il; i ++ ) {\n\n\t\t\tvar vertex = new Vertex( oldVertices[ i ], i );\n\t\t\tvertices.push( vertex );\n\n\t\t}\n\n\t\t// add faces\n\n\t\tfor ( i = 0, il = oldFaces.length; i < il; i ++ ) {\n\n\t\t\tvar face = oldFaces[ i ];\n\n\t\t\tvar a = face.a;\n\t\t\tvar b = face.b;\n\t\t\tvar c = face.c;\n\n\t\t\tvar triangle = new Triangle( vertices[ a ], vertices[ b ], vertices[ c ], a, b, c );\n\t\t\tfaces.push( triangle );\n\n\t\t}\n\n\t\t// compute all edge collapse costs\n\n\t\tfor ( i = 0, il = vertices.length; i < il; i ++ ) {\n\n\t\t\tcomputeEdgeCostAtVertex( vertices[ i ] );\n\n\t\t}\n\n\t\tvar nextVertex;\n\n\t\tvar z = count;\n\n\t\twhile ( z -- ) {\n\n\t\t\tnextVertex = minimumCostEdge( vertices );\n\n\t\t\tif ( ! nextVertex ) {\n\n\t\t\t\tconsole.log( 'THREE.SimplifyModifier: No next vertex' );\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tcollapse( vertices, faces, nextVertex, nextVertex.collapseNeighbor );\n\n\t\t}\n\n\t\t//\n\n\t\tvar simplifiedGeometry = new THREE.BufferGeometry();\n\t\tvar position = [];\n\t\tvar index = [];\n\n\t\t//\n\n\t\tfor ( i = 0; i < vertices.length; i ++ ) {\n\n\t\t\tvar vertex = vertices[ i ].position;\n\t\t\tposition.push( vertex.x, vertex.y, vertex.z );\n\n\t\t}\n\n\t\t//\n\n\t\tfor ( i = 0; i < faces.length; i ++ ) {\n\n\t\t\tvar face = faces[ i ];\n\n\t\t\tvar a = vertices.indexOf( face.v1 );\n\t\t\tvar b = vertices.indexOf( face.v2 );\n\t\t\tvar c = vertices.indexOf( face.v3 );\n\n\t\t\tindex.push( a, b, c );\n\n\t\t}\n\n\t\t//\n\n\t\tsimplifiedGeometry.addAttribute( 'position', new THREE.Float32BufferAttribute( position, 3 ) );\n\t\tsimplifiedGeometry.setIndex( index );\n\n\t\treturn simplifiedGeometry;\n\n\t};\n\n} )();\n","import * as THREE from 'three'\nimport {vectors2, vectors, quaternions, matrices, traverse, V_000, V_001, V_010} from '../utils'\nimport {ConvexGeometry} from './ConvexGeometry'\nimport {SimplifyModifier} from './SimplifyModifier'\n\nexport class SimplifiedHull {\n    static hulls = new WeakMap<THREE.Geometry|THREE.BufferGeometry, THREE.Geometry|undefined>()\n  \n    static compute(geometry:THREE.Geometry|THREE.BufferGeometry, maxPoints = 30) {\n      const bufferGeometry = (geometry as THREE.BufferGeometry).type === 'BufferGeometry' ? \n        geometry as THREE.BufferGeometry : null\n      const normalGeometry = bufferGeometry ? \n        new THREE.Geometry().fromBufferGeometry(bufferGeometry) : geometry as THREE.Geometry\n      if (normalGeometry.vertices.length < maxPoints) {\n        this.hulls.set(geometry, normalGeometry)\n        return normalGeometry\n      }\n    \n      const modifier = new (SimplifyModifier as any)()\n      let hull = new ConvexGeometry(normalGeometry.vertices) as THREE.Geometry\n      const count = hull.vertices.length\n      if (count > maxPoints) {\n        const simplified = modifier.modify( hull, hull.vertices.length - maxPoints )\n        hull = new THREE.Geometry().fromBufferGeometry(simplified)\n      }\n      this.hulls.set(geometry, hull)\n      return hull\n    } \n    \n    static get(geometry:THREE.Geometry|THREE.BufferGeometry) {\n        return this.hulls.get(geometry) || geometry\n    }\n}\n\nexport class Box3 extends THREE.Box3 {\n    objectFilter? = SpatialMetrics.objectFilter\n    objectExpansion = 'box' as 'geometry'|'hull'|'box'\n    coordinateSystem = undefined as THREE.Object3D|undefined\n\n    private _objectExpandFunction:(o:THREE.Object3D)=>void\n\n    private _onObjectTraverse( node: THREE.Object3D, ) {\n        if (this.objectFilter && !this.objectFilter(node)) return false\n        this._objectExpandFunction.call(this, node)\n        return true\n    }\n\n    setFromObject( object:THREE.Object3D ) {\n\n        this.makeEmpty()\n\n        switch (this.objectExpansion) {\n            case 'geometry': this._objectExpandFunction = this.expandByObjectGeometry; break;\n            case 'hull': this._objectExpandFunction = this.expandByObjectHull; break;\n            case 'box':   \n            default: this._objectExpandFunction = this.expandByObjectBox; break;\n        }\n\n        this._objectExpandFunction.call(this, object)\n        for (const c of object.children) {\n            traverse(c, this._onObjectTraverse, this)\n        }\n\n        return this\n    }\n\n    private _vector = new THREE.Vector3\n    private _mat4 = new THREE.Matrix4\n\n    expandByObjectGeometry ( node: THREE.Object3D ) {\n        let i, l\n        const vector = this._vector\n        const mesh = node as THREE.Mesh\n\t\tnode.updateWorldMatrix( false, false )\n\t\tvar geometry = mesh.geometry as THREE.Geometry&THREE.BufferGeometry\n\t\tif ( geometry !== undefined ) {\n            const mat = this._getCoordinateSystemTransform(node)\n\t\t\tif ( geometry.isGeometry ) {\n\t\t\t\tvar vertices = geometry.vertices\n\t\t\t\tfor ( i = 0, l = vertices.length; i < l; i ++ ) {\n\t\t\t\t\tvector.copy( vertices[ i ] )\n\t\t\t\t\tvector.applyMatrix4( mat )\n\t\t\t\t\tthis.expandByPoint( vector )\n\t\t\t\t}\n\t\t\t} else if ( geometry.isBufferGeometry ) {\n\t\t\t\tvar attribute = geometry.attributes.position\n\t\t\t\tif ( attribute !== undefined ) {\n\t\t\t\t\tfor ( i = 0, l = attribute.count; i < l; i ++ ) {\n\t\t\t\t\t\tvector.fromBufferAttribute( attribute as any, i ).applyMatrix4( mat )\n\t\t\t\t\t\tthis.expandByPoint( vector )\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn this\n    }\n\n    expandByObjectHull( node: THREE.Object3D ) {\n        const mesh = node as THREE.Mesh\n        const vector = this._vector\n        let geometry = mesh.geometry\n        if (!geometry) return this\n        const mat = this._getCoordinateSystemTransform(node) \n        geometry = SimplifiedHull.get(geometry)\n        if (geometry && 'vertices' in geometry) {\n            const vertices = geometry.vertices    \n            for (let i = 0; i < vertices.length; ++i) {\n                const v = vertices[i]\n                vector.copy( v ).applyMatrix4( mat )\n                this.expandByPoint( vector )\n            }\n        } else {\n            const vertices = geometry.getAttribute('position')  \n            for (let i = 0; i < vertices.count; i+=vertices.itemSize) {\n                vector.set( vertices.getX(i), vertices.getY(i), vertices.getZ(i) ).applyMatrix4( mat )\n                this.expandByPoint( vector )\n            }\n        }\n        return this\n    }\n\n    private _box = new THREE.Box3\n\n    expandByObjectBox ( node:THREE.Object3D ) {\n        const box = this._box\n        const mesh = node as THREE.Mesh\n        const geometry = mesh.geometry\n        if (!geometry) return this\n        if ( geometry.boundingBox === null ) {\n            geometry.computeBoundingBox()\n        }\n        box.copy( geometry.boundingBox )\n        box.applyMatrix4( this._getCoordinateSystemTransform(node) )\n        this.union( box )\n        return this\n    }\n\n    private _getCoordinateSystemTransform(node: THREE.Object3D) {\n        const mat4 = this._mat4\n        if (this.coordinateSystem) {\n            mat4.getInverse(this.coordinateSystem.transitioner.matrixWorldTarget).multiply( node.transitioner.matrixWorldTarget )\n        } else {\n            mat4.copy( node.transitioner.matrixWorldTarget )\n        }\n        return mat4\n    }\n\n    private _center = new THREE.Vector3\n    private _size = new THREE.Vector3\n\n    relativeToAbsolute(relativePosition:THREE.Vector3, out = relativePosition) {\n        if (!this.isEmpty()) {\n            const center = this._center\n            const size = this._size\n            this.getCenter(center)\n            this.getSize(size)\n            out.copy(relativePosition).multiplyScalar(0.5).multiply(size).add(center)\n        } else {\n            out.copy(relativePosition).multiplyScalar(0)\n        }\n        // if (!isFinite(out.x)) out.x = 0\n        // if (!isFinite(out.y)) out.y = 0\n        // if (!isFinite(out.z)) out.z = 0\n        return out\n    }\n\n    absoluteToRelative(absolutePosition:THREE.Vector3, out = absolutePosition) {\n        if (!this.isEmpty()) {  \n            const center = this._center\n            const size = this._size\n            this.getCenter(center)\n            this.getSize(size)\n            out.copy(absolutePosition).sub(center).divide(size).multiplyScalar(2)\n        } else {\n            out.copy(absolutePosition).multiplyScalar(0)\n        }\n        // if (!isFinite(out.x)) out.x = 0\n        // if (!isFinite(out.y)) out.y = 0\n        // if (!isFinite(out.z)) out.z = 0\n        return out\n    }\n\n    isEmpty() {\n        return !isFinite(this.min.x) && !isFinite(this.min.y) && !isFinite(this.min.z) &&\n        !isFinite(this.max.x) && !isFinite(this.max.y) && !isFinite(this.max.z)\n    }\n}\n\nconst rotateY180 = new THREE.Quaternion().setFromAxisAngle(V_010, Math.PI)\n\n/**\n * A visual viewing frustum, with angles specified in DEGREES\n */\nexport class VisualFrustum {\n    \n    objectFilter? = SpatialMetrics.objectFilter\n    objectExpansion = 'box' as 'geometry'|'hull'|'box'\n    private _objectExpandFunction:(o:THREE.Object3D)=>void\n\n    min = new THREE.Vector3(Infinity,Infinity,Infinity)\n    max = new THREE.Vector3(-Infinity,-Infinity,-Infinity)\n    minClamped = new THREE.Vector3\n    maxClamped = new THREE.Vector3\n\n    minClamp?:THREE.Vector3\n    maxClamp?:THREE.Vector3\n\n    constructor(public coordinateSystem: THREE.Object3D) {}\n\n    get left() {\n        if (this.isEmpty()) return 0\n        return this.min.x\n    }\n\n    get leftClamped() {\n        if (this.isEmpty()) return 0\n        return this.minClamped.x\n    } \n\n    get top() {\n        if (this.isEmpty()) return 0\n        return this.max.y\n    }\n\n    get topClamped() {\n        if (this.isEmpty()) return 0\n        return this.maxClamped.y\n    }\n\n    get right() {\n        if (this.isEmpty()) return 0\n        return this.max.x   \n    }\n\n    get rightClamped() {\n        if (this.isEmpty()) return 0\n        return this.maxClamped.x   \n    }\n\n    get bottom() {\n        if (this.isEmpty()) return 0\n        return this.min.y\n    }\n\n    get bottomClamped() {\n        if (this.isEmpty()) return 0\n        return this.minClamped.y \n    }\n\n    get near() {\n        if (this.isEmpty()) return 0\n        return this.min.z\n    }\n\n    get nearClamped() {\n        if (this.isEmpty()) return 0\n        return this.minClamped.z\n    }\n\n    get far() {\n        if (this.isEmpty()) return 0\n        return this.max.z\n    }\n\n    get farClamped() {\n        if (this.isEmpty()) return 0\n        return this.maxClamped.z\n    }\n\n    get horizontal() {\n        if (this.isEmpty()) return 0\n        return this.right - this.left\n    }\n\n    get horizontalClamped() {\n        if (this.isEmpty()) return 0\n        return this.rightClamped - this.leftClamped\n    }\n\n    get vertical() {\n        if (this.isEmpty()) return 0\n        return this.top - this.bottom\n    }\n\n    get verticalClamped() {\n        if (this.isEmpty()) return 0\n        return this.topClamped - this.bottomClamped\n    }\n\n    get depth() {\n        if (this.isEmpty()) return 0\n        return this.far - this.near\n    }\n\n    get depthClamped() {\n        if (this.isEmpty()) return 0\n        return this.farClamped - this.nearClamped\n    }\n\n    get diagonal() {\n        if (this.isEmpty()) return 0\n        const minDirection = SpatialMetrics.getCartesianForSphericalDirection(this.min, vectors.get())\n        const maxDirection = SpatialMetrics.getCartesianForSphericalDirection(this.max, vectors.get())\n        const diagonal = minDirection.angleTo(maxDirection)\n        vectors.pool(minDirection)\n        vectors.pool(maxDirection)\n        return diagonal * THREE.Math.RAD2DEG\n    }\n\n    get diagonalClamped() {\n        if (this.isEmpty()) return 0\n        const minDirection = SpatialMetrics.getCartesianForSphericalDirection(this.minClamped, vectors.get())\n        const maxDirection = SpatialMetrics.getCartesianForSphericalDirection(this.maxClamped, vectors.get())\n        const diagonal = minDirection.angleTo(maxDirection)\n        vectors.pool(minDirection)\n        vectors.pool(maxDirection)\n        return diagonal * THREE.Math.RAD2DEG\n    }\n\n\tisEmpty(){\n\t\treturn this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z\n\t}\n\n    getCenter(out:THREE.Vector3) {\n        return out.set( \n            this.right - this.horizontal / 2, \n            this.top - this.vertical / 2,\n            this.far - this.depth / 2,\n        )\n    }\n\n    getClampedCenter(out:THREE.Vector3) {\n        return out.set( \n            this.rightClamped - this.horizontalClamped / 2, \n            this.topClamped - this.verticalClamped / 2,\n            this.farClamped - this.depthClamped / 2,\n        )\n    }\n\n    getSize(out:THREE.Vector3) {\n        return out.set(\n            this.horizontal, \n            this.vertical, \n            this.depth\n        )\n    }\n\n    getClampedSize(out:THREE.Vector3) {\n        return out.set(\n            this.horizontalClamped, \n            this.verticalClamped, \n            this.depthClamped\n        )\n    }\n\n    getPositionForOffset(offset:THREE.Vector3, out:THREE.Vector3) {\n        const center = this.getCenter(vectors.get())\n        const size = this.getSize(vectors.get())\n        out.copy(offset).multiplyScalar(0.5).multiply(size).add(center)\n        vectors.pool(center)\n        vectors.pool(size)\n        return out\n    }\n\n    getClampedPositionForOffset(offset:THREE.Vector3, out:THREE.Vector3) {\n        const center = this.getClampedCenter(vectors.get())\n        const size = this.getClampedSize(vectors.get())\n        out.copy(offset).multiplyScalar(0.5).multiply(size).add(center)\n        vectors.pool(center) \n        vectors.pool(size)\n        return out\n    }\n    \n    setFromPerspectiveProjectionMatrix(projectionMatrix:THREE.Matrix4) {\n        const inverseProjection = matrices.get().getInverse(projectionMatrix)\n        const vec = vectors.get()\n        this.min.x = -vec.set(-1,0,-1).applyMatrix4(inverseProjection).angleTo(V_001) * THREE.Math.RAD2DEG\n        this.max.x = vec.set(1,0,-1).applyMatrix4(inverseProjection).angleTo(V_001) * THREE.Math.RAD2DEG\n        this.min.y = -vec.set(0,-1,-1).applyMatrix4(inverseProjection).angleTo(V_001) * THREE.Math.RAD2DEG\n        this.max.y = vec.set(0,1,-1).applyMatrix4(inverseProjection).angleTo(V_001) * THREE.Math.RAD2DEG\n        this.min.z = -vec.set(0,0,-1).applyMatrix4(inverseProjection).z\n        this.max.z = -vec.set(0,0,1).applyMatrix4(inverseProjection).z\n        matrices.pool(inverseProjection)\n        vectors.pool(vec)\n        this._applyClamping()\n    }\n\n    makeEmpty() {\n        this.min.set(Infinity,Infinity,Infinity)\n        this.max.set(-Infinity,-Infinity,-Infinity)\n    }\n\n    setFromObject( object:THREE.Object3D ) {\n\n        this.makeEmpty()\n\n        switch (this.objectExpansion) {\n            case 'geometry': //this._objectExpandFunction = this.expandByObjectGeometry; break;\n            case 'hull': this._objectExpandFunction = this.expandByObjectHull; break;\n            case 'box':   \n            default: this._objectExpandFunction = this.expandByObjectBox; break;\n        }\n\n        this._objectExpandFunction.call(this, object)\n        for (const c of object.children) {\n            traverse(c, this._onObjectTraverse, this)\n        }\n\n        return this\n    }\n    \n    private _onObjectTraverse( node: THREE.Object3D, ) {\n        if (this.objectFilter && !this.objectFilter(node)) return false\n        this._objectExpandFunction.call(this, node)\n        return true\n    }\n\n    private _vec3 = new THREE.Vector3\n    private _mat4 = new THREE.Matrix4\n\n    private expandByObjectHull(object:THREE.Object3D) {\n        const m = object as THREE.Mesh\n        if (!m.isMesh) return\n\n        const coordinateSystem = this.coordinateSystem\n        const vertexPosition = this._vec3\n        const localToReferenceFrame = this._mat4.getInverse(coordinateSystem.matrixWorld).multiply(m.matrixWorld)\n        const hull = SimplifiedHull.get(m.geometry)!\n        const metrics = SpatialMetrics.get(coordinateSystem)\n\n        if ('vertices' in hull) {\n            for (const vertex of hull.vertices) {\n                vertexPosition.copy(vertex).applyMatrix4(localToReferenceFrame)\n                const vertexVisualPosition = metrics.getVisualPositionForCartesianPosition(vertexPosition, vertexPosition)\n                this.min.min(vertexVisualPosition)\n                this.max.max(vertexVisualPosition)\n            }\n        } else {\n            const vertices = hull.getAttribute('position')\n            for (let i = 0; i < vertices.count; i += vertices.itemSize) {\n                vertexPosition.set(vertices.getX(i), vertices.getY(i), vertices.getZ(i)).applyMatrix4(localToReferenceFrame)\n                const vertexVisualPosition = metrics.getVisualPositionForCartesianPosition(vertexPosition, vertexPosition)\n                this.min.min(vertexVisualPosition)\n                this.max.max(vertexVisualPosition)\n            }\n        }\n\n        this._applyClamping()\n    }\n\n    private _boxPoints = [\n        new THREE.Vector3(),\n        new THREE.Vector3(),\n        new THREE.Vector3(),\n        new THREE.Vector3(),\n        new THREE.Vector3(),\n        new THREE.Vector3(),\n        new THREE.Vector3(),\n        new THREE.Vector3()\n    ] as THREE.Vector3[]\n\n    expandByObjectBox ( node:THREE.Object3D ) {\n        const mat4 = this._mat4\n        const mesh = node as THREE.Mesh\n        const geometry = mesh.geometry\n        if (!geometry) return this\n\n        if ( geometry.boundingBox === null ) {\n            geometry.computeBoundingBox()\n        }\n    \n        const box = geometry.boundingBox\n        const points = this._boxPoints\n\t\tpoints[ 0 ].set( box.min.x, box.min.y, box.min.z ) // 000\n\t\tpoints[ 1 ].set( box.min.x, box.min.y, box.max.z ) // 001\n\t\tpoints[ 2 ].set( box.min.x, box.max.y, box.min.z ) // 010\n\t\tpoints[ 3 ].set( box.min.x, box.max.y, box.max.z ) // 011\n\t\tpoints[ 4 ].set( box.max.x, box.min.y, box.min.z ) // 100\n\t\tpoints[ 5 ].set( box.max.x, box.min.y, box.max.z ) // 101\n\t\tpoints[ 6 ].set( box.max.x, box.max.y, box.min.z ) // 110\n        points[ 7 ].set( box.max.x, box.max.y, box.max.z ) // 111\n\n        const coordinateSystem = this.coordinateSystem\n        const metrics = SpatialMetrics.get(coordinateSystem)\n        const localToReferenceFrame = mat4.getInverse(coordinateSystem.matrixWorld).multiply(mesh.matrixWorld)\n\n        for (const p of points) {\n            p.applyMatrix4(localToReferenceFrame)\n            const vertexVisualPosition = metrics.getVisualPositionForCartesianPosition(p, p)\n            this.min.min(vertexVisualPosition)\n            this.max.max(vertexVisualPosition)\n        }\n        \n        this._applyClamping()\n    }\n\n    private _applyClamping() {\n        this.minClamped.copy(this.min)\n        this.maxClamped.copy(this.max)\n        if (this.minClamp) this.minClamped.min(this.minClamp)\n        if (this.maxClamp) this.maxClamped.max(this.maxClamp)\n    }\n\n}\n\n/**\n * Calculate spatial metrics between a primary object and a target object.\n *\n * The results are always in one of two *local* coordinate systems:\n * `object-space` -\n *      Local *cartesian* coordinate system [X,Y,Z]. By convention, this local coordinate system is\n *      interpreted in two different ways, depending on whether or not the object is a camera:\n *          Typical objects: [+X = left, +Y = up, +Z = forward]\n *          Camera objects: [+X = right, +Y = up, -Z = forward]\n * `visual-space` -\n *      Local *spherical* coordinate system [azimuth, elevation, distance], where:\n *          `azimuth` (-180 to 180 DEGREES) an angle around the horizontal plane\n *              (increasing from left to right, with 0deg being aligned with this object's natural `forward` vector)\n *          `elevation` (-90 to 90 DEGREES ) an angle above or below the horizontal plane\n *              (increases from below to above, with 0deg at the horizon)\n *          `distance` is distance along the direction defined by the azimuth and elevation\n *      Unlike object-space, visual-space is consistent for camera and non-camera objects.\n */\nexport class SpatialMetrics {\n\n    public matrixWorldGetter = 'target' as 'current' | 'target'\n\n    private static _metrics = new WeakMap<THREE.Object3D, SpatialMetrics>()\n\n    public static objectFilter = (o:THREE.Object3D) => !o.layout.isBoundingContext()\n\n    static get(o:THREE.Object3D) {\n        if (this._metrics.has(o)) return this._metrics.get(o)!\n        this._metrics.set(o, new SpatialMetrics(o))\n        return this._metrics.get(o)!\n    }\n\n    static getCartesianForSphericalDirection(sphericalDirection: THREE.Vector2|THREE.Vector3, out: THREE.Vector3) { \n        const visualElevationRadians = THREE.Math.DEG2RAD * sphericalDirection.y\n        const visualAzimuthRadians = THREE.Math.DEG2RAD * sphericalDirection.x\n        const y = Math.sin(visualElevationRadians)\n        const x = Math.cos(visualElevationRadians) * Math.sin(visualAzimuthRadians)\n        const z = - Math.cos(visualElevationRadians) * Math.cos(visualAzimuthRadians)\n        out.set(x, y, z).normalize()\n        return out\n    }\n\n    static getSphericalDirectionForCartesian(cartesian: THREE.Vector3, out: THREE.Vector2) {\n        const direction = vectors.get().copy(cartesian).normalize()\n        out.y = Math.asin(direction.y) * THREE.Math.RAD2DEG\n        out.x = Math.atan2(direction.x, -direction.z) * THREE.Math.RAD2DEG\n        vectors.pool(direction)\n        return out\n    }\n\n    static getSphericalPositionForCartesian(cartesian: THREE.Vector3, out: THREE.Vector3) {\n        const distance = cartesian.length()\n        const direction = out.copy(cartesian).normalize()\n        out.y = Math.asin(direction.y) * THREE.Math.RAD2DEG\n        out.x = Math.atan2(direction.x, -direction.z) * THREE.Math.RAD2DEG\n        out.z = distance\n        return out\n    }\n\n    static getCartesianForSphericalPosition(sphericalPosition:THREE.Vector3, out: THREE.Vector3) {\n        const distance = sphericalPosition.z\n        const visualDirection = vectors2.get().set(sphericalPosition.x, sphericalPosition.y)\n        SpatialMetrics.getCartesianForSphericalDirection(visualDirection, out).multiplyScalar(distance)\n        vectors2.pool(visualDirection)\n        return out\n    }\n\n    private constructor(public object: THREE.Object3D) {}\n\n    private getMatrixWorld(o:THREE.Object3D) {\n        return this.matrixWorldGetter === 'current' ? \n            o.matrixWorld : o.transitioner.matrixWorldTarget\n    }\n\n    getCartesianForVisualDirection(visualDirection: THREE.Vector2, out: THREE.Vector3) {\n        SpatialMetrics.getCartesianForSphericalDirection(visualDirection, out)\n        if (!(this.object as THREE.Camera).isCamera) { out.applyQuaternion(rotateY180) }\n        return out\n    }\n\n    getVisualDirectionForCartesian(cartesian: THREE.Vector3, out: THREE.Vector2) {\n        const cartesianPosition = vectors.get().copy(cartesian)\n        if (!(this.object as THREE.Camera).isCamera) { cartesianPosition.applyQuaternion(rotateY180) }\n        SpatialMetrics.getSphericalDirectionForCartesian(cartesianPosition, out)\n        vectors.pool(cartesianPosition)\n        return out\n    }\n\n    getVisualPositionForCartesianPosition(cartesianPosition: THREE.Vector3, out: THREE.Vector3) {\n        const position = out.copy(cartesianPosition)\n        if (!(this.object as THREE.Camera).isCamera) { position.applyQuaternion(rotateY180) }\n        SpatialMetrics.getSphericalPositionForCartesian(position, out)\n        return out\n    }\n\n    getCartesianForVisualPosition(visualPosition:THREE.Vector3, out: THREE.Vector3) {\n        const distance = visualPosition.z\n        const visualDirection = vectors2.get().set(visualPosition.x, visualPosition.y)\n        this.getCartesianForVisualDirection(visualDirection, out).multiplyScalar(distance)\n        vectors2.pool(visualDirection)\n        return out\n    }\n\n    /**\n     * Calculate the local position of target in `object space`\n     */\n    getPositionOf(target: THREE.Object3D, out: THREE.Vector3) {\n        out.setFromMatrixPosition(this.getMatrixWorld(target))  \n        const invMatrixWorld = matrices.get().getInverse(this.getMatrixWorld(this.object))\n        out.applyMatrix4(invMatrixWorld)\n        matrices.pool(invMatrixWorld)\n        return out\n    }\n\n    /**\n     * Calculate the local distance of the target object\n     * (Note: this is the same for both `object-space` and `visual-space`)\n     */\n    getDistanceOf(target: THREE.Object3D) {\n        const vec = vectors.get()\n        const result = this.getPositionOf(target, vec).length()\n        vectors.pool(vec)\n        return result\n    }\n\n    /**\n     * Calculate the local direction of the target object in `object-space`\n     *\n     * Remember, by convention:\n     *     Normal objects: [+X = left, +Y = up, +Z = forward]\n     *     Camera objects: [+X = right, +Y = up, -Z = forward]\n     * Special Case: if both objects are at the same *exact* position,\n     *      the result is a `forward` vector ([0,0,-1] for cameras, [0,0,1] for other objects)\n     */\n    getDirectionOf(target: THREE.Object3D, out: THREE.Vector3) {\n        const position = this.getPositionOf(target, out)\n        const distance = position.lengthSq()\n        if (distance === 0 || !isFinite(distance)) { // if distance is 0\n            if ((this.object as THREE.Camera).isCamera) { return out.set(0, 0, -1) }\n            return out.set(0, 0, 1)\n        }\n        return position.normalize()\n    }\n\n    /**\n     * Get the world direction of the target object.\n     *\n     * Special Case: if both objects are at the same *exact* position,\n     *      the result is a `forward` vector ([0,0,-1] for cameras, [0,0,1] for other objects),\n     *      transformed into world coordinates\n     */\n    getWorldDirectionOf(target: THREE.Object3D, out: THREE.Vector3) {\n        return this.getDirectionOf(target, out).transformDirection(this.getMatrixWorld(this.object))\n    }\n\n    getClosestOrthogonalOrientationOf(target: THREE.Object3D, out: THREE.Quaternion) {\n        const o = this.object\n        const viewToObjectMat = (o ? matrices.get().getInverse(this.getMatrixWorld(o)) : matrices.get())\n                .multiply(this.getMatrixWorld(target))\n        const mat = viewToObjectMat.extractRotation(viewToObjectMat)\n        const orientation = out.setFromRotationMatrix(mat)\n\n        const forwardDirection = vectors.get().set(0,0,1).applyQuaternion(orientation)\n        const upDirection = vectors.get().set(0,1,0).applyQuaternion(orientation)\n\n        let distForward = Infinity\n        let distUp = Infinity\n        let closestForwardDirection!:THREE.Vector3\n        let closestUpDirection!:THREE.Vector3\n\n        for (const dir of directions) {\n            let dist = upDirection.distanceToSquared(dir)\n            if (dist < distUp) {\n                distUp = dist\n                closestUpDirection = dir\n            }\n        }\n\n        for (const dir of directions) {\n            // avoid having forward & up defined on the same axis\n            if (dir.x && closestUpDirection.x) continue\n            if (dir.y && closestUpDirection.y) continue\n            if (dir.z && closestUpDirection.z) continue\n            let dist = forwardDirection.distanceToSquared(dir)\n            if (dist < distForward) {\n                distForward = dist\n                closestForwardDirection = dir\n            }\n        }\n\n        mat.identity()\n        mat.lookAt(closestForwardDirection, V_000, closestUpDirection)\n        orientation.setFromRotationMatrix(mat)\n        matrices.pool(mat)\n        o.updateMatrixWorld()\n    }\n\n    /**\n     * Set a position for the *target object*,\n     * based on the visual-space of *this object*.\n     *\n     * If the object has no bounding sphere, or if a visualSize is not specified,\n     * then the current distance will be assumed.\n     *\n     * @param target\n     * @param visualDirection the desired visual direction to the target\n     * @param visualSize the desired visual size of the target (in DEGREES)\n     * @param alpha a linear interpolation value (default is 1)\n     */\n    // setPositionFor( target: THREE.Object3D,\n    //                 visualDirection: THREE.Vector2,\n    //                 visualSize?: number,\n    //                 alpha = 1) {\n    //     let distance: number\n    //     if (typeof visualSize === 'number' && visualSize > 0) {\n    //         distance = this.computeDistanceFor(target, visualSize)\n    //     } else {\n    //         distance = this.getDistanceOf(target)\n    //     }\n    //     const start = vectors.get().copy(target.position)\n    //     const end = target.position\n    //     this.getCartesianForVisualDirection(visualDirection, end)\n    //     end.transformDirection(this.object.matrixWorld).multiplyScalar(distance)\n    //     target.parent && target.parent.worldToLocal(end)\n    //     target.position.copy(start.lerp(end, alpha))\n    //     vectors.pool(start)\n    // }\n\n    /**\n     * Set a new scale for the target that\n     * would make it have the desired visual size\n     * in this object's `visual-space`.\n     *\n     * @param target\n     * @param visualSize the desired visual size of the target (in DEGREES)\n     * @param alpha a linear interpolation value (default is 1)\n     */\n    // setScaleFor(target: THREE.Object3D, visualSize: number, alpha = 1) {\n    //     const idealDistance = this.computeDistanceFor(target, visualSize)\n    //     const currentDistance = this.getDistanceOf(target)\n    //     const distanceScale = idealDistance / currentDistance\n    //     const start = vectors.get().copy(target.scale)\n    //     const end = target.scale\n    //     if (isFinite(distanceScale)) { end.multiplyScalar(distanceScale) }\n    //     target.scale.copy(start.lerp(end, alpha))\n    //     vectors.pool(start)\n    // }\n\n    // /**\n    //  * Perform a look-at operation on the target object, based\n    //  * on this object's local up direction.\n    //  * @param target\n    //  */\n    // setOrientationFor(target: THREE.Object3D, alpha = 1) {\n    //     const localObjectUp = vectors.get().set(0, 1, 0)\n    //     const savedTargetUp = vectors.get().copy(target.up)\n    //     const globalObjectUp = localObjectUp.transformDirection(this.object.matrixWorld)\n    //     target.up.copy(globalObjectUp)\n    //     const start = quaternions.get().copy(target.quaternion)\n    //     const lookAtVector = vectors.get().setFromMatrixPosition(this.object.matrixWorld)\n    //     target.lookAt(lookAtVector)\n    //     target.up.copy(savedTargetUp)\n    //     const end = target.quaternion\n    //     target.quaternion.copy(start.slerp(end, alpha))\n    //     vectors.pool(localObjectUp, savedTargetUp, lookAtVector)\n    //     quaternions.pool(start)\n    // }\n\n\n    // computeDistanceFor(target: THREE.Object3D, visualSize: number): number {\n    //     if (visualSize < 0 || visualSize > 360) { throw new Error('Invalid visualSize, must be between [0-360]') }\n    //     const targetMatrixWorldInverse = matrices.get().getInverse(this.getMatrixWorld(target))\n    //     const frustum = this.getVisualFrustumOf(target)\n    //     return 0\n    //     // if (sphereRadius === 0) { return this.getDistanceOf(target) }\n\n    //     // if (visualSize > 180) {\n    //     //     // special case: linearly decrease distance with increasing visual size within the bounding sphere.\n    //     //     return (360 - visualSize / 180) * sphereRadius\n    //     // }\n\n    //     // // see https://stackoverflow.com/questions/21648630/radius-of-projected-sphere-in-screen-space\n    //     // return sphereRadius / Math.sin( THREE.Math.DEG2RAD * visualSize / 2 )\n    // }\n\n    getOrientationOf(target: THREE.Object3D, out: THREE.Quaternion) {\n        const rotMat = matrices.get()\n        const targetWorldOrientation = quaternions.get().setFromRotationMatrix(rotMat.extractRotation(this.getMatrixWorld(target)))\n        const inverseThisWorldOrientation = quaternions.get().setFromRotationMatrix(rotMat.extractRotation(this.getMatrixWorld(this.object))).inverse()\n        out.multiplyQuaternions(inverseThisWorldOrientation, targetWorldOrientation)\n        quaternions.pool(targetWorldOrientation) \n        quaternions.pool(inverseThisWorldOrientation)\n        matrices.pool(rotMat)\n        return out\n    } \n\n    /**\n     * Calculate the visual direction towards the target object.\n     * Assumes that a normal object faces +Z, and a camera faces -Z.\n     *\n     * If pointing directly towards the target object, the direction is [0,0] (forward)\n     * If pointing directly opposite of the target object, the direction is [0,-180] (backwards)\n     * Special Case: if both are at the same exact position, the direction is [0,0] (forward)\n     */\n    getVisualDirectionOf(target: THREE.Object3D, out: THREE.Vector2) {\n        const direction = this.getDirectionOf(target, vectors.get())\n        const visualDirection = this.getVisualDirectionForCartesian(direction, out)\n        vectors.pool(direction)\n        return visualDirection\n    }\n\n\n    /**\n     * Calculate the visual angle towards the target object.\n     * Assumes that a normal object faces +Z, and a camera faces -Z.\n     *\n     * If the target object is to the right of the forward vector, the angle is 0\n     * If the target object is above the forward vector, the angle is 90\n     * If the target object is to the left of the forward vector, then angle is 180\n     * If the target object is below the forward vector, the angle is 270\n     * If pointing directly towards the target object, the angle is 90 (up)\n     * If pointing directly opposite of the target object, the direction is [0,-180] (backwards)\n     * Special Case: if both are at the same exact position, the direction is [0,0] (forward)\n     */\n    getVisualAngleOf(target: THREE.Object3D, out: THREE.Vector2) {\n        const direction = this.getDirectionOf(target, vectors.get())\n        const visualDirection = this.getVisualDirectionForCartesian(direction, out)\n        vectors.pool(direction)\n        return visualDirection\n    }\n\n    /**\n     * Calculate the bounds of the target object, in the local `object-space` coordinate system. \n     * @param target \n     * @param out \n     */\n    getBoundsOf(target: THREE.Object3D, out = this._box) {\n        if (out === this._box) {\n            out.objectFilter = SpatialMetrics.objectFilter\n            out.objectExpansion = 'box'\n        }\n        out.coordinateSystem = this.object\n        return out.setFromObject(target)\n    }\n    private _box = new Box3\n\n\n    private _visualFrustum = new VisualFrustum(this.object)\n    getVisualFrustumOf(target: THREE.Object3D = this.object, out = this._visualFrustum) {\n        if (out === this._visualFrustum) out.objectFilter = SpatialMetrics.objectFilter\n        const camera = target as THREE.Camera\n        if (camera.isCamera) out.setFromPerspectiveProjectionMatrix(camera.projectionMatrix)\n        else out.setFromObject(target)\n        return out\n    }\n\n    // /**\n    //  * Calculate the visual bounds of the target object, in the local `visual-space` coordinate system\n    //  * @param target \n    //  * @param out \n    //  */\n    // getVisualBoundsOf(target: THREE.Object3D, out: VisualBounds) {\n    //     const direction = this.getDirectionOf(target, vectors.get())\n    //     const visualDirection = this.getVisualDirectionOf(target, vectors2.get())\n    //     const rotation = matrices.get().lookAt(V_000, direction, V_010)\n    //     const rotatedMatrixWorld = matrices.get().multiplyMatrices(rotation, this.object.matrixWorld)\n    //     const rotatedMatrixWorldInverse = rotatedMatrixWorld.getInverse(rotatedMatrixWorld)\n    //     _box.setFromObjectBoxes(target, rotatedMatrixWorldInverse)\n    //     this.getVisualPointFromCartesianPoint(_box.min, out.leftBottomNear)\n    //     this.getVisualPointFromCartesianPoint(_box.max, out.rightTopFar)\n        \n    //     matrices.pool(objectMatrixWorldInverse)\n    // }\n\n    /**\n     * Calculate the angular offset (in DEGREES) between this object's forward vector,\n     * and the direction towards the target object (as calculated by getDirectionOf).\n     * Assumes that a normal object faces +Z, and a camera faces -Z.\n     *\n     * If pointing directly towards the target object, the visual offset is 0\n     * If pointing directly opposite of the target object, the visual offset is 180\n     * Special Case: if both are at the same position, the visual offset is 180\n     */\n    getVisualOffsetOf(target: THREE.Object3D): number {\n        const direction = this.getDirectionOf(target, vectors.get())\n        if (!(this.object as THREE.Camera).isCamera) { direction.applyQuaternion(rotateY180) }\n        const result = V_001.angleTo(direction) * THREE.Math.RAD2DEG\n        vectors.pool(direction)\n        return result\n    }\n\n    /**\n     * Calculate the field of view of the target object as seen by this object.\n     *\n     * The `visual size` grows from 0 to 180 as the visual bouding box of the target grows in our\n     * field of view.\n     * Once we are inside the bounding box, the `visual size` continues to\n     * increase linearly, from 180 to 360 at the center of the bounding box.\n     * If the target object has no bounding sphere defined, the result is 0.\n     *\n     * @returns visual size of the target object in DEGREES, from [0-360], in horizontal and vertical dimensions\n     */\n    // getVisualSizeOf(target: THREE.Object3D, out:THREE.Vector2) {\n    //     const direction = this.getDirectionOf(target, vectors.get())\n    //     const rotation = matrices.get().lookAt(V_000, direction, V_010)\n    //     const rotatedMatrixWorld = matrices.get().multiplyMatrices(rotation, this.object.matrixWorld)\n    //     const rotatedMatrixWorldInverse = rotatedMatrixWorld.getInverse(rotatedMatrixWorld)\n    //     const facingBox = _box.setFromObjectBoxes(target, rotatedMatrixWorldInverse)\n    //     const facingBoxSize = facingBox.getSize(vectors.get())\n    //     // const linearSize = mode === 'horizontal' ? facingBoxSize.x : facingBoxSize.y\n    //     // const distance = this.getDistanceOf(target)\n    //     const near = \n    //     out.x = 2 * Math.atan2(facingBoxSize.x / 2, distance) * THREE.Math.RAD2DEG\n    //     out.y = 2 * Math.atan2(facingBoxSize.y / 2, distance) * THREE.Math.RAD2DEG\n    //     vectors.pool(direction, facingBoxSize)\n    //     matrices.pool(rotation, rotatedMatrixWorld)\n    //     return out\n\n    //     // const objectMatrixWorldInverse = matrices.get().getInverse(this.object.matrixWorld)\n    //     // _box.setFromObjectBoxes(target, objectMatrixWorldInverse)\n    //     // matrices.pool(objectMatrixWorldInverse)\n    //     // const sphere = _box.getBoundingSphere(_sphere)\n    //     // const sphereRadius = sphere.radius\n    //     // if (sphereRadius <= 0) { return 0 }\n    //     // const sphereDistance = this.getDistanceOf(target)\n    //     // if (sphereDistance <= sphereRadius) {\n    //     //     return 180 + (180 * sphereDistance / sphereRadius)\n    //     // } // we are inside the bounding sphere\n    //     // // see https://stackoverflow.com/questions/21648630/radius-of-projected-sphere-in-screen-space\n    //     // return 2 * Math.asin(sphereRadius / sphereDistance) * 180 / Math.PI\n    // }\n\n    // getVisualWidthOf(target: THREE.Object3D) {\n    //     const size = this.getVisualSizeOf(target, vectors2.get())\n    //     const width = size.x\n    //     vectors2.pool(size)\n    //     return width\n    // }\n\n    // getVisualHeightOf(target: THREE.Object3D) {\n    //     const size = this.getVisualSizeOf(target, vectors2.get())\n    //     const height = size.y\n    //     vectors2.pool(size)\n    //     return height\n    // }\n\n    // getVisualDiameterOf(target: THREE.Object3D) {\n    //     const size = this.getVisualSizeOf(target, vectors2.get())\n    //     const length = size.length()\n    //     vectors2.pool(size)\n    //     return length\n    // }\n\n    /**\n     * Calculate the perspective visual frustum which bounds the the target object.\n     * If no target is specified and the current object is a camera, returns \n     * a perspective visual frustum for the camera (assuming it is a perspective camera)\n     */\n    // getVisualFrustum(target:THREE.Object3D=this.object): VisualFrustum {\n    //     if (!this._visualFrustum) { this._visualFrustum =  new VisualFrustum }\n    //     const out = this._visualFrustum\n    //     const camera = this.object as THREE.Camera\n    //     if (camera.isCamera) { \n    //         const invProjection = matrices.get().getInverse(camera.projectionMatrix, true)\n    //         out.setFromBoundsMatrix(invProjection)\n    //         matrices.pool(invProjection)\n    //     } else {\n    //         const direction = this.getDirectionOf(target, vectors.get())\n    //         const rotation = matrices.get().lookAt(V_000, direction, V_010)\n    //         const rotatedMatrixWorld = matrices.get().multiplyMatrices(rotation, this.object.matrixWorld)\n    //         const rotatedMatrixWorldInverse = rotatedMatrixWorld.getInverse(rotatedMatrixWorld)\n    //         const facingBox = _box.setFromObjectBoxes(target, rotatedMatrixWorldInverse)\n    //         const facingBoxSize = facingBox.getSize(vectors.get())\n    //         const near = facingBox.min.z\n    //         const far = facingBox.max.z\n    //         const left = facingBox.min.x\n    //         out.x = 2 * Math.atan2(facingBoxSize.x / 2, distance) * THREE.Math.RAD2DEG\n    //         out.y = 2 * Math.atan2(facingBoxSize.y / 2, distance) * THREE.Math.RAD2DEG\n    //         matrices.get().makePerspective()\n    //     }\n    //     return out\n    // }\n\n}\n\n\nconst directions = [\n    new THREE.Vector3( 1, 0, 0),\n    new THREE.Vector3( 0, 1, 0), \n    new THREE.Vector3( 0, 0, 1), \n    new THREE.Vector3(-1, 0, 0), \n    new THREE.Vector3( 0,-1, 0), \n    new THREE.Vector3( 0, 0,-1), \n]\n\n\n// export function getMetrics(obj: THREE.Object3D) : SpatialMetrics {\n//     if (_metricsMap.has(obj)) return _metricsMap.get(obj)!\n//     const metrics = new SpatialMetrics(obj)\n//     _metricsMap.set(obj, metrics)\n//     return metrics\n// }","import * as THREE from 'three'\nimport { SpatialMetrics, Box3 } from '../metrics/SpatialMetrics'\nimport { matrices, vectors } from '../utils'\n\nexport const LayoutFit = {\n    contain: 'contain',\n    contain3d: 'contain3d',\n    cover: 'cover',\n    cover3d: 'cover3d',\n    fill: 'fill',\n    fill3d: 'fill3d',\n}\n\nconst FIT_CONTAIN_3D = {\n    contain: 0,\n    contain3d: 1,\n    cover: 0,\n    cover3d: 0,\n    fill: 0,\n    fill3d: 0,\n}\n\nexport type LayoutFitType = keyof typeof LayoutFit\n\nexport type LayoutX = number|'center'|'left'|'right'\nexport type LayoutY = number|'center'|'top'|'bottom'\nexport type LayoutZ = number|'center'|'front'|'back'\n\n\n/**\n * Extend THREE.Object3D functionality with 3D layout functionality.\n * \n * Features include:\n *  - automatic bounds computation\n *  - modify alignment, origin, and size with respect to bounds and parent bounds\n *  - pose & layout transitions\n */\nexport class Layout {\n\n    /**\n     * Force local layout bounds to be excluded from the parent bounding context \n     * (effectively, forces a new bounding context)\n     */\n    forceBoundsExclusion = false\n\n    /**\n     * Specifies the degree to which the layout properties (`absolute`, and `relative`) influence \n     * the final transform. At 0, the layout properties have no effect. At 1, they have\n     * their full intended effect. \n     */\n    weight = 1\n    \n    /**\n     * Specify absolute layout bounds. A mininum or maximum boundary\n     * can be set to `NaN` in any dimension to remain unspecified. \n     * \n     * Note: any specified `relative` and `absolute` bounds\n     * are combined to determine `computedBounds`\n     */\n    absolute =  new Box3\n\n    /**\n     * Specify relative layout bounds, with -1 to 1 spanning the \n     * range of `computedOuterBounds` for each dimension. A mininum or \n     * maximum boundary can be set to `NaN` in any dimension to remain \n     * unspecified. \n     * \n     * Note: any specified `relative` and `absolute` bounds\n     * are combined to determine `computedBounds`\n     */\n    relative = new Box3\n\n    /**\n     * Specify the orientation of the layout. Default is identity. \n     */\n    orientation = new THREE.Quaternion\n\n    /**\n     * \n     */\n    minRelativeSize = new THREE.Vector3\n\n    /**\n     * \n     */\n    minAbsoluteSize = new THREE.Vector3\n\n    /** \n     * Specifies how the object should fit within `absolute` and `relative` bounds,\n     * which determines the `computedBounds`\n    */\n    set fit(fit:LayoutFitType) {\n        this._fit = fit\n        for (const id in this.fitTargets) this.fitTargets[id as LayoutFitType] = 0\n        this.fitTargets[fit] = 1\n    }\n    get fit() {\n        return this._fit\n    }\n    private _fit = 'contain' as LayoutFitType\n\n    /** Used internally. */\n    fitTargets = {\n        contain: 1,\n        contain3d: 0,\n        cover: 0,\n        cover3d: 0,\n        fill: 0,\n        fill3d: 0,\n    }\n\n    /**\n     * \n     */\n    fitAlign = new THREE.Vector3\n\n    clip = new Box3\n\n    inner = new Box3\n    innerAutoUpdate = true\n\n    computedBounds = new Box3\n    computedInnerBounds = new Box3\n    computedOuterBounds = new Box3\n    computedClipBounds = new Box3\n\n    public matrix = new THREE.Matrix4\n\n    private _boundsValid = false\n\n    constructor(public object:THREE.Object3D) {\n        this.computedInnerBounds.objectFilter = SpatialMetrics.objectFilter\n        this.computedInnerBounds.objectExpansion = 'box'\n        this.computedInnerBounds.coordinateSystem = object\n    }\n\n    invalidateBounds() {\n        this._boundsValid = false\n    }\n\n    resetLayout() {\n        this.fit = 'contain'\n        this.absolute.makeEmpty()\n        this.relative.makeEmpty()\n    }\n\n    resetPose() {\n        this.object.position.setScalar(0)\n        this.object.quaternion.set(0,0,0,1)\n        this.object.scale.setScalar(1)\n    }\n\n    reset() {\n        this.resetLayout()\n        this.resetPose()\n    }\n\n    /**\n     * If true, the layout properties are effectively noop\n     */\n    isPassive() {\n        return this.absolute.isEmpty() && this.relative.isEmpty()\n    }\n\n    /**\n     * If true, the `object` should not be included in the bounding calculation\n     * for any parent layouts.\n     */\n    isBoundingContext() {\n        if (this.forceBoundsExclusion) return true\n        if (!this.isPassive()) {\n            this.forceBoundsExclusion = true\n            return true\n        }\n        return false\n    }\n\n    updateMatrix() {\n        const bounds = this.computedBounds\n        \n        if (this.isPassive()) {\n            this.matrix.identity()\n            return\n        }\n\n        if (!this._boundsValid) {\n            Layout.updateInnerBounds(this.object)\n            Layout.updateOuterBounds(this.object)\n            if (this.computedInnerBounds.isEmpty()) {\n                this.computedInnerBounds.copy(this.computedOuterBounds)\n            }\n            this._boundsValid = true\n        }\n\n        const {absolute, relative, fitTargets, orientation, computedInnerBounds, computedOuterBounds, clip} = this\n        \n        // combine relative and absolute bounds\n\n        bounds.makeEmpty()\n        computedOuterBounds.relativeToAbsolute(relative.min, bounds.min)\n        computedOuterBounds.relativeToAbsolute(relative.max, bounds.max)\n        if (isFinite(absolute.min.x)) bounds.min.x = (isFinite(bounds.min.x) ? bounds.min.x : 0) + absolute.min.x\n        if (isFinite(absolute.min.y)) bounds.min.y = (isFinite(bounds.min.y) ? bounds.min.y : 0) + absolute.min.y\n        if (isFinite(absolute.min.z)) bounds.min.z = (isFinite(bounds.min.z) ? bounds.min.z : 0) + absolute.min.z\n        if (isFinite(absolute.max.x)) bounds.max.x = (isFinite(bounds.max.x) ? bounds.max.x : 0) + absolute.max.x\n        if (isFinite(absolute.max.y)) bounds.max.y = (isFinite(bounds.max.y) ? bounds.max.y : 0) + absolute.max.y\n        if (isFinite(absolute.max.z)) bounds.max.z = (isFinite(bounds.max.z) ? bounds.max.z : 0) + absolute.max.z\n\n        // apply clip\n\n        if (!clip.isEmpty()) {\n            // const clipMax = vectors.get().copy(clip.max)//.subVectors(clip.max, bounds.max).min(V_000)\n            // const clipMin = vectors.get().copy(clip.min)//.subVectors(clip.min, bounds.min).max(V_000)\n            const clipMax = computedInnerBounds.absoluteToRelative(clip.max, vectors.get())//.subVectors(clip.max, bounds.max).min(V_000)\n            const clipMin = computedInnerBounds.absoluteToRelative(clip.min,Â vectors.get())//.subVectors(clip.min, bounds.min).max(V_000)\n            bounds.relativeToAbsolute(clipMax, clipMax)//.subVectors(clip.max, bounds.max).min(V_000)\n            bounds.relativeToAbsolute(clipMin, clipMin)//.subVectors(clip.min, bounds.min).max(V_000)\n            if (!isFinite(clipMax.x)) clipMax.x = Infinity\n            if (!isFinite(clipMax.y)) clipMax.y = Infinity\n            if (!isFinite(clipMax.z)) clipMax.z = Infinity\n            if (!isFinite(clipMin.x)) clipMin.x = -Infinity\n            if (!isFinite(clipMin.y)) clipMin.y = -Infinity\n            if (!isFinite(clipMin.z)) clipMin.z = -Infinity\n            bounds.max.min(clipMax)\n            bounds.min.max(clipMin)\n            vectors.pool(clipMax)\n            vectors.pool(clipMin)\n        }\n\n        // compute min size\n        const minSize = computedOuterBounds.getSize(vectors.get())\n            .multiply(this.minRelativeSize).max(this.minAbsoluteSize)\n\n        // compute final size\n        const innerSize = computedInnerBounds.getSize(vectors.get())\n        const layoutScale = bounds.getSize(vectors.get()).max(minSize).divide(innerSize)\n        Layout.adjustScaleForFit(fitTargets, layoutScale)\n        const finalSize = vectors.get().multiplyVectors(innerSize, layoutScale)\n        finalSize.x = Math.abs(finalSize.x)\n        finalSize.y = Math.abs(finalSize.y)\n        finalSize.z = Math.abs(finalSize.z)\n\n        if (!isFinite(bounds.min.x) && !isFinite(bounds.max.x)) {\n            bounds.max.x = finalSize.x / 2\n            bounds.min.x = - bounds.max.x\n        }\n        if (!isFinite(bounds.min.y) && !isFinite(bounds.max.y)) {\n            bounds.max.y = finalSize.y / 2\n            bounds.min.y = - bounds.max.y\n        }\n        if (!isFinite(bounds.min.z) && !isFinite(bounds.max.z)) {\n            bounds.max.z = finalSize.z / 2\n            bounds.min.z = - bounds.max.z\n        }\n        if (!isFinite(bounds.max.x)) bounds.max.x = bounds.min.x + finalSize.x\n        if (!isFinite(bounds.max.y)) bounds.max.y = bounds.min.y + finalSize.y\n        if (!isFinite(bounds.max.z)) bounds.max.z = bounds.min.z + finalSize.z\n        if (!isFinite(bounds.min.x)) bounds.min.x = bounds.max.x - finalSize.x\n        if (!isFinite(bounds.min.y)) bounds.min.y = bounds.max.y - finalSize.y\n        if (!isFinite(bounds.min.z)) bounds.min.z = bounds.max.z - finalSize.z\n\n        const orient = matrices.get().makeRotationFromQuaternion(orientation)\n        const halfFinalSize = finalSize.divideScalar(2)\n\n        const layoutAlignOffset = bounds.relativeToAbsolute(this.fitAlign, vectors.get())\n        bounds.min.copy(layoutAlignOffset).sub(halfFinalSize)\n        bounds.max.copy(layoutAlignOffset).add(halfFinalSize)\n        bounds.applyMatrix4(orient)\n\n        const innerAlignOffset = computedInnerBounds.relativeToAbsolute(this.fitAlign, vectors.get())\n        innerAlignOffset.multiply(layoutScale).applyMatrix4(orient)\n        bounds.min.sub(innerAlignOffset)\n        bounds.max.sub(innerAlignOffset)\n\n        // compose layout matrix\n\n        const layoutPosition = bounds.getCenter(vectors.get())\n        this.matrix.compose(layoutPosition, orientation, layoutScale)\n        \n        // cleanup\n\n        vectors.pool(innerSize)\n        vectors.pool(minSize)\n        vectors.pool(finalSize)\n        vectors.pool(layoutPosition)\n        vectors.pool(layoutScale)\n        vectors.pool(layoutAlignOffset)\n        // vectors.pool(innerAlignOffset)\n    }\n\n    public static updateInnerBounds(o:THREE.Object3D) {\n        const layout = o.layout\n        const bounds = layout.computedInnerBounds\n        if (layout._boundsValid) return bounds\n        bounds.coordinateSystem = o\n        bounds.setFromObject(o).union(layout.inner)\n        if (bounds.min.x === bounds.max.x) bounds.max.x += 1e-10\n        if (bounds.min.y === bounds.max.y) bounds.max.y += 1e-10\n        if (bounds.min.z === bounds.max.z) bounds.max.z += 1e-10\n        return bounds\n    }\n    \n    public static updateOuterBounds(o:THREE.Object3D) {\n        const layout = o.layout\n        const parentBounds = layout.computedOuterBounds\n\n        if (layout._boundsValid) return parentBounds\n\n        const parent = o.parent\n        const cameraParent = parent as THREE.Camera\n        if (cameraParent && cameraParent.isCamera) {\n            const position = vectors.get().setFromMatrixPosition(o.matrix)\n            const projectionMatrixInverse = matrices.get().getInverse(cameraParent.projectionMatrix)\n            const near = parentBounds.min.set(0,0,-1).applyMatrix4(projectionMatrixInverse).z\n            const far = parentBounds.min.set(0,0,1).applyMatrix4(projectionMatrixInverse).z\n            const projectionZ = parentBounds.min.set(0,0,position.z).applyMatrix4(cameraParent.projectionMatrix).z\n            parentBounds.min.set(-1, -1, projectionZ)\n            parentBounds.max.set(1, 1, projectionZ)\n            parentBounds.min.applyMatrix4(projectionMatrixInverse)\n            parentBounds.max.applyMatrix4(projectionMatrixInverse)\n            parentBounds.min.z = far\n            parentBounds.max.z = near\n            vectors.pool(position)\n            matrices.pool(projectionMatrixInverse)\n        } else if (parent) {\n            parentBounds.copy(parent.layout.computedInnerBounds)\n        } else {\n            parentBounds.makeEmpty()\n        }\n\n        const orient = matrices.get().makeRotationFromQuaternion(layout.orientation)\n        parentBounds.applyMatrix4(orient.getInverse(orient))\n        matrices.pool(orient)\n        return parentBounds\n    }\n\n    public static _fitScale = new THREE.Vector3\n    public static adjustScaleForFit(fitTargets:typeof Layout.prototype.fitTargets, sizeScale:THREE.Vector3) {\n        const fitScale = this._fitScale\n        const out = sizeScale\n        const min = 1e-10\n        const max = 1e10\n\n        if (!isFinite(out.x) && !isFinite(out.y) && !isFinite(out.z)) {\n            out.setScalar(1)\n            return out\n        }\n        \n        if (!isFinite(out.x)) out.x = max\n        if (!isFinite(out.y)) out.y = max\n        if (!isFinite(out.z)) out.z = max\n        out.x = out.x < 0 ? THREE.Math.clamp(out.x, -max, -min) : THREE.Math.clamp(out.x, min, max)\n        out.y = out.y < 0 ? THREE.Math.clamp(out.y, -max, -min) : THREE.Math.clamp(out.y, min, max)\n        out.z = out.z < 0 ? THREE.Math.clamp(out.z, -max, -min) : THREE.Math.clamp(out.z, min, max)\n        \n        const {x,y,z} = out\n        const ax = Math.abs(x)\n        const ay = Math.abs(y)\n        const az = Math.abs(z)\n\n        // fill3d: allow all dimensions to fill layout size\n        if (fitTargets.fill3d) {\n            // no-op\n        }\n\n        // fill (2D): set z to average of x and y\n        if (fitTargets.fill) {\n            fitScale.set(x, y, x + y / 2)\n            out.lerp(fitScale, fitTargets.fill)\n        }\n\n        // contain (2D): set all dimensions to smallest of x or y\n        if (fitTargets.contain) {\n            if (ax < ay) {\n                fitScale.set(x, x, x)\n            } else {\n                fitScale.set(y, y, y)\n            }\n            out.lerp(fitScale, fitTargets.contain)\n        }\n\n        // contain3d: set all dimensions to smallest of x or y or z\n        if (fitTargets.contain3d) {\n            if (ax < ay && ax < az) {\n                fitScale.set(x, x, x)\n            } else if (ay < ax && ay < az) {\n                fitScale.set(y, y, y)\n            } else {\n                fitScale.set(z, z, z)\n            }\n            out.lerp(fitScale, fitTargets.contain3d)\n        }\n\n        // cover (2D): set all dimensions to largest of x or y\n        if (fitTargets.cover) {\n            if (ax > ay) {\n                fitScale.set(x, x, x)\n            } else {\n                fitScale.set(y, y, y)\n            }\n            out.lerp(fitScale, fitTargets.cover)\n        }\n\n        // cover (3D): set all dimensions to largest of x or y or z\n        if (fitTargets.cover3d) {\n            if (ax > ay && ax > az) {\n                fitScale.set(x, x, x)\n            } else if (ay > ax && ay > az) {\n                fitScale.set(y, y, y)\n            } else {\n                fitScale.set(z, z, z)\n            }\n            out.lerp(fitScale, fitTargets.cover3d)\n        }\n\n        // clamp between 1e-10 and 1e10\n        if (!isFinite(out.x)) out.x = min\n        if (!isFinite(out.y)) out.y = min\n        if (!isFinite(out.z)) out.z = min\n        out.x = out.x < 0 ? THREE.Math.clamp(out.x, -max, -min) : THREE.Math.clamp(out.x, min, max)\n        out.y = out.y < 0 ? THREE.Math.clamp(out.y, -max, -min) : THREE.Math.clamp(out.y, min, max)\n        out.z = out.z < 0 ? THREE.Math.clamp(out.z, -max, -min) : THREE.Math.clamp(out.z, min, max)\n        return out\n    }\n}\n\n// function isNaN(a:number) {\n//     return a !== a\n// }","var DEFAULT_OVERSHOOT_STRENGTH = 1.525;\nvar reversed = function (easing) {\n    return function (p) {\n        return 1 - easing(1 - p);\n    };\n};\nvar mirrored = function (easing) {\n    return function (p) {\n        return p <= 0.5 ? easing(2 * p) / 2 : (2 - easing(2 * (1 - p))) / 2;\n    };\n};\nvar createReversedEasing = reversed;\nvar createMirroredEasing = mirrored;\nvar createExpoIn = function (power) {\n    return function (p) {\n        return Math.pow(p, power);\n    };\n};\nvar createBackIn = function (power) {\n    return function (p) {\n        return p * p * ((power + 1) * p - power);\n    };\n};\nvar createAnticipateEasing = function (power) {\n    var backEasing = createBackIn(power);\n    return function (p) {\n        return (p *= 2) < 1 ? 0.5 * backEasing(p) : 0.5 * (2 - Math.pow(2, -10 * (p - 1)));\n    };\n};\nvar linear = function (p) {\n    return p;\n};\nvar easeIn = /*#__PURE__*/createExpoIn(2);\nvar easeOut = /*#__PURE__*/reversed(easeIn);\nvar easeInOut = /*#__PURE__*/mirrored(easeIn);\nvar circIn = function (p) {\n    return 1 - Math.sin(Math.acos(p));\n};\nvar circOut = /*#__PURE__*/reversed(circIn);\nvar circInOut = /*#__PURE__*/mirrored(circOut);\nvar backIn = /*#__PURE__*/createBackIn(DEFAULT_OVERSHOOT_STRENGTH);\nvar backOut = /*#__PURE__*/reversed(backIn);\nvar backInOut = /*#__PURE__*/mirrored(backIn);\nvar anticipate = /*#__PURE__*/createAnticipateEasing(DEFAULT_OVERSHOOT_STRENGTH);\nvar BOUNCE_FIRST_THRESHOLD = 4.0 / 11.0;\nvar BOUNCE_SECOND_THRESHOLD = 8.0 / 11.0;\nvar BOUNCE_THIRD_THRESHOLD = 9.0 / 10.0;\nvar ca = 4356.0 / 361.0;\nvar cb = 35442.0 / 1805.0;\nvar cc = 16061.0 / 1805.0;\nvar bounceOut = function (p) {\n    var p2 = p * p;\n    return p < BOUNCE_FIRST_THRESHOLD ? 7.5625 * p2 : p < BOUNCE_SECOND_THRESHOLD ? 9.075 * p2 - 9.9 * p + 3.4 : p < BOUNCE_THIRD_THRESHOLD ? ca * p2 - cb * p + cc : 10.8 * p * p - 20.52 * p + 10.72;\n};\nvar bounceIn = function (p) {\n    return 1.0 - bounceOut(1.0 - p);\n};\nvar bounceInOut = function (p) {\n    return p < 0.5 ? 0.5 * (1.0 - bounceOut(1.0 - p * 2.0)) : 0.5 * bounceOut(p * 2.0 - 1.0) + 0.5;\n};\nvar NEWTON_ITERATIONS = 8;\nvar NEWTON_MIN_SLOPE = 0.001;\nvar SUBDIVISION_PRECISION = 0.0000001;\nvar SUBDIVISION_MAX_ITERATIONS = 10;\nvar K_SPLINE_TABLE_SIZE = 11;\nvar K_SAMPLE_STEP_SIZE = 1.0 / (K_SPLINE_TABLE_SIZE - 1.0);\nvar FLOAT_32_SUPPORTED = typeof Float32Array !== 'undefined';\nvar a = function (a1, a2) {\n    return 1.0 - 3.0 * a2 + 3.0 * a1;\n};\nvar b = function (a1, a2) {\n    return 3.0 * a2 - 6.0 * a1;\n};\nvar c = function (a1) {\n    return 3.0 * a1;\n};\nvar getSlope = function (t, a1, a2) {\n    return 3.0 * a(a1, a2) * t * t + 2.0 * b(a1, a2) * t + c(a1);\n};\nvar calcBezier = function (t, a1, a2) {\n    return ((a(a1, a2) * t + b(a1, a2)) * t + c(a1)) * t;\n};\nfunction cubicBezier(mX1, mY1, mX2, mY2) {\n    var sampleValues = FLOAT_32_SUPPORTED ? new Float32Array(K_SPLINE_TABLE_SIZE) : new Array(K_SPLINE_TABLE_SIZE);\n    var binarySubdivide = function (aX, aA, aB) {\n        var i = 0;\n        var currentX;\n        var currentT;\n        do {\n            currentT = aA + (aB - aA) / 2.0;\n            currentX = calcBezier(currentT, mX1, mX2) - aX;\n            if (currentX > 0.0) {\n                aB = currentT;\n            } else {\n                aA = currentT;\n            }\n        } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);\n        return currentT;\n    };\n    var newtonRaphsonIterate = function (aX, aGuessT) {\n        var i = 0;\n        var currentSlope = 0;\n        var currentX;\n        for (; i < NEWTON_ITERATIONS; ++i) {\n            currentSlope = getSlope(aGuessT, mX1, mX2);\n            if (currentSlope === 0.0) {\n                return aGuessT;\n            }\n            currentX = calcBezier(aGuessT, mX1, mX2) - aX;\n            aGuessT -= currentX / currentSlope;\n        }\n        return aGuessT;\n    };\n    var calcSampleValues = function () {\n        for (var i = 0; i < K_SPLINE_TABLE_SIZE; ++i) {\n            sampleValues[i] = calcBezier(i * K_SAMPLE_STEP_SIZE, mX1, mX2);\n        }\n    };\n    var getTForX = function (aX) {\n        var intervalStart = 0.0;\n        var currentSample = 1;\n        var lastSample = K_SPLINE_TABLE_SIZE - 1;\n        var dist = 0.0;\n        var guessForT = 0.0;\n        var initialSlope = 0.0;\n        for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {\n            intervalStart += K_SAMPLE_STEP_SIZE;\n        }\n        --currentSample;\n        dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);\n        guessForT = intervalStart + dist * K_SAMPLE_STEP_SIZE;\n        initialSlope = getSlope(guessForT, mX1, mX2);\n        if (initialSlope >= NEWTON_MIN_SLOPE) {\n            return newtonRaphsonIterate(aX, guessForT);\n        } else if (initialSlope === 0.0) {\n            return guessForT;\n        } else {\n            return binarySubdivide(aX, intervalStart, intervalStart + K_SAMPLE_STEP_SIZE);\n        }\n    };\n    calcSampleValues();\n    var resolver = function (aX) {\n        var returnValue;\n        if (mX1 === mY1 && mX2 === mY2) {\n            returnValue = aX;\n        } else if (aX === 0) {\n            returnValue = 0;\n        } else if (aX === 1) {\n            returnValue = 1;\n        } else {\n            returnValue = calcBezier(getTForX(aX), mY1, mY2);\n        }\n        return returnValue;\n    };\n    return resolver;\n}\n\nexport { reversed, mirrored, createReversedEasing, createMirroredEasing, createExpoIn, createBackIn, createAnticipateEasing, linear, easeIn, easeOut, easeInOut, circIn, circOut, circInOut, backIn, backOut, backInOut, anticipate, bounceOut, bounceIn, bounceInOut, cubicBezier };\n","import * as THREE from 'three'\nimport { vectors2, vectors, quaternions, matrices, V_00, V_000, Q_IDENTITY } from '../utils'\nimport * as easing from '@popmotion/easing'\n\nexport {easing}\n\nfunction defined(...obj:any[]) {\n    for (const o of obj) {\n        if (typeof o !== 'undefined') return o\n    }\n}\n\ntype WidenLiteral<T> = T extends number ? number : T\n\nexport type Multiplier<T> = number | (T extends THREE.Matrix4 ? {position?:number,scale?:number,quaternion?:number} : never)\n\nexport class TransitionTarget<T extends ValueType = ValueType>{\n    constructor(\n        public value: T,\n        public duration: number,\n        public easing: (number) => number\n    ) {}\n    public elapsed: 0\n}\n\ntype ValueTypes = number|THREE.Vector2|THREE.Vector3|THREE.Quaternion|THREE.Color|THREE.Matrix4|THREE.Box3\nexport type ValueType<T extends ValueTypes=ValueTypes> = WidenLiteral<T>\n\nexport type ValueRange<T> = T extends THREE.Vector2|THREE.Vector3 ? T : \n    T extends THREE.Matrix4|THREE.Box3 ? THREE.Vector3 : \n    T extends number ? number : never\n\nexport type TransitionableConstructorKeys = \n    'target'|'multiplier'|'duration'|'easing'|'threshold'|\n    'delay'|'debounce'|'maxWait'\nexport type TransitionerConstructOptions<T extends ValueType> = Pick<Transitionable<T>, TransitionableConstructorKeys>\n\nexport type TransitionableConfig = Pick<Transitionable<ValueType>,'delay'|'debounce'|'maxWait'|'multiplier'|'duration'|'easing'|'threshold'>\n\nexport class Transitionable<T extends ValueType = ValueType> {\n\n    constructor(config:TransitionerConstructOptions<T>) {\n        Object.assign(this, config)\n        const t = this.target\n        if (typeof this.current === 'undefined') \n            this.current = (typeof t === 'number' ? t : (t as any).clone()) as  WidenLiteral<T>\n        if (typeof this.start === 'undefined') \n            this.start = (typeof t === 'number' ? t : (t as any).clone()) as  WidenLiteral<T>\n    }\n\n    /**\n     * The desired target value\n     */\n    target: WidenLiteral<T>\n\n    /**\n     * The current value\n     */\n    current : WidenLiteral<T>\n\n    /**\n     * The start value\n     */\n    start : WidenLiteral<T>\n    \n    /**\n     * The typical range of the target value, used to determine percentage change\n     */\n    range: ValueRange<T>\n    /**\n     * The target value awaiting to be added to the `targetQueue`\n     */\n    committedTarget?: WidenLiteral<T>\n    /**\n     * A multiplier to influence the speed of the transition\n     */\n    multiplier?: number = undefined\n    /**\n     * The duration of the easing function\n     */\n    duration?: number  = undefined\n    /**\n     * The easing function \n     */\n    easing?: (alpha:number) => number = undefined\n    /**\n     * The percentage that the `target` must differ from the `committedTarget`, \n     * the last target added to the `targetQueue`, or the `current` value  (in  that order)\n     * before it is considered \"changed\". Depends on `range` being defined. \n     */\n    threshold?: number = undefined\n    /**\n     * The number of seconds in which the `target` value must remain \"changed\" before it\n     * becomes the `committedTarget`\n     */\n    delay?: number = undefined\n    /**\n     * The number of seconds in which the `committedTarget` must \n     * remain stable before it is pushed to the `targetQueue`\n     */\n    debounce?: number = undefined\n    /**\n     * The maximum number of seconds to wait before the `committedTarget`\n     * is pushed to the `targetQueue`\n     */\n    maxWait?: number = undefined\n    /**\n     * The queue of committed target values that are still influencing the current value\n     * (whose durations have not yet been exceeded)\n     */\n    targetQueue: TransitionTarget<WidenLiteral<T>>[] = []\n\n    _delayTime = 0\n    _debounceTime = 0\n    _waitTime = 0\n\n    _changePercent = 0\n\n    /**\n     * \n     */\n    update(deltaTime:number, c?:TransitionableConfig, changePercent?:number) {\n        const config = this._updateConfig(c)\n        const queue = this.targetQueue\n        const target = this.target\n        this._changePercent = changePercent = typeof changePercent === 'number' ? changePercent : this._computePercentChange()\n        deltaTime *= config.multiplier\n        \n        if (changePercent > config.threshold) {\n            if (this._delayTime > config.delay) {\n                if (typeof target === 'number') this.committedTarget = target as any\n                else {\n                    if (this.committedTarget) (this.committedTarget as any).copy(target)\n                    else this.committedTarget = (target as any).clone()\n                }\n                this._delayTime = 0\n                this._debounceTime = 0\n            }\n            this._delayTime += deltaTime\n        } else {\n            if (typeof this.committedTarget !== 'undefined') this._delayTime = 0\n            this._debounceTime += deltaTime\n        }\n\n        if (this.committedTarget) this._waitTime += deltaTime\n\n        if (this.committedTarget && (this._debounceTime > config.debounce || this._waitTime > config.maxWait)) {\n            queue.push({\n                value: this.committedTarget,\n                easing: config.easing,\n                duration: config.duration,\n                elapsed: 0\n            })\n            this.committedTarget = undefined\n            this._waitTime = 0\n        }\n        \n        while (queue.length && queue[0].elapsed > queue[0].duration) {\n            this.start = queue.shift()!.value\n        }\n        \n        this._setCurrent(this.start)\n        let previousTarget = this.start\n        for (const target of queue) {\n            target.elapsed += deltaTime\n            this._addTargetInfluence(previousTarget, target)\n            previousTarget = target.value\n        }\n    }\n\n    private static _c = new THREE.Color\n    private static _cBlack = new THREE.Color(0,0,0)\n\n    private _addTargetInfluence(start:WidenLiteral<T>, target:TransitionTarget<WidenLiteral<T>>) {\n        const alpha = target.duration > 0 ? target.easing( Math.min(target.elapsed, target.duration) / target.duration) : 1\n\n        if (typeof target.value !== 'number' && 'isMatrix4' in target.value) {\n            const c = this.current as THREE.Matrix4\n            const s = start as THREE.Matrix4\n            const e = target.value as THREE.Matrix4\n\n            const pos = vectors.get()\n            const quat = quaternions.get()\n            const scale = vectors.get()\n            c.decompose(pos, quat, scale)\n\n            const sPos = vectors.get()\n            const sQuat = quaternions.get()\n            const sScale = vectors.get()\n            s.decompose(sPos, sQuat, sScale)\n    \n            const tPos = vectors.get()\n            const tQuat = quaternions.get()\n            const tScale = vectors.get()\n            e.decompose(tPos, tQuat, tScale)\n    \n            pos.add(tPos.sub(sPos).lerp(V_000, 1-alpha))\n            quat.multiply(sQuat.inverse().multiply(tQuat).slerp(Q_IDENTITY, 1-alpha)).normalize()\n            scale.add(tScale.sub(sScale).lerp(V_000, 1-alpha))\n    \n            vectors.pool(pos)\n            quaternions.pool(quat)\n            vectors.pool(scale)\n            vectors.pool(sPos)\n            quaternions.pool(sQuat)\n            vectors.pool(sScale)\n            vectors.pool(tPos)\n            quaternions.pool(tQuat)\n            vectors.pool(tScale)\n            return\n        }\n\n        if (typeof target.value === 'number') {\n            this.current += THREE.Math.lerp(0, target.value-(startÂ as number), alpha) as any\n            return\n        } \n        \n        if ('isVector3' in target.value) {\n            const c = this.current as THREE.Vector3\n            const s = start as THREE.Vector3\n            const e = target.value as THREE.Vector3\n            const amount = vectors.get().copy(e).sub(s).lerp(V_000, 1-alpha)\n            c.add(amount)\n            vectors.pool(amount)\n            return\n        } \n        \n        if ('isVector2' in target.value) {\n            const c = this.current as THREE.Vector2\n            const s = start as THREE.Vector2\n            const e = target.value as THREE.Vector2\n            const amount = vectors2.get().copy(e).sub(s).lerp(V_00, 1-alpha)\n            c.add(amount)\n            vectors2.pool(amount)\n            return\n        } \n        \n        if ('isQuaternion' in target.value) {\n            const c = this.current as THREE.Quaternion\n            const s = start as THREE.Quaternion\n            const e = target.value as THREE.Quaternion\n            const amount = quaternions.get().copy(s).inverse().multiply(e).slerp(Q_IDENTITY, 1-alpha)\n            c.multiply(amount).normalize()\n            quaternions.pool(amount)\n            return\n        } \n        \n        if ('isColor' in target.value) {\n            const c = this.current as THREE.Color\n            const s = start as THREE.Color\n            const e = target.value as THREE.Color\n            const amount = Transitionable._c.copy(e).sub(s).lerp(Transitionable._cBlack, 1-alpha)\n            c.add(amount)\n            return\n        } \n        \n        if ('isBox3' in target.value) {\n            const c = this.current as THREE.Box3\n            const s = start as THREE.Box3\n            const e = target.value as THREE.Box3\n            const minAmount = vectors.get().copy(e.min).sub(s.min).lerp(V_000, 1-alpha)\n            const maxAmount = vectors.get().copy(e.max).sub(s.max).lerp(V_000, 1-alpha)\n            if (isFinite(c.min.x)) c.min.x = 0\n            if (isFinite(c.min.y)) c.min.y = 0\n            if (isFinite(c.min.z)) c.min.z = 0\n            if (isFinite(c.max.x)) c.max.x = 0\n            if (isFinite(c.max.y)) c.max.y = 0\n            if (isFinite(c.max.z)) c.max.z = 0\n            c.min.add(minAmount)\n            c.max.add(maxAmount)\n            return\n        }\n    }\n\n    _setCurrent(value:WidenLiteral<T>) {\n        if (typeof value === 'number') {\n            this.current = value\n        } else {\n            (this.current as any).copy(value)\n        }\n    }\n\n    _computePercentChange() {\n\n        const end = this.target as ValueType\n        const start = this.committedTarget || (this.targetQueue[0] && this.targetQueue[0].value) || this.current\n\n        if (typeof start === 'number') {\n            const s = start as number\n            const e = end as number\n            return Math.abs(e - s / ((this.range as number) || 1))\n        } \n\n        if ('isMatrix4' in start) {\n            const s = start as THREE.Matrix4\n            const e = end as THREE.Matrix4\n            const sPos = vectors.get()\n            const sQuat = quaternions.get()\n            const sScale = vectors.get()\n            s.decompose(sPos, sQuat, sScale)\n            const ePos = vectors.get()\n            const eQuat = quaternions.get()\n            const eScale = vectors.get()\n            e.decompose(ePos, eQuat, eScale)\n\n            const posPercent = sPos.equals(ePos) ? 0 : Infinity\n\n            const quatPercent = Math.abs(sQuat.angleTo(eQuat) / Math.PI)\n\n            const scalePercent = sScale.equals(eScale) ? 0 : Infinity\n            \n            vectors.pool(sPos)\n            quaternions.pool(sQuat)\n            vectors.pool(sScale)\n            vectors.pool(ePos)\n            quaternions.pool(eQuat)\n            vectors.pool(eScale)\n\n            return Math.max(posPercent, quatPercent, scalePercent)\n        }\n        \n        if ('isVector3' in start) {\n            const s = start as THREE.Vector3\n            const e = end as THREE.Vector3\n            if (!this.range) return e.equals(s) ? 0 : Infinity\n            const percent = vectors.get().subVectors(e, s).divide(this.range as THREE.Vector3)\n            const {x,y,z} = percent\n            vectors.pool(percent)\n            return Math.max(Math.abs(x||0),Math.abs(y||0),Math.abs(z||0))\n        } \n        \n        if ('isVector2' in start) {\n            const s = start as THREE.Vector2\n            const e = end as THREE.Vector2\n            if (!this.range) return e.equals(s) ? 0 : Infinity\n            const percent = vectors2.get().subVectors(e, s).divide(this.range as THREE.Vector2)\n            const {x,y} = percent\n            vectors2.pool(percent)\n            return Math.max(Math.abs(x||0),Math.abs(y||0))\n        } \n        \n        if ('isQuaternion' in start) {\n            const s = start as THREE.Quaternion\n            const e = end as THREE.Quaternion\n            return Math.abs(s.angleTo(e) / Math.PI)\n        } \n        \n        if ('isColor' in start) {\n            const s = start as THREE.Color\n            const e = end as THREE.Color\n            return Math.max(\n                Math.abs(e.r - s.r), \n                Math.abs(e.g - s.r), \n                Math.abs(e.b - s.r)\n            )\n        } \n        \n        if ('isBox3' in start) {\n            const s = start as THREE.Box3\n            const e = end as THREE.Box3\n            if (!this.range) return e.equals(s) ? 0 : Infinity\n            const size = this.range as ValueRange<THREE.Box3>\n            const minPercent = vectors.get().subVectors(e.min, s.min).divide(size)\n            const maxPercent = vectors.get().subVectors(e.max, s.max).divide(size)\n            const min = Math.max(Math.abs(minPercent.x||0), Math.abs(minPercent.y||0), Math.abs(minPercent.z||0))\n            const max = Math.max(Math.abs(maxPercent.x||0), Math.abs(maxPercent.y||0), Math.abs(maxPercent.z||0))\n            vectors.pool(minPercent)\n            vectors.pool(maxPercent)\n            return Math.max(min, max)\n        }\n\n        return Infinity\n    }\n\n    protected _config = {} as Required<TransitionableConfig>\n\n    protected _updateConfig(c?:TransitionableConfig) {\n        this._config.multiplier = defined(this.multiplier, c && c.multiplier, Transitioner.DEFAULT_CONFIG.multiplier)\n        this._config.duration = defined(this.duration, c && c.duration, Transitioner.DEFAULT_CONFIG.duration)\n        this._config.easing = defined(this.easing, c && c.easing, Transitioner.DEFAULT_CONFIG.easing)\n        this._config.threshold = defined(this.threshold, c && c.threshold, Transitioner.DEFAULT_CONFIG.threshold)\n        this._config.delay = defined(this.delay, c && c.delay, Transitioner.DEFAULT_CONFIG.delay)\n        this._config.debounce = defined(this.debounce, c && c.debounce, Transitioner.DEFAULT_CONFIG.debounce) \n        this._config.maxWait = defined(this.maxWait, c && c.maxWait, Transitioner.DEFAULT_CONFIG.maxWait)\n        return this._config\n    }\n\n}\n\nexport class LocalMatrixTransitionable extends Transitionable<THREE.Matrix4> {\n    constructor(public object:THREE.Object3D) {\n        super({ target: new THREE.Matrix4 })\n    }\n\n    position = new Transitionable({target: new THREE.Vector3})\n    quaternion = new Transitionable({target: new THREE.Quaternion})\n    scale = new Transitionable({target: new THREE.Vector3(1,1,1)})\n\n    autoRange = true\n    synchronizeComponents = true\n\n    update(deltaTime:number, c?:TransitionableConfig) {\n        this._updateConfig(c)\n        const {position, quaternion, scale, _config} = this\n\n        if (this.autoRange) {\n            if (!position.range) position.range = new THREE.Vector3\n            if (!scale.range) scale.range = new THREE.Vector3\n            this.object.layout.computedOuterBounds.getSize(position.range)\n            this.object.layout.computedOuterBounds.getSize(scale.range).divide(position.range)\n            if (!isFinite(scale.range.x) || scale.range.x === 0) scale.range.x = 1\n            if (!isFinite(scale.range.y) || scale.range.y === 0) scale.range.y = 1\n            if (!isFinite(scale.range.z) || scale.range.z === 0) scale.range.z = 1\n        }\n        \n        this.target.decompose(position.target, quaternion.target, scale.target)\n        this.current.decompose(position.current, quaternion.current, scale.current)\n        \n        let changePercent:number|undefined = undefined\n        if (this.synchronizeComponents) {\n            changePercent = Math.max(\n                position._computePercentChange(), \n                quaternion._computePercentChange(), \n                scale._computePercentChange()\n            )\n        }\n\n        position.update(deltaTime, _config, changePercent)\n        quaternion.update(deltaTime, _config, changePercent)\n        scale.update(deltaTime, _config, changePercent)\n        this.current.compose(position.current, quaternion.current, scale.current)\n    }\n}\n\n/**\n * Enables smooth interpolation of various kinds of values, with hysteresis\n */\nexport class Transitioner {\n\n    static disableAllTransitions = false\n\n    static DEFAULT_CONFIG:Required<TransitionableConfig> = {\n        multiplier: 1,\n        duration: 1.5,\n        easing: easing.easeInOut,\n        threshold: 1e-2,\n        delay: 0,\n        debounce: 0,\n        maxWait: 10\n    }\n\n    /**\n     * The amount of time (in milliseconds) it takes to smoothly \n     * damp towards the target.\n     * \n     * By defualt, based on a progress threshold of 0.96\n     * \n     * progress = 1 - Math.exp(-time)\n     * time = - Math.log(1-progress)\n     */\n    static NATURAL_DURATION = - Math.log(1 - 0.95)\n    \n    /**\n     * \n     */\n    set active(active:boolean) {\n        this._active = active\n    }\n    get active() {\n        return this._active && !Transitioner.disableAllTransitions\n    }\n    private _active = false\n\n    /**\n     * Specifies the desired parent coordinate system.\n     */\n    parentTarget : THREE.Object3D|null = null\n\n    /**\n     * The local matrix transitionable\n     */\n    matrixLocal:LocalMatrixTransitionable\n    \n    /**\n     * The target world matrix, automatically computed from pose/layout properties\n     */\n    matrixWorldTarget = new THREE.Matrix4\n\n    /**\n     * A multiplier to influence the speed of the transition\n     */\n    multiplier? : number = undefined\n    \n    /**\n     * The duration of the easing function\n     */\n    duration? : number = undefined\n\n    /**\n     * The easing function \n     */\n    easing? : (alpha:number) => number = undefined\n\n    /**\n     * The percentage that the `target` must differ from the `committedTarget`, \n     * the last target added to the `targetQueue`, or the `current` value  (in  that order)\n     * before it is considered \"changed\"\n     */\n    threshold? : number = undefined\n\n    /**\n     * The number of seconds in which the `target` value must remain \"changed\" before it\n     * becomes the `committedTarget`\n     */\n    delay? : number = undefined\n\n    /**\n     * The number of seconds in which the `committedTarget` must \n     * remain stable before it is pushed to the `targetQueue`\n     */\n    debounce? : number = undefined\n\n    /**\n     * The maximum number of seconds to wait before the `committedTarget`\n     * is pushed to the `targetQueue`\n     */\n    maxWait? : number = undefined\n\n    /**\n     * \n     */\n    customTransitionables = [] as Transitionable[]\n\n    /**\n     * \n     * @param object \n     */\n    constructor(public object:THREE.Object3D) {\n        this.matrixLocal = new LocalMatrixTransitionable(this.object)\n    }\n\n    /**\n     * Add a transitionable\n     * @param transitionable \n     */\n    add<T extends ValueType>(transitionable:TransitionerConstructOptions<T>|Transitionable<T>) : Transitionable<T> {\n        const t = transitionable instanceof Transitionable ? \n            transitionable : new Transitionable(transitionable)\n        this.customTransitionables.push(t)\n        return t\n    }\n\n    /**\n     * Transitions pose, layout, and/or custom properties associated with an Object3D instance.\n     * \n     * When the transitioner is active, the object's pose (`position`, `quaternion`, and `scale`)\n     * and layout (`layout.absolute`, `layout.relative`, etc.) properties are treated as \n     * target values, and their corresponding target matrices are maintained in the transitioner \n     * instance (e.g., `transitioner.matrix`, `transitioner.layoutMatrix`). Meanwhile, the object's \n     * pose/layout matrices (`matrix` and `layout.matrix`) will only be updated when this `update` \n     * method is called).\n     * \n     * If `targetParent` is set and differs from the current `object.parent`, \n     * this method will smoothly switch to the new coordinate system. \n     */\n    update(deltaTime:number, autoActive=true) {\n\n        if (!this.active && autoActive) this.active = true\n\n        if (!this.active) { \n            this.matrixLocal.current.copy(this.matrixLocal.target)\n            for (const t of this.customTransitionables) {\n                t._setCurrent(t.target)\n            }\n            return\n        }\n\n        // refresh matrix targets if necessary\n        if (autoActive) this.object.updateWorldMatrix(true, true)\n        this._setParent()\n\n        // update transitionables\n        deltaTime = Math.max(deltaTime, 1e-10) // in case multiplier is Infinity\n        this.matrixLocal.update(deltaTime, this)\n        for (const t of this.customTransitionables) {\n            t.update(deltaTime, this)\n        }\n\n        this.object.updateWorldMatrix(false, true)\n    }\n\n    /**\n     * Ensure that this `object` is attached to the `targetParent` Object3D instance. \n     * When the `transitioner` is active, this method ensures a smooth transition \n     * to another coordinate system. If the `object` is already attached to the \n     * `targetParent`, this method is effectively noop.\n     */\n    private _setParent() {\n        const parent = this.parentTarget\n        const o = this.object\n        if (!parent) return\n        if (o.parent !== parent) {\n            o.updateWorldMatrix(true, true)\n            const originalMatrixWorld = matrices.get().copy(o.matrixWorld)\n            o.parent && o.parent.remove(o)\n            parent && parent.add(o)\n            parent.updateWorldMatrix(true, true)\n            const inverseParentMatrixWorld = parent ? matrices.get().getInverse(parent.matrixWorld) : matrices.get().identity()\n            o.matrix.copy(inverseParentMatrixWorld.multiply(originalMatrixWorld))\n            // const transitioner = o.layout.transitioner\n            // if (transitioner.active) {\n            //     transitioner.layout.weight = 0\n            //     o.matrix.decompose(transitioner.position, transitioner.quaternion, transitioner.scale)\n            // } else {\n            // }\n            o.matrix.decompose(o.position, o.quaternion, o.scale)\n            matrices.pool(originalMatrixWorld)\n            matrices.pool(inverseParentMatrixWorld)\n        }\n    }\n}\n\n// function resolve(path:string, obj=self as any, separator='.') {\n//     var properties = Array.isArray(path) ? path : path.split(separator)\n//     return properties.reduce((prev, curr) => prev && prev[curr], obj)\n// }\n\n// function set(path:string, obj=self as any, value:any, separator='.') {\n//     var properties = Array.isArray(path) ? path : path.split(separator)\n//     var lastPropertKey = properties.pop()\n//     const property = properties.reduce((prev, curr) => prev && prev[curr], obj)\n//     property[lastPropertKey] = value\n// }","import { Vector3, Vector2, Triangle, DoubleSide, BackSide, Face3 } from 'three';\r\n\r\n// Ripped and modified From THREE.js Mesh raycast\r\n// https://github.com/mrdoob/three.js/blob/0aa87c999fe61e216c1133fba7a95772b503eddf/src/objects/Mesh.js#L115\r\nvar vA = new Vector3();\r\nvar vB = new Vector3();\r\nvar vC = new Vector3();\r\n\r\nvar uvA = new Vector2();\r\nvar uvB = new Vector2();\r\nvar uvC = new Vector2();\r\n\r\nvar intersectionPoint = new Vector3();\r\nvar intersectionPointWorld = new Vector3();\r\n\r\nfunction checkIntersection( object, material, raycaster, ray, pA, pB, pC, point ) {\r\n\r\n\tvar intersect;\r\n\tif ( material.side === BackSide ) {\r\n\r\n\t\tintersect = ray.intersectTriangle( pC, pB, pA, true, point );\r\n\r\n\t} else {\r\n\r\n\t\tintersect = ray.intersectTriangle( pA, pB, pC, material.side !== DoubleSide, point );\r\n\r\n\t}\r\n\r\n\tif ( intersect === null ) return null;\r\n\r\n\tintersectionPointWorld.copy( point );\r\n\tintersectionPointWorld.applyMatrix4( object.matrixWorld );\r\n\r\n\tvar distance = raycaster.ray.origin.distanceTo( intersectionPointWorld );\r\n\r\n\tif ( distance < raycaster.near || distance > raycaster.far ) return null;\r\n\r\n\treturn {\r\n\t\tdistance: distance,\r\n\t\tpoint: intersectionPointWorld.clone(),\r\n\t\tobject: object\r\n\t};\r\n\r\n}\r\n\r\nfunction checkBufferGeometryIntersection( object, raycaster, ray, position, uv, a, b, c ) {\r\n\r\n\tvA.fromBufferAttribute( position, a );\r\n\tvB.fromBufferAttribute( position, b );\r\n\tvC.fromBufferAttribute( position, c );\r\n\r\n\tvar intersection = checkIntersection( object, object.material, raycaster, ray, vA, vB, vC, intersectionPoint );\r\n\r\n\tif ( intersection ) {\r\n\r\n\t\tif ( uv ) {\r\n\r\n\t\t\tuvA.fromBufferAttribute( uv, a );\r\n\t\t\tuvB.fromBufferAttribute( uv, b );\r\n\t\t\tuvC.fromBufferAttribute( uv, c );\r\n\r\n\t\t\tintersection.uv = Triangle.getUV( intersectionPoint, vA, vB, vC, uvA, uvB, uvC, new Vector2( ) );\r\n\r\n\t\t}\r\n\r\n\t\tvar normal = new Vector3();\r\n\t\tintersection.face = new Face3( a, b, c, Triangle.getNormal( vA, vB, vC, normal ) );\r\n\t\tintersection.faceIndex = a;\r\n\r\n\t}\r\n\r\n\treturn intersection;\r\n\r\n}\r\n\r\n\r\n// https://github.com/mrdoob/three.js/blob/0aa87c999fe61e216c1133fba7a95772b503eddf/src/objects/Mesh.js#L258\r\nfunction intersectTri( mesh, geo, raycaster, ray, tri, intersections ) {\r\n\r\n\tconst triOffset = tri * 3;\r\n\tconst a = geo.index.getX( triOffset );\r\n\tconst b = geo.index.getX( triOffset + 1 );\r\n\tconst c = geo.index.getX( triOffset + 2 );\r\n\r\n\tconst intersection = checkBufferGeometryIntersection( mesh, raycaster, ray, geo.attributes.position, geo.attributes.uv, a, b, c );\r\n\r\n\tif ( intersection ) {\r\n\r\n\t\tintersection.faceIndex = tri;\r\n\t\tif ( intersections ) intersections.push( intersection );\r\n\t\treturn intersection;\r\n\r\n\t}\r\n\r\n\treturn null;\r\n\r\n};\r\n\r\nexport { intersectTri };\r\n","// Returns a Float32Array representing the bounds data for box.\r\nexport function boxToArray( bx ) {\r\n\r\n\tconst arr = new Float32Array( 6 );\r\n\r\n\tarr[ 0 ] = bx.min.x;\r\n\tarr[ 1 ] = bx.min.y;\r\n\tarr[ 2 ] = bx.min.z;\r\n\r\n\tarr[ 3 ] = bx.max.x;\r\n\tarr[ 4 ] = bx.max.y;\r\n\tarr[ 5 ] = bx.max.z;\r\n\r\n\treturn arr;\r\n\r\n}\r\n\r\nexport function arrayToBox( arr, target ) {\r\n\r\n\ttarget.min.x = arr[ 0 ];\r\n\ttarget.min.y = arr[ 1 ];\r\n\ttarget.min.z = arr[ 2 ];\r\n\r\n\ttarget.max.x = arr[ 3 ];\r\n\ttarget.max.y = arr[ 4 ];\r\n\ttarget.max.z = arr[ 5 ];\r\n\r\n\treturn target;\r\n\r\n}\r\n\r\nexport function getLongestEdgeIndex( bounds ) {\r\n\r\n\tlet splitDimIdx = - 1;\r\n\tlet splitDist = - Infinity;\r\n\r\n\tfor ( let i = 0; i < 3; i ++ ) {\r\n\r\n\t\tconst dist = bounds[ i + 3 ] - bounds[ i ];\r\n\t\tif ( dist > splitDist ) {\r\n\r\n\t\t\tsplitDist = dist;\r\n\t\t\tsplitDimIdx = i;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn splitDimIdx;\r\n\r\n}\r\n","import { Vector3 } from 'three';\r\n\r\nexport class SeparatingAxisBounds {\r\n\r\n\tconstructor() {\r\n\r\n\t\tthis.min = Infinity;\r\n\t\tthis.max = - Infinity;\r\n\r\n\t}\r\n\r\n\tsetFromPointsField( points, field ) {\r\n\r\n\t\tlet min = Infinity;\r\n\t\tlet max = - Infinity;\r\n\t\tfor ( let i = 0, l = points.length; i < l; i ++ ) {\r\n\r\n\t\t\tconst p = points[ i ];\r\n\t\t\tconst val = p[ field ];\r\n\t\t\tmin = Math.min( val, min );\r\n\t\t\tmax = Math.max( val, max );\r\n\r\n\t\t}\r\n\r\n\t\tthis.min = min;\r\n\t\tthis.max = max;\r\n\r\n\r\n\t}\r\n\r\n\tsetFromPoints( axis, points ) {\r\n\r\n\t\tlet min = Infinity;\r\n\t\tlet max = - Infinity;\r\n\t\tfor ( let i = 0, l = points.length; i < l; i ++ ) {\r\n\r\n\t\t\tconst p = points[ i ];\r\n\t\t\tconst val = axis.dot( p );\r\n\t\t\tmin = Math.min( val, min );\r\n\t\t\tmax = Math.max( val, max );\r\n\r\n\t\t}\r\n\r\n\t\tthis.min = min;\r\n\t\tthis.max = max;\r\n\r\n\t}\r\n\r\n\tisSeparated( other ) {\r\n\r\n\t\treturn this.min > other.max || other.min > this.max;\r\n\r\n\t}\r\n\r\n}\r\n\r\nSeparatingAxisBounds.prototype.setFromBox = ( function () {\r\n\r\n\tconst p = new Vector3();\r\n\treturn function setFromBox( axis, box ) {\r\n\r\n\t\tconst boxMin = box.min;\r\n\t\tconst boxMax = box.max;\r\n\t\tlet min = Infinity;\r\n\t\tlet max = - Infinity;\r\n\t\tfor ( let x = 0; x <= 1; x ++ ) {\r\n\r\n\t\t\tfor ( let y = 0; y <= 1; y ++ ) {\r\n\r\n\t\t\t\tfor ( let z = 0; z <= 1; z ++ ) {\r\n\r\n\t\t\t\t\tp.x = boxMin.x * x + boxMax.x * ( 1 - x );\r\n\t\t\t\t\tp.y = boxMin.y * y + boxMax.y * ( 1 - y );\r\n\t\t\t\t\tp.z = boxMin.z * z + boxMax.z * ( 1 - z );\r\n\r\n\t\t\t\t\tconst val = axis.dot( p );\r\n\t\t\t\t\tmin = Math.min( val, min );\r\n\t\t\t\t\tmax = Math.max( val, max );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tthis.min = min;\r\n\t\tthis.max = max;\r\n\r\n\t};\r\n\r\n} )();\r\n\r\nexport const areIntersecting = ( function () {\r\n\r\n\tconst cacheSatBounds = new SeparatingAxisBounds();\r\n\treturn function areIntersecting( shape1, shape2 ) {\r\n\r\n\t\tconst points1 = shape1.points;\r\n\t\tconst satAxes1 = shape1.satAxes;\r\n\t\tconst satBounds1 = shape1.satBounds;\r\n\r\n\t\tconst points2 = shape2.points;\r\n\t\tconst satAxes2 = shape2.satAxes;\r\n\t\tconst satBounds2 = shape2.satBounds;\r\n\r\n\t\t// check axes of the first shape\r\n\t\tfor ( let i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\tconst sb = satBounds1[ i ];\r\n\t\t\tconst sa = satAxes1[ i ];\r\n\t\t\tcacheSatBounds.setFromPoints( sa, points2 );\r\n\t\t\tif ( sb.isSeparated( cacheSatBounds ) ) return false;\r\n\r\n\t\t}\r\n\r\n\t\t// check axes of the second shape\r\n\t\tfor ( let i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\tconst sb = satBounds2[ i ];\r\n\t\t\tconst sa = satAxes2[ i ];\r\n\t\t\tcacheSatBounds.setFromPoints( sa, points1 );\r\n\t\t\tif ( sb.isSeparated( cacheSatBounds ) ) return false;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n} )();\r\n","import { Vector3, Vector2, Plane, Line3 } from 'three';\r\nexport const closestPointLineToLine = ( function () {\r\n\r\n\t// https://github.com/juj/MathGeoLib/blob/master/src/Geometry/Line.cpp#L56\r\n\tconst dir1 = new Vector3();\r\n\tconst dir2 = new Vector3();\r\n\tconst v02 = new Vector3();\r\n\treturn function closestPointLineToLine( l1, l2, result ) {\r\n\r\n\t\tconst v0 = l1.start;\r\n\t\tconst v10 = dir1;\r\n\t\tconst v2 = l2.start;\r\n\t\tconst v32 = dir2;\r\n\r\n\t\tv02.subVectors( v0, v2 );\r\n\t\tdir1.subVectors( l1.end, l2.start );\r\n\t\tdir2.subVectors( l2.end, l2.start );\r\n\r\n\t\t// float d0232 = v02.Dot(v32);\r\n\t\tconst d0232 = v02.dot( v32 );\r\n\r\n\t\t// float d3210 = v32.Dot(v10);\r\n\t\tconst d3210 = v32.dot( v10 );\r\n\r\n\t\t// float d3232 = v32.Dot(v32);\r\n\t\tconst d3232 = v32.dot( v32 );\r\n\r\n\t\t// float d0210 = v02.Dot(v10);\r\n\t\tconst d0210 = v02.dot( v10 );\r\n\r\n\t\t// float d1010 = v10.Dot(v10);\r\n\t\tconst d1010 = v10.dot( v10 );\r\n\r\n\t\t// float denom = d1010*d3232 - d3210*d3210;\r\n\t\tconst denom = d1010 * d3232 - d3210 * d3210;\r\n\r\n\t\tlet d, d2;\r\n\t\tif ( denom !== 0 ) {\r\n\r\n\t\t\td = ( d0232 * d3210 - d0210 * d3232 ) / denom;\r\n\r\n\t\t} else {\r\n\r\n\t\t\td = 0;\r\n\r\n\t\t}\r\n\r\n\t\td2 = ( d0232 + d * d3210 ) / d3232;\r\n\r\n\t\tresult.x = d;\r\n\t\tresult.y = d2;\r\n\r\n\t};\r\n\r\n} )();\r\n\r\nexport const closestPointsSegmentToSegment = ( function () {\r\n\r\n\t// https://github.com/juj/MathGeoLib/blob/master/src/Geometry/LineSegment.cpp#L187\r\n\tconst paramResult = new Vector2();\r\n\tconst temp1 = new Vector3();\r\n\tconst temp2 = new Vector3();\r\n\treturn function closestPointsSegmentToSegment( l1, l2, target1, target2 ) {\r\n\r\n\t\tclosestPointLineToLine( l1, l2, paramResult );\r\n\r\n\t\tlet d = paramResult.x;\r\n\t\tlet d2 = paramResult.y;\r\n\t\tif ( d >= 0 && d <= 1 && d2 >= 0 && d2 <= 1 ) {\r\n\r\n\t\t\tl1.at( d, target1 );\r\n\t\t\tl2.at( d2, target2 );\r\n\r\n\t\t\treturn;\r\n\r\n\t\t} else if ( d >= 0 && d <= 1 ) {\r\n\r\n\t\t\t// Only d2 is out of bounds.\r\n\t\t\tif ( d2 < 0 ) {\r\n\r\n\t\t\t\tl2.at( 0, target2 );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tl2.at( 1, target2 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tl1.closestPointToPoint( target2, true, target1 );\r\n\t\t\treturn;\r\n\r\n\t\t} else if ( d2 >= 0 && d2 <= 1 ) {\r\n\r\n\t\t\t// Only d is out of bounds.\r\n\t\t\tif ( d < 0 ) {\r\n\r\n\t\t\t\tl1.at( 0, target1 );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tl1.at( 1, target1 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tl2.closestPointToPoint( target1, true, target2 );\r\n\t\t\treturn;\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// Both u and u2 are out of bounds.\r\n\t\t\tlet p;\r\n\t\t\tif ( d < 0 ) {\r\n\r\n\t\t\t\tp = l1.start;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tp = l1.end;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tlet p2;\r\n\t\t\tif ( d2 < 0 ) {\r\n\r\n\t\t\t\tp2 = l2.start;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tp2 = l2.end;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst closestPoint = temp1;\r\n\t\t\tconst closestPoint2 = temp2;\r\n\t\t\tl1.closestPointToPoint( p2, true, temp1 );\r\n\t\t\tl2.closestPointToPoint( p, true, temp2 );\r\n\r\n\t\t\tif ( closestPoint.distanceToSquared( p2 ) <= closestPoint2.distanceToSquared( p ) ) {\r\n\r\n\t\t\t\ttarget1.copy( closestPoint );\r\n\t\t\t\ttarget2.copy( p2 );\r\n\t\t\t\treturn;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\ttarget1.copy( p );\r\n\t\t\t\ttarget2.copy( closestPoint2 );\r\n\t\t\t\treturn;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n} )();\r\n\r\n\r\nexport const sphereIntersectTriangle = ( function () {\r\n\r\n\t// https://stackoverflow.com/questions/34043955/detect-collision-between-sphere-and-triangle-in-three-js\r\n\tconst closestPointTemp = new Vector3();\r\n\tconst projectedPointTemp = new Vector3();\r\n\tconst planeTemp = new Plane();\r\n\tconst lineTemp = new Line3();\r\n\treturn function sphereIntersectTriangle( sphere, triangle ) {\r\n\r\n\t\tconst { radius, center } = sphere;\r\n\t\tconst { a, b, c } = triangle;\r\n\r\n\t\t// phase 1\r\n\t\tlineTemp.start = a;\r\n\t\tlineTemp.end = b;\r\n\t\tconst closestPoint1 = lineTemp.closestPointToPoint( center, true, closestPointTemp );\r\n\t\tif ( closestPoint1.distanceTo( center ) <= radius ) return true;\r\n\r\n\t\tlineTemp.start = a;\r\n\t\tlineTemp.end = c;\r\n\t\tconst closestPoint2 = lineTemp.closestPointToPoint( center, true, closestPointTemp );\r\n\t\tif ( closestPoint2.distanceTo( center ) <= radius ) return true;\r\n\r\n\t\tlineTemp.start = b;\r\n\t\tlineTemp.end = c;\r\n\t\tconst closestPoint3 = lineTemp.closestPointToPoint( center, true, closestPointTemp );\r\n\t\tif ( closestPoint3.distanceTo( center ) <= radius ) return true;\r\n\r\n\t\t// phase 2\r\n\t\tconst plane = triangle.getPlane( planeTemp );\r\n\t\tconst dp = Math.abs( plane.distanceToPoint( center ) );\r\n\t\tif ( dp <= radius ) {\r\n\r\n\t\t\tconst pp = plane.projectPoint( center, projectedPointTemp );\r\n\t\t\tconst cp = triangle.containsPoint( pp );\r\n\t\t\tif ( cp ) return true;\r\n\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\r\n\t};\r\n\r\n} )();\r\n","import { Triangle, Vector3, Line3, Sphere } from 'three';\r\nimport { SeparatingAxisBounds } from './SeparatingAxisBounds.js';\r\nimport { closestPointsSegmentToSegment } from './MathUtilities.js';\r\n\r\nexport class SeparatingAxisTriangle extends Triangle {\r\n\r\n\tconstructor( ...args ) {\r\n\r\n\t\tsuper( ...args );\r\n\r\n\t\tthis.isSeparatingAxisTriangle = true;\r\n\t\tthis.satAxes = new Array( 4 ).fill().map( () => new Vector3() );\r\n\t\tthis.satBounds = new Array( 4 ).fill().map( () => new SeparatingAxisBounds() );\r\n\t\tthis.points = [ this.a, this.b, this.c ];\r\n\t\tthis.sphere = new Sphere();\r\n\r\n\t}\r\n\r\n}\r\n\r\nSeparatingAxisTriangle.prototype.update = ( function () {\r\n\r\n\tconst arr = new Array( 3 );\r\n\treturn function update( ) {\r\n\r\n\t\tconst a = this.a;\r\n\t\tconst b = this.b;\r\n\t\tconst c = this.c;\r\n\r\n\t\tarr[ 0 ] = this.a;\r\n\t\tarr[ 1 ] = this.b;\r\n\t\tarr[ 2 ] = this.c;\r\n\r\n\t\tconst satAxes = this.satAxes;\r\n\t\tconst satBounds = this.satBounds;\r\n\r\n\t\tconst axis0 = satAxes[ 0 ];\r\n\t\tconst sab0 = satBounds[ 0 ];\r\n\t\tthis.getNormal( axis0 );\r\n\t\tsab0.setFromPoints( axis0, arr );\r\n\r\n\t\tconst axis1 = satAxes[ 1 ];\r\n\t\tconst sab1 = satBounds[ 1 ];\r\n\t\taxis1.subVectors( a, b );\r\n\t\tsab1.setFromPoints( axis1, arr );\r\n\r\n\t\tconst axis2 = satAxes[ 2 ];\r\n\t\tconst sab2 = satBounds[ 2 ];\r\n\t\taxis2.subVectors( b, c );\r\n\t\tsab2.setFromPoints( axis2, arr );\r\n\r\n\t\tconst axis3 = satAxes[ 3 ];\r\n\t\tconst sab3 = satBounds[ 3 ];\r\n\t\taxis3.subVectors( c, a );\r\n\t\tsab3.setFromPoints( axis3, arr );\r\n\r\n\t\tthis.sphere.setFromPoints( this.points );\r\n\r\n\t};\r\n\r\n} )();\r\n\r\nSeparatingAxisTriangle.prototype.intersectsTriangle = ( function () {\r\n\r\n\tconst saTri2 = new SeparatingAxisTriangle();\r\n\tconst arr1 = new Array( 3 );\r\n\tconst arr2 = new Array( 3 );\r\n\tconst cachedSatBounds = new SeparatingAxisBounds();\r\n\tconst cachedSatBounds2 = new SeparatingAxisBounds();\r\n\tconst cachedAxis = new Vector3();\r\n\treturn function intersectsTriangle( other ) {\r\n\r\n\t\tif ( ! other.isSeparatingAxisTriangle ) {\r\n\r\n\t\t\tsaTri2.copy( other );\r\n\t\t\tsaTri2.update();\r\n\t\t\tother = saTri2;\r\n\r\n\t\t}\r\n\r\n\t\tconst satBounds1 = this.satBounds;\r\n\t\tconst satAxes1 = this.satAxes;\r\n\t\tarr2[ 0 ] = other.a;\r\n\t\tarr2[ 1 ] = other.b;\r\n\t\tarr2[ 2 ] = other.c;\r\n\t\tfor ( let i = 0; i < 4; i ++ ) {\r\n\r\n\t\t\tconst sb = satBounds1[ i ];\r\n\t\t\tconst sa = satAxes1[ i ];\r\n\t\t\tcachedSatBounds.setFromPoints( sa, arr2 );\r\n\t\t\tif ( sb.isSeparated( cachedSatBounds ) ) return false;\r\n\r\n\t\t}\r\n\r\n\t\tconst satBounds2 = other.satBounds;\r\n\t\tconst satAxes2 = other.satAxes;\r\n\t\tarr1[ 0 ] = this.a;\r\n\t\tarr1[ 1 ] = this.b;\r\n\t\tarr1[ 2 ] = this.c;\r\n\t\tfor ( let i = 0; i < 4; i ++ ) {\r\n\r\n\t\t\tconst sb = satBounds2[ i ];\r\n\t\t\tconst sa = satAxes2[ i ];\r\n\t\t\tcachedSatBounds.setFromPoints( sa, arr1 );\r\n\t\t\tif ( sb.isSeparated( cachedSatBounds ) ) return false;\r\n\r\n\t\t}\r\n\r\n\t\t// check crossed axes\r\n\t\tfor ( let i = 0; i < 4; i ++ ) {\r\n\r\n\t\t\tconst sa1 = satAxes1[ i ];\r\n\t\t\tfor ( let i2 = 0; i2 < 4; i2 ++ ) {\r\n\r\n\t\t\t\tconst sa2 = satAxes2[ i2 ];\r\n\t\t\t\tcachedAxis.crossVectors( sa1, sa2 );\r\n\t\t\t\tcachedSatBounds.setFromPoints( cachedAxis, arr1 );\r\n\t\t\t\tcachedSatBounds2.setFromPoints( cachedAxis, arr2 );\r\n\t\t\t\tif ( cachedSatBounds.isSeparated( cachedSatBounds2 ) ) return false;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\r\n\t};\r\n\r\n} )();\r\n\r\n\r\nSeparatingAxisTriangle.prototype.distanceToPoint = ( function () {\r\n\r\n\tconst target = new Vector3();\r\n\treturn function distanceToPoint( point ) {\r\n\r\n\t\tthis.closestPointToPoint( point, target );\r\n\t\treturn point.distanceTo( target );\r\n\r\n\t};\r\n\r\n} )();\r\n\r\n\r\nSeparatingAxisTriangle.prototype.distanceToTriangle = ( function () {\r\n\r\n\tconst point = new Vector3();\r\n\tconst point2 = new Vector3();\r\n\tconst cornerFields = [ 'a', 'b', 'c' ];\r\n\tconst line1 = new Line3();\r\n\tconst line2 = new Line3();\r\n\r\n\treturn function distanceToTriangle( other, target1 = null, target2 = null ) {\r\n\r\n\t\tif ( this.intersectsTriangle( other ) ) {\r\n\r\n\t\t\t// TODO: This will not result in a point that lies on\r\n\t\t\t// the intersection line of the triangles\r\n\t\t\tif ( target1 || target2 ) {\r\n\r\n\t\t\t\tthis.getMidpoint( point );\r\n\t\t\t\tother.closestPointToPoint( point, point2 );\r\n\t\t\t\tthis.closestPointToPoint( point2, point );\r\n\r\n\t\t\t\tif ( target1 ) target1.copy( point );\r\n\t\t\t\tif ( target2 ) target2.copy( point2 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn 0;\r\n\r\n\t\t}\r\n\r\n\t\tlet closestDistanceSq = Infinity;\r\n\r\n\t\t// check all point distances\r\n\t\tfor ( let i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\tlet dist;\r\n\t\t\tconst field = cornerFields[ i ];\r\n\t\t\tconst otherVec = other[ field ];\r\n\t\t\tthis.closestPointToPoint( otherVec, point );\r\n\r\n\t\t\tdist = otherVec.distanceToSquared( point );\r\n\r\n\t\t\tif ( dist < closestDistanceSq ) {\r\n\r\n\t\t\t\tclosestDistanceSq = dist;\r\n\t\t\t\tif ( target1 ) target1.copy( point );\r\n\t\t\t\tif ( target2 ) target2.copy( otherVec );\r\n\r\n\t\t\t}\r\n\r\n\r\n\t\t\tconst thisVec = this[ field ];\r\n\t\t\tother.closestPointToPoint( thisVec, point );\r\n\r\n\t\t\tdist = thisVec.distanceToSquared( point );\r\n\r\n\t\t\tif ( dist < closestDistanceSq ) {\r\n\r\n\t\t\t\tclosestDistanceSq = dist;\r\n\t\t\t\tif ( target1 ) target1.copy( thisVec );\r\n\t\t\t\tif ( target2 ) target2.copy( point );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfor ( let i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\tconst f11 = cornerFields[ i ];\r\n\t\t\tconst f12 = cornerFields[ ( i + 1 ) % 3 ];\r\n\t\t\tline1.set( this[ f11 ], this[ f12 ] );\r\n\t\t\tfor ( let i2 = 0; i2 < 3; i2 ++ ) {\r\n\r\n\t\t\t\tconst f21 = cornerFields[ i2 ];\r\n\t\t\t\tconst f22 = cornerFields[ ( i2 + 1 ) % 3 ];\r\n\t\t\t\tline2.set( other[ f21 ], other[ f22 ] );\r\n\r\n\t\t\t\tclosestPointsSegmentToSegment( line1, line2, point, point2 );\r\n\r\n\t\t\t\tconst dist = point.distanceToSquared( point2 );\r\n\t\t\t\tif ( dist < closestDistanceSq ) {\r\n\r\n\t\t\t\t\tclosestDistanceSq = dist;\r\n\t\t\t\t\tif ( target1 ) target1.copy( point );\r\n\t\t\t\t\tif ( target2 ) target2.copy( point2 );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn Math.sqrt( closestDistanceSq );\r\n\r\n\t};\r\n\r\n} )();\r\n\r\n","import { Box3, Vector3, Matrix4, Sphere, Line3 } from 'three';\r\nimport { SeparatingAxisBounds } from './SeparatingAxisBounds.js';\r\nimport { SeparatingAxisTriangle } from './SeparatingAxisTriangle.js';\r\nimport { closestPointsSegmentToSegment } from './MathUtilities.js';\r\n\r\nexport class OrientedBox extends Box3 {\r\n\r\n\tconstructor( ...args ) {\r\n\r\n\t\tsuper( ...args );\r\n\r\n\t\tthis.isOrientedBox = true;\r\n\t\tthis.matrix = new Matrix4();\r\n\t\tthis.invMatrix = new Matrix4();\r\n\t\tthis.points = new Array( 8 ).fill().map( () => new Vector3() );\r\n\t\tthis.satAxes = new Array( 3 ).fill().map( () => new Vector3() );\r\n\t\tthis.satBounds = new Array( 3 ).fill().map( () => new SeparatingAxisBounds() );\r\n\t\tthis.alignedSatBounds = new Array( 3 ).fill().map( () => new SeparatingAxisBounds() );\r\n\t\tthis.sphere = new Sphere();\r\n\r\n\t}\r\n\r\n\tset( min, max, matrix ) {\r\n\r\n\t\tsuper.set( min, max );\r\n\t\tthis.matrix = matrix;\r\n\r\n\t}\r\n\r\n\tcopy( other ) {\r\n\r\n\t\tsuper.copy( other );\r\n\t\tthis.matrix.copy( other.matrix );\r\n\r\n\t}\r\n\r\n}\r\n\r\nOrientedBox.prototype.update = ( function () {\r\n\r\n\treturn function update() {\r\n\r\n\t\tconst matrix = this.matrix;\r\n\t\tconst min = this.min;\r\n\t\tconst max = this.max;\r\n\r\n\t\tconst points = this.points;\r\n\t\tfor ( let x = 0; x <= 1; x ++ ) {\r\n\r\n\t\t\tfor ( let y = 0; y <= 1; y ++ ) {\r\n\r\n\t\t\t\tfor ( let z = 0; z <= 1; z ++ ) {\r\n\r\n\t\t\t\t\tconst i = ( ( 1 << 0 ) * x ) | ( ( 1 << 1 ) * y ) | ( ( 1 << 2 ) * z );\r\n\t\t\t\t\tconst v = points[ i ];\r\n\t\t\t\t\tv.x = x ? max.x : min.x;\r\n\t\t\t\t\tv.y = y ? max.y : min.y;\r\n\t\t\t\t\tv.z = z ? max.z : min.z;\r\n\r\n\t\t\t\t\tv.applyMatrix4( matrix );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tthis.sphere.setFromPoints( this.points );\r\n\r\n\t\tconst satBounds = this.satBounds;\r\n\t\tconst satAxes = this.satAxes;\r\n\t\tconst minVec = points[ 0 ];\r\n\t\tfor ( let i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\tconst axis = satAxes[ i ];\r\n\t\t\tconst sb = satBounds[ i ];\r\n\t\t\tconst index = 1 << i;\r\n\t\t\tconst pi = points[ index ];\r\n\r\n\t\t\taxis.subVectors( minVec, pi );\r\n\t\t\tsb.setFromPoints( axis, points );\r\n\r\n\t\t}\r\n\r\n\t\tconst alignedSatBounds = this.alignedSatBounds;\r\n\t\talignedSatBounds[ 0 ].setFromPointsField( points, 'x' );\r\n\t\talignedSatBounds[ 1 ].setFromPointsField( points, 'y' );\r\n\t\talignedSatBounds[ 2 ].setFromPointsField( points, 'z' );\r\n\r\n\t\tthis.invMatrix.getInverse( this.matrix );\r\n\r\n\t};\r\n\r\n} )();\r\n\r\nOrientedBox.prototype.intersectsBox = ( function () {\r\n\r\n\tconst aabbBounds = new SeparatingAxisBounds();\r\n\treturn function intersectsBox( box ) {\r\n\r\n\t\tif ( ! box.intersectsSphere( this.sphere ) ) return false;\r\n\r\n\t\tconst min = box.min;\r\n\t\tconst max = box.max;\r\n\t\tconst satBounds = this.satBounds;\r\n\t\tconst satAxes = this.satAxes;\r\n\t\tconst alignedSatBounds = this.alignedSatBounds;\r\n\r\n\t\taabbBounds.min = min.x;\r\n\t\taabbBounds.max = max.x;\r\n\t\tif ( alignedSatBounds[ 0 ].isSeparated( aabbBounds ) ) return false;\r\n\r\n\t\taabbBounds.min = min.y;\r\n\t\taabbBounds.max = max.y;\r\n\t\tif ( alignedSatBounds[ 1 ].isSeparated( aabbBounds ) ) return false;\r\n\r\n\t\taabbBounds.min = min.z;\r\n\t\taabbBounds.max = max.z;\r\n\t\tif ( alignedSatBounds[ 2 ].isSeparated( aabbBounds ) ) return false;\r\n\r\n\t\tfor ( let i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\tconst axis = satAxes[ i ];\r\n\t\t\tconst sb = satBounds[ i ];\r\n\t\t\taabbBounds.setFromBox( axis, box );\r\n\t\t\tif ( sb.isSeparated( aabbBounds ) ) return false;\r\n\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\r\n\t};\r\n\r\n} )();\r\n\r\nOrientedBox.prototype.intersectsTriangle = ( function () {\r\n\r\n\tconst saTri = new SeparatingAxisTriangle();\r\n\tconst pointsArr = new Array( 3 );\r\n\tconst cachedSatBounds = new SeparatingAxisBounds();\r\n\tconst cachedSatBounds2 = new SeparatingAxisBounds();\r\n\tconst cachedAxis = new Vector3();\r\n\treturn function intersectsTriangle( triangle ) {\r\n\r\n\t\tif ( ! triangle.isSeparatingAxisTriangle ) {\r\n\r\n\t\t\tsaTri.copy( triangle );\r\n\t\t\tsaTri.update();\r\n\t\t\ttriangle = saTri;\r\n\r\n\t\t}\r\n\r\n\t\tconst satBounds = this.satBounds;\r\n\t\tconst satAxes = this.satAxes;\r\n\r\n\t\tpointsArr[ 0 ] = triangle.a;\r\n\t\tpointsArr[ 1 ] = triangle.b;\r\n\t\tpointsArr[ 2 ] = triangle.c;\r\n\r\n\t\tfor ( let i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\tconst sb = satBounds[ i ];\r\n\t\t\tconst sa = satAxes[ i ];\r\n\t\t\tcachedSatBounds.setFromPoints( sa, pointsArr );\r\n\t\t\tif ( sb.isSeparated( cachedSatBounds ) ) return false;\r\n\r\n\t\t}\r\n\r\n\t\tconst triSatBounds = triangle.satBounds;\r\n\t\tconst triSatAxes = triangle.satAxes;\r\n\t\tconst points = this.points;\r\n\t\tfor ( let i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\tconst sb = triSatBounds[ i ];\r\n\t\t\tconst sa = triSatAxes[ i ];\r\n\t\t\tcachedSatBounds.setFromPoints( sa, points );\r\n\t\t\tif ( sb.isSeparated( cachedSatBounds ) ) return false;\r\n\r\n\t\t}\r\n\r\n\t\t// check crossed axes\r\n\t\tfor ( let i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\tconst sa1 = satAxes[ i ];\r\n\t\t\tfor ( let i2 = 0; i2 < 4; i2 ++ ) {\r\n\r\n\t\t\t\tconst sa2 = triSatAxes[ i2 ];\r\n\t\t\t\tcachedAxis.crossVectors( sa1, sa2 );\r\n\t\t\t\tcachedSatBounds.setFromPoints( cachedAxis, pointsArr );\r\n\t\t\t\tcachedSatBounds2.setFromPoints( cachedAxis, points );\r\n\t\t\t\tif ( cachedSatBounds.isSeparated( cachedSatBounds2 ) ) return false;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\r\n\t};\r\n\r\n} )();\r\n\r\nOrientedBox.prototype.closestPointToPoint = ( function () {\r\n\r\n\treturn function closestPointToPoint( point, target1 ) {\r\n\r\n\t\ttarget1\r\n\t\t\t.copy( point )\r\n\t\t\t.applyMatrix4( this.invMatrix )\r\n\t\t\t.clamp( this.min, this.max )\r\n\t\t\t.applyMatrix4( this.matrix );\r\n\r\n\t\treturn target1;\r\n\r\n\t};\r\n\r\n} )();\r\n\r\nOrientedBox.prototype.distanceToPoint = ( function () {\r\n\r\n\tconst target = new Vector3();\r\n\treturn function distanceToPoint( point ) {\r\n\r\n\t\tthis.closestPointToPoint( point, target );\r\n\t\treturn point.distanceTo( target );\r\n\r\n\t};\r\n\r\n} )();\r\n\r\n\r\nOrientedBox.prototype.distanceToBox = ( function () {\r\n\r\n\tconst xyzFields = [ 'x', 'y', 'z' ];\r\n\tconst segments1 = new Array( 12 ).fill().map( () => new Line3() );\r\n\tconst segments2 = new Array( 12 ).fill().map( () => new Line3() );\r\n\r\n\tconst point1 = new Vector3();\r\n\tconst point2 = new Vector3();\r\n\r\n\treturn function distanceToBox( box, threshold = 0, target1 = null, target2 = null ) {\r\n\r\n\t\tif ( this.intersectsBox( box ) ) {\r\n\r\n\t\t\tif ( target1 || target2 ) {\r\n\r\n\t\t\t\tbox.getCenter( point2 );\r\n\t\t\t\tthis.closestPointToPoint( point2, point1 );\r\n\t\t\t\tbox.closestPointToPoint( point1, point2 );\r\n\r\n\t\t\t\tif ( target1 ) target1.copy( point1 );\r\n\t\t\t\tif ( target2 ) target2.copy( point2 );\r\n\r\n\t\t\t}\r\n\t\t\treturn 0;\r\n\r\n\t\t}\r\n\r\n\t\tconst threshold2 = threshold * threshold;\r\n\t\tconst min = box.min;\r\n\t\tconst max = box.max;\r\n\t\tconst points = this.points;\r\n\r\n\r\n\t\t// iterate over every edge and compare distances\r\n\t\tlet closestDistanceSq = Infinity;\r\n\r\n\t\t// check over all these points\r\n\t\tfor ( let i = 0; i < 8; i ++ ) {\r\n\r\n\t\t\tconst p = points[ i ];\r\n\t\t\tpoint2.copy( p ).clamp( min, max );\r\n\r\n\t\t\tconst dist = p.distanceToSquared( point2 );\r\n\t\t\tif ( dist < closestDistanceSq ) {\r\n\r\n\t\t\t\tclosestDistanceSq = dist;\r\n\t\t\t\tif ( target1 ) target1.copy( p );\r\n\t\t\t\tif ( target2 ) target2.copy( point2 );\r\n\r\n\t\t\t\tif ( dist < threshold2 ) return Math.sqrt( dist );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// generate and check all line segment distances\r\n\t\tlet count = 0;\r\n\t\tfor ( let i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\tfor ( let i1 = 0; i1 <= 1; i1 ++ ) {\r\n\r\n\t\t\t\tfor ( let i2 = 0; i2 <= 1; i2 ++ ) {\r\n\r\n\t\t\t\t\tconst nextIndex = ( i + 1 ) % 3;\r\n\t\t\t\t\tconst nextIndex2 = ( i + 2 ) % 3;\r\n\r\n\t\t\t\t\t// get obb line segments\r\n\t\t\t\t\tconst index = i1 << nextIndex | i2 << nextIndex2;\r\n\t\t\t\t\tconst index2 = 1 << i | i1 << nextIndex | i2 << nextIndex2;\r\n\t\t\t\t\tconst p1 = points[ index ];\r\n\t\t\t\t\tconst p2 = points[ index2 ];\r\n\t\t\t\t\tconst line1 = segments1[ count ];\r\n\t\t\t\t\tline1.set( p1, p2 );\r\n\r\n\r\n\t\t\t\t\t// get aabb line segments\r\n\t\t\t\t\tconst f1 = xyzFields[ i ];\r\n\t\t\t\t\tconst f2 = xyzFields[ nextIndex ];\r\n\t\t\t\t\tconst f3 = xyzFields[ nextIndex2 ];\r\n\t\t\t\t\tconst line2 = segments2[ count ];\r\n\t\t\t\t\tconst start = line2.start;\r\n\t\t\t\t\tconst end = line2.end;\r\n\r\n\t\t\t\t\tstart[ f1 ] = min[ f1 ];\r\n\t\t\t\t\tstart[ f2 ] = i1 ? min[ f2 ] : max[ f2 ];\r\n\t\t\t\t\tstart[ f3 ] = i2 ? min[ f3 ] : max[ f2 ];\r\n\r\n\t\t\t\t\tend[ f1 ] = max[ f1 ];\r\n\t\t\t\t\tend[ f2 ] = i1 ? min[ f2 ] : max[ f2 ];\r\n\t\t\t\t\tend[ f3 ] = i2 ? min[ f3 ] : max[ f2 ];\r\n\r\n\t\t\t\t\tcount ++;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// check all the other boxes point\r\n\t\tfor ( let x = 0; x <= 1; x ++ ) {\r\n\r\n\t\t\tfor ( let y = 0; y <= 1; y ++ ) {\r\n\r\n\t\t\t\tfor ( let z = 0; z <= 1; z ++ ) {\r\n\r\n\t\t\t\t\tpoint2.x = x ? max.x : min.x;\r\n\t\t\t\t\tpoint2.y = y ? max.y : min.y;\r\n\t\t\t\t\tpoint2.z = z ? max.z : min.z;\r\n\r\n\t\t\t\t\tthis.closestPointToPoint( point2, point1 );\r\n\t\t\t\t\tconst dist = point2.distanceToSquared( point1 );\r\n\t\t\t\t\tif ( dist < closestDistanceSq ) {\r\n\r\n\t\t\t\t\t\tclosestDistanceSq = dist;\r\n\t\t\t\t\t\tif ( target1 ) target1.copy( point1 );\r\n\t\t\t\t\t\tif ( target2 ) target2.copy( point2 );\r\n\r\n\t\t\t\t\t\tif ( dist < threshold2 ) return Math.sqrt( dist );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfor ( let i = 0; i < 12; i ++ ) {\r\n\r\n\t\t\tconst l1 = segments1[ i ];\r\n\t\t\tfor ( let i2 = 0; i2 < 12; i2 ++ ) {\r\n\r\n\t\t\t\tconst l2 = segments2[ i2 ];\r\n\t\t\t\tclosestPointsSegmentToSegment( l1, l2, point1, point2 );\r\n\t\t\t\tconst dist = point1.distanceToSquared( point2 );\r\n\t\t\t\tif ( dist < closestDistanceSq ) {\r\n\r\n\t\t\t\t\tclosestDistanceSq = dist;\r\n\t\t\t\t\tif ( target1 ) target1.copy( point1 );\r\n\t\t\t\t\tif ( target2 ) target2.copy( point2 );\r\n\r\n\t\t\t\t\tif ( dist < threshold2 ) return Math.sqrt( dist );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn Math.sqrt( closestDistanceSq );\r\n\r\n\t};\r\n\r\n} )();\r\n","\r\nimport * as THREE from 'three';\r\nimport { intersectTris, intersectClosestTri } from './Utils/RayIntersectTriUtlities.js';\r\nimport { arrayToBox } from './Utils/ArrayBoxUtilities.js';\r\nimport { OrientedBox } from './Utils/OrientedBox.js';\r\nimport { SeparatingAxisTriangle } from './Utils/SeparatingAxisTriangle.js';\r\nimport { sphereIntersectTriangle } from './Utils/MathUtilities.js';\r\n\r\nconst boundingBox = new THREE.Box3();\r\nconst boxIntersection = new THREE.Vector3();\r\nconst xyzFields = [ 'x', 'y', 'z' ];\r\n\r\nfunction setTriangle( tri, i, index, pos ) {\r\n\r\n\tconst ta = tri.a;\r\n\tconst tb = tri.b;\r\n\tconst tc = tri.c;\r\n\r\n\tlet i3 = index.getX( i );\r\n\tta.x = pos.getX( i3 );\r\n\tta.y = pos.getY( i3 );\r\n\tta.z = pos.getZ( i3 );\r\n\r\n\ti3 = index.getX( i + 1 );\r\n\ttb.x = pos.getX( i3 );\r\n\ttb.y = pos.getY( i3 );\r\n\ttb.z = pos.getZ( i3 );\r\n\r\n\ti3 = index.getX( i + 2 );\r\n\ttc.x = pos.getX( i3 );\r\n\ttc.y = pos.getY( i3 );\r\n\ttc.z = pos.getZ( i3 );\r\n\r\n}\r\n\r\nexport default\r\nclass MeshBVHNode {\r\n\r\n\tconstructor() {\r\n\r\n\t\t// internal nodes have boundingData, left, right, and splitAxis\r\n\t\t// leaf nodes have offset and count (referring to primitives in the mesh geometry)\r\n\r\n\t}\r\n\r\n\tintersectRay( ray, target ) {\r\n\r\n\t\tarrayToBox( this.boundingData, boundingBox );\r\n\r\n\t\treturn ray.intersectBox( boundingBox, target );\r\n\r\n\t}\r\n\r\n\traycast( mesh, raycaster, ray, intersects ) {\r\n\r\n\t\tif ( this.count ) intersectTris( mesh, mesh.geometry, raycaster, ray, this.offset, this.count, intersects );\r\n\t\telse {\r\n\r\n\t\t\tif ( this.left.intersectRay( ray, boxIntersection ) )\r\n\t\t\t\tthis.left.raycast( mesh, raycaster, ray, intersects );\r\n\t\t\tif ( this.right.intersectRay( ray, boxIntersection ) )\r\n\t\t\t\tthis.right.raycast( mesh, raycaster, ray, intersects );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\traycastFirst( mesh, raycaster, ray ) {\r\n\r\n\t\tif ( this.count ) {\r\n\r\n\t\t\treturn intersectClosestTri( mesh, mesh.geometry, raycaster, ray, this.offset, this.count );\r\n\r\n\t\t} else {\r\n\r\n\r\n\t\t\t// consider the position of the split plane with respect to the oncoming ray; whichever direction\r\n\t\t\t// the ray is coming from, look for an intersection among that side of the tree first\r\n\t\t\tconst splitAxis = this.splitAxis;\r\n\t\t\tconst xyzAxis = xyzFields[ splitAxis ];\r\n\t\t\tconst rayDir = ray.direction[ xyzAxis ];\r\n\t\t\tconst leftToRight = rayDir >= 0;\r\n\r\n\t\t\t// c1 is the child to check first\r\n\t\t\tlet c1, c2;\r\n\t\t\tif ( leftToRight ) {\r\n\r\n\t\t\t\tc1 = this.left;\r\n\t\t\t\tc2 = this.right;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tc1 = this.right;\r\n\t\t\t\tc2 = this.left;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst c1Intersection = c1.intersectRay( ray, boxIntersection );\r\n\t\t\tconst c1Result = c1Intersection ? c1.raycastFirst( mesh, raycaster, ray ) : null;\r\n\r\n\t\t\t// if we got an intersection in the first node and it's closer than the second node's bounding\r\n\t\t\t// box, we don't need to consider the second node because it couldn't possibly be a better result\r\n\t\t\tif ( c1Result ) {\r\n\r\n\t\t\t\t// check only along the split axis\r\n\t\t\t\tconst rayOrig = ray.origin[ xyzAxis ];\r\n\t\t\t\tconst toPoint = rayOrig - c1Result.point[ xyzAxis ];\r\n\t\t\t\tconst toChild1 = rayOrig - c2.boundingData[ splitAxis ];\r\n\t\t\t\tconst toChild2 = rayOrig - c2.boundingData[ splitAxis + 3 ];\r\n\r\n\t\t\t\tconst toPointSq = toPoint * toPoint;\r\n\t\t\t\tif ( toPointSq <= toChild1 * toChild1 && toPointSq <= toChild2 * toChild2 ) {\r\n\r\n\t\t\t\t\treturn c1Result;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// either there was no intersection in the first node, or there could still be a closer\r\n\t\t\t// intersection in the second, so check the second node and then take the better of the two\r\n\t\t\tconst c2Intersection = c2.intersectRay( ray, boxIntersection );\r\n\t\t\tconst c2Result = c2Intersection ? c2.raycastFirst( mesh, raycaster, ray ) : null;\r\n\r\n\t\t\tif ( c1Result && c2Result ) {\r\n\r\n\t\t\t\treturn c1Result.distance <= c2Result.distance ? c1Result : c2Result;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\treturn c1Result || c2Result || null;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\nMeshBVHNode.prototype.shapecast = ( function () {\r\n\r\n\tconst triangle = new SeparatingAxisTriangle();\r\n\tconst cachedBox1 = new THREE.Box3();\r\n\tconst cachedBox2 = new THREE.Box3();\r\n\treturn function shapecast( mesh, intersectsBoundsFunc, intersectsTriangleFunc = null, nodeScoreFunc = null ) {\r\n\r\n\t\tif ( this.count && intersectsTriangleFunc ) {\r\n\r\n\t\t\tconst geometry = mesh.geometry;\r\n\t\t\tconst index = geometry.index;\r\n\t\t\tconst pos = geometry.attributes.position;\r\n\t\t\tconst offset = this.offset;\r\n\t\t\tconst count = this.count;\r\n\r\n\t\t\tfor ( let i = offset * 3, l = ( count + offset ) * 3; i < l; i += 3 ) {\r\n\r\n\t\t\t\tsetTriangle( triangle, i, index, pos );\r\n\t\t\t\ttriangle.update();\r\n\r\n\t\t\t\tif ( intersectsTriangleFunc( triangle, i, i + 1, i + 2 ) ) {\r\n\r\n\t\t\t\t\treturn true;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn false;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tconst left = this.left;\r\n\t\t\tconst right = this.right;\r\n\t\t\tlet c1 = left;\r\n\t\t\tlet c2 = right;\r\n\r\n\t\t\tlet score1, score2;\r\n\t\t\tlet box1, box2;\r\n\t\t\tif ( nodeScoreFunc ) {\r\n\r\n\t\t\t\tbox1 = cachedBox1;\r\n\t\t\t\tbox2 = cachedBox2;\r\n\r\n\t\t\t\tarrayToBox( c1.boundingData, box1 );\r\n\t\t\t\tarrayToBox( c2.boundingData, box2 );\r\n\r\n\t\t\t\tscore1 = nodeScoreFunc( box1 );\r\n\t\t\t\tscore2 = nodeScoreFunc( box2 );\r\n\r\n\t\t\t\tif ( score2 < score1 ) {\r\n\r\n\t\t\t\t\tc1 = right;\r\n\t\t\t\t\tc2 = left;\r\n\r\n\t\t\t\t\tconst temp = score1;\r\n\t\t\t\t\tscore1 = score2;\r\n\t\t\t\t\tscore2 = temp;\r\n\r\n\t\t\t\t\tconst tempBox = box1;\r\n\t\t\t\t\tbox1 = box2;\r\n\t\t\t\t\tbox2 = tempBox;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( ! box1 ) {\r\n\r\n\t\t\t\tbox1 = cachedBox1;\r\n\t\t\t\tarrayToBox( c1.boundingData, box1 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst isC1Leaf = ! ! c1.count;\r\n\t\t\tconst c1Intersection =\r\n\t\t\t\tintersectsBoundsFunc( box1, isC1Leaf, score1, c1 ) &&\r\n\t\t\t\tc1.shapecast( mesh, intersectsBoundsFunc, intersectsTriangleFunc, nodeScoreFunc );\r\n\r\n\t\t\tif ( c1Intersection ) return true;\r\n\r\n\r\n\t\t\tif ( ! box2 ) {\r\n\r\n\t\t\t\tbox2 = cachedBox2;\r\n\t\t\t\tarrayToBox( c2.boundingData, box2 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst isC2Leaf = ! ! c2.count;\r\n\t\t\tconst c2Intersection =\r\n\t\t\t\tintersectsBoundsFunc( box2, isC2Leaf, score2, c2 ) &&\r\n\t\t\t\tc2.shapecast( mesh, intersectsBoundsFunc, intersectsTriangleFunc, nodeScoreFunc );\r\n\r\n\t\t\tif ( c2Intersection ) return true;\r\n\r\n\t\t\treturn false;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n} )();\r\n\r\nMeshBVHNode.prototype.intersectsGeometry = ( function () {\r\n\r\n\tconst triangle = new SeparatingAxisTriangle();\r\n\tconst triangle2 = new SeparatingAxisTriangle();\r\n\tconst cachedMesh = new THREE.Mesh();\r\n\tconst invertedMat = new THREE.Matrix4();\r\n\r\n\tconst obb = new OrientedBox();\r\n\tconst obb2 = new OrientedBox();\r\n\r\n\treturn function intersectsGeometry( mesh, geometry, geometryToBvh, cachedObb = null ) {\r\n\r\n\t\tif ( cachedObb === null ) {\r\n\r\n\t\t\tif ( ! geometry.boundingBox ) {\r\n\r\n\t\t\t\tgeometry.computeBoundingBox();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tobb.set( geometry.boundingBox.min, geometry.boundingBox.max, geometryToBvh );\r\n\t\t\tobb.update();\r\n\t\t\tcachedObb = obb;\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.count ) {\r\n\r\n\t\t\tconst thisGeometry = mesh.geometry;\r\n\t\t\tconst thisIndex = thisGeometry.index;\r\n\t\t\tconst thisPos = thisGeometry.attributes.position;\r\n\r\n\t\t\tconst index = geometry.index;\r\n\t\t\tconst pos = geometry.attributes.position;\r\n\r\n\t\t\tconst offset = this.offset;\r\n\t\t\tconst count = this.count;\r\n\r\n\t\t\t// get the inverse of the geometry matrix so we can transform our triangles into the\r\n\t\t\t// geometry space we're trying to test. We assume there are fewer triangles being checked\r\n\t\t\t// here.\r\n\t\t\tinvertedMat.getInverse( geometryToBvh );\r\n\r\n\t\t\tif ( geometry.boundsTree ) {\r\n\r\n\t\t\t\tfunction triangleCallback( tri ) {\r\n\r\n\t\t\t\t\ttri.a.applyMatrix4( geometryToBvh );\r\n\t\t\t\t\ttri.b.applyMatrix4( geometryToBvh );\r\n\t\t\t\t\ttri.c.applyMatrix4( geometryToBvh );\r\n\t\t\t\t\ttri.update();\r\n\r\n\t\t\t\t\tfor ( let i = offset * 3, l = ( count + offset ) * 3; i < l; i += 3 ) {\r\n\r\n\t\t\t\t\t\t// this triangle needs to be transformed into the current BVH coordinate frame\r\n\t\t\t\t\t\tsetTriangle( triangle2, i, thisIndex, thisPos );\r\n\t\t\t\t\t\ttriangle2.update();\r\n\t\t\t\t\t\tif ( tri.intersectsTriangle( triangle2 ) ) {\r\n\r\n\t\t\t\t\t\t\treturn true;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\treturn false;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tarrayToBox( this.boundingData, obb2 );\r\n\t\t\t\tobb2.matrix.copy( invertedMat );\r\n\t\t\t\tobb2.update();\r\n\r\n\t\t\t\tcachedMesh.geometry = geometry;\r\n\t\t\t\tconst res = geometry.boundsTree.shapecast( cachedMesh, box => obb2.intersectsBox( box ), triangleCallback );\r\n\t\t\t\tcachedMesh.geometry = null;\r\n\r\n\t\t\t\treturn res;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tfor ( let i = offset * 3, l = ( count + offset * 3 ); i < l; i += 3 ) {\r\n\r\n\t\t\t\t\t// this triangle needs to be transformed into the current BVH coordinate frame\r\n\t\t\t\t\tsetTriangle( triangle, i, thisIndex, thisPos );\r\n\t\t\t\t\ttriangle.a.applyMatrix4( invertedMat );\r\n\t\t\t\t\ttriangle.b.applyMatrix4( invertedMat );\r\n\t\t\t\t\ttriangle.c.applyMatrix4( invertedMat );\r\n\t\t\t\t\ttriangle.update();\r\n\r\n\t\t\t\t\tfor ( let i2 = 0, l2 = index.count; i2 < l2; i2 += 3 ) {\r\n\r\n\t\t\t\t\t\tsetTriangle( triangle2, i2, index, pos );\r\n\t\t\t\t\t\ttriangle2.update();\r\n\r\n\t\t\t\t\t\tif ( triangle.intersectsTriangle( triangle2 ) ) {\r\n\r\n\t\t\t\t\t\t\treturn true;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tconst left = this.left;\r\n\t\t\tconst right = this.right;\r\n\r\n\t\t\tarrayToBox( left.boundingData, boundingBox );\r\n\t\t\tconst leftIntersection =\r\n\t\t\t\tcachedObb.intersectsBox( boundingBox ) &&\r\n\t\t\t\tleft.intersectsGeometry( mesh, geometry, geometryToBvh, cachedObb );\r\n\r\n\t\t\tif ( leftIntersection ) return true;\r\n\r\n\r\n\t\t\tarrayToBox( right.boundingData, boundingBox );\r\n\t\t\tconst rightIntersection =\r\n\t\t\t\tcachedObb.intersectsBox( boundingBox ) &&\r\n\t\t\t\tright.intersectsGeometry( mesh, geometry, geometryToBvh, cachedObb );\r\n\r\n\t\t\tif ( rightIntersection ) return true;\r\n\r\n\t\t\treturn false;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n} )();\r\n\r\nMeshBVHNode.prototype.intersectsBox = ( function () {\r\n\r\n\tconst obb = new OrientedBox();\r\n\r\n\treturn function intersectsBox( mesh, box, boxToBvh ) {\r\n\r\n\t\tobb.set( box.min, box.max, boxToBvh );\r\n\t\tobb.update();\r\n\r\n\t\treturn this.shapecast(\r\n\t\t\tmesh,\r\n\t\t\tbox => obb.intersectsBox( box ),\r\n\t\t\ttri => obb.intersectsTriangle( tri )\r\n\t\t);\r\n\r\n\t};\r\n\r\n} )();\r\n\r\nMeshBVHNode.prototype.intersectsSphere = ( function () {\r\n\r\n\treturn function intersectsSphere( mesh, sphere ) {\r\n\r\n\t\treturn this.shapecast(\r\n\t\t\tmesh,\r\n\t\t\tbox => sphere.intersectsBox( box ),\r\n\t\t\ttri => sphereIntersectTriangle( sphere, tri )\r\n\t\t);\r\n\r\n\t};\r\n\r\n} )();\r\n\r\nMeshBVHNode.prototype.closestPointToPoint = ( function () {\r\n\r\n\t// early out if under minThreshold\r\n\t// skip checking if over maxThreshold\r\n\t// set minThreshold = maxThreshold to quickly check if a point is within a threshold\r\n\t// returns Infinity if no value found\r\n\r\n\tconst temp = new THREE.Vector3();\r\n\treturn function closestPointToPoint( mesh, point, target = null, minThreshold = 0, maxThreshold = Infinity ) {\r\n\r\n\t\tlet closestDistance = Infinity;\r\n\t\tthis.shapecast(\r\n\r\n\t\t\tmesh,\r\n\t\t\t( box, isLeaf, score ) => score < closestDistance && score < maxThreshold,\r\n\t\t\ttri => {\r\n\r\n\t\t\t\ttri.closestPointToPoint( point, temp );\r\n\t\t\t\tconst dist = point.distanceTo( temp );\r\n\t\t\t\tif ( dist < closestDistance ) {\r\n\r\n\t\t\t\t\tif ( target ) target.copy( temp );\r\n\t\t\t\t\tclosestDistance = dist;\r\n\r\n\t\t\t\t}\r\n\t\t\t\tif ( dist < minThreshold ) return true;\r\n\t\t\t\treturn false;\r\n\r\n\t\t\t},\r\n\t\t\tbox => box.distanceToPoint( point )\r\n\r\n\t\t);\r\n\r\n\t\treturn closestDistance;\r\n\r\n\t};\r\n\r\n} )();\r\n\r\nMeshBVHNode.prototype.closestPointToGeometry = ( function () {\r\n\r\n\t// early out if under minThreshold\r\n\t// skip checking if over maxThreshold\r\n\t// set minThreshold = maxThreshold to quickly check if a point is within a threshold\r\n\t// returns Infinity if no value found\r\n\r\n\tconst tri2 = new SeparatingAxisTriangle();\r\n\tconst obb = new OrientedBox();\r\n\r\n\tconst temp1 = new THREE.Vector3();\r\n\tconst temp2 = new THREE.Vector3();\r\n\treturn function closestPointToGeometry( mesh, geometry, geometryToBvh, target1 = null, target2 = null, minThreshold = 0, maxThreshold = Infinity ) {\r\n\r\n\t\tif ( ! geometry.boundingBox ) geometry.computeBoundingBox();\r\n\t\tobb.set( geometry.boundingBox.min, geometry.boundingBox.max, geometryToBvh );\r\n\t\tobb.update();\r\n\r\n\t\tconst pos = geometry.attributes.position;\r\n\t\tconst index = geometry.index;\r\n\r\n\t\tlet tempTarget1, tempTarget2;\r\n\t\tif ( target1 ) tempTarget1 = temp1;\r\n\t\tif ( target2 ) tempTarget2 = temp2;\r\n\r\n\t\tlet closestDistance = Infinity;\r\n\t\tthis.shapecast(\r\n\t\t\tmesh,\r\n\t\t\t( box, isLeaf, score ) => score < closestDistance && score < maxThreshold,\r\n\t\t\ttri => {\r\n\r\n\t\t\t\tconst sphere1 = tri.sphere;\r\n\t\t\t\tfor ( let i2 = 0, l2 = index.count; i2 < l2; i2 += 3 ) {\r\n\r\n\t\t\t\t\tsetTriangle( tri2, i2, index, pos );\r\n\t\t\t\t\ttri2.a.applyMatrix4( geometryToBvh );\r\n\t\t\t\t\ttri2.b.applyMatrix4( geometryToBvh );\r\n\t\t\t\t\ttri2.c.applyMatrix4( geometryToBvh );\r\n\t\t\t\t\ttri2.sphere.setFromPoints( tri2.points );\r\n\r\n\t\t\t\t\tconst sphere2 = tri2.sphere;\r\n\t\t\t\t\tconst sphereDist = sphere2.center.distanceTo( sphere1.center ) - sphere2.radius - sphere1.radius;\r\n\t\t\t\t\tif ( sphereDist > closestDistance ) continue;\r\n\r\n\t\t\t\t\ttri2.update();\r\n\r\n\t\t\t\t\tconst dist = tri.distanceToTriangle( tri2, tempTarget1, tempTarget2 );\r\n\t\t\t\t\tif ( dist < closestDistance ) {\r\n\r\n\t\t\t\t\t\tif ( target1 ) target1.copy( tempTarget1 );\r\n\t\t\t\t\t\tif ( target2 ) target2.copy( tempTarget2 );\r\n\t\t\t\t\t\tclosestDistance = dist;\r\n\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif ( dist < minThreshold ) return true;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn false;\r\n\r\n\t\t\t},\r\n\t\t\tbox => obb.distanceToBox( box, Math.min( closestDistance, maxThreshold ) )\r\n\r\n\t\t);\r\n\r\n\t\treturn closestDistance;\r\n\r\n\t};\r\n\r\n} )();\r\n","import { intersectTri } from './ThreeIntersectionUtilities.js';\r\n\r\nexport function intersectTris( mesh, geo, raycaster, ray, offset, count, intersections ) {\r\n\r\n\tfor ( let i = offset, end = offset + count; i < end; i ++ ) {\r\n\r\n\t\tintersectTri( mesh, geo, raycaster, ray, i, intersections );\r\n\r\n\t}\r\n\r\n};\r\n\r\nexport function intersectClosestTri( mesh, geo, raycaster, ray, offset, count ) {\r\n\r\n\tlet dist = Infinity;\r\n\tlet res = null;\r\n\tfor ( let i = offset, end = offset + count; i < end; i ++ ) {\r\n\r\n\t\tconst intersection = intersectTri( mesh, geo, raycaster, ray, i );\r\n\t\tif ( intersection && intersection.distance < dist ) {\r\n\r\n\t\t\tres = intersection;\r\n\t\t\tdist = intersection.distance;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn res;\r\n\r\n};\r\n","// Split strategy constants\r\nexport const CENTER = 0;\r\nexport const AVERAGE = 1;\r\nexport const SAH = 2;\r\n","import * as THREE from 'three';\r\nimport { arrayToBox, getLongestEdgeIndex } from './Utils/ArrayBoxUtilities.js';\r\nimport { CENTER, AVERAGE, SAH } from './Constants.js';\r\n\r\nconst xyzFields = [ 'x', 'y', 'z' ];\r\n\r\n// precomputes the bounding box for each triangle; required for quickly calculating tree splits.\r\n// result is an array of size tris.length * 6 where triangle i maps to a\r\n// [x_center, x_delta, y_center, y_delta, z_center, z_delta] tuple starting at index i * 6,\r\n// representing the center and half-extent in each dimension of triangle i\r\nfunction computeBounds( geo ) {\r\n\r\n\tconst verts = geo.attributes.position.array;\r\n\tconst index = geo.index.array;\r\n\tconst triCount = index.length / 3;\r\n\tconst bounds = new Float32Array( triCount * 6 );\r\n\r\n\tfor ( let tri = 0; tri < triCount; tri ++ ) {\r\n\r\n\t\tconst ai = index[ 3 * tri + 0 ] * 3;\r\n\t\tconst bi = index[ 3 * tri + 1 ] * 3;\r\n\t\tconst ci = index[ 3 * tri + 2 ] * 3;\r\n\r\n\t\tfor ( let el = 0; el < 3; el ++ ) {\r\n\r\n\t\t\tconst a = verts[ ai + el ];\r\n\t\t\tconst b = verts[ bi + el ];\r\n\t\t\tconst c = verts[ ci + el ];\r\n\t\t\tconst min = Math.min( a, b, c );\r\n\t\t\tconst max = Math.max( a, b, c );\r\n\t\t\tconst halfExtents = ( max - min ) / 2;\r\n\t\t\tbounds[ tri * 6 + el * 2 + 0 ] = min + halfExtents;\r\n\t\t\tbounds[ tri * 6 + el * 2 + 1 ] = halfExtents;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn bounds;\r\n\r\n}\r\n\r\nconst boxtemp = new THREE.Box3();\r\n\r\nexport default class BVHConstructionContext {\r\n\r\n\tconstructor( geo, options ) {\r\n\r\n\t\tthis.geo = geo;\r\n\t\tthis.options = options;\r\n\t\tthis.bounds = computeBounds( geo );\r\n\r\n\t\t// SAH Initialization\r\n\t\tthis.sahplanes = null;\r\n\t\tif ( options.strategy === SAH ) {\r\n\r\n\t\t\tconst triCount = geo.index.count / 3;\r\n\t\t\tthis.sahplanes = [ new Array( triCount ), new Array( triCount ), new Array( triCount ) ];\r\n\t\t\tfor ( let tri = 0; tri < triCount; tri ++ ) {\r\n\r\n\t\t\t\tfor ( let el = 0; el < 3; el ++ ) {\r\n\r\n\t\t\t\t\tthis.sahplanes[ el ][ tri ] = { p: this.bounds[ tri * 6 + el * 2 ], tri };\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// returns the average coordinate on the specified axis of the all the provided triangles\r\n\tgetAverage( offset, count, axis ) {\r\n\r\n\t\tlet avg = 0;\r\n\t\tconst bounds = this.bounds;\r\n\r\n\t\tfor ( let i = offset, end = offset + count; i < end; i ++ ) {\r\n\r\n\t\t\tavg += bounds[ i * 6 + axis * 2 ];\r\n\r\n\t\t}\r\n\r\n\t\treturn avg / count;\r\n\r\n\t}\r\n\r\n\t// computes the union of the bounds of all of the given triangles and puts the resulting box in target\r\n\tgetBounds( offset, count, target ) {\r\n\r\n\t\tlet minx = Infinity;\r\n\t\tlet miny = Infinity;\r\n\t\tlet minz = Infinity;\r\n\t\tlet maxx = - Infinity;\r\n\t\tlet maxy = - Infinity;\r\n\t\tlet maxz = - Infinity;\r\n\t\tconst bounds = this.bounds;\r\n\r\n\t\tfor ( let i = offset, end = offset + count; i < end; i ++ ) {\r\n\r\n\t\t\tconst cx = bounds[ i * 6 + 0 ];\r\n\t\t\tconst hx = bounds[ i * 6 + 1 ];\r\n\t\t\tminx = Math.min( minx, cx - hx );\r\n\t\t\tmaxx = Math.max( maxx, cx + hx );\r\n\t\t\tconst cy = bounds[ i * 6 + 2 ];\r\n\t\t\tconst hy = bounds[ i * 6 + 3 ];\r\n\t\t\tminy = Math.min( miny, cy - hy );\r\n\t\t\tmaxy = Math.max( maxy, cy + hy );\r\n\t\t\tconst cz = bounds[ i * 6 + 4 ];\r\n\t\t\tconst hz = bounds[ i * 6 + 5 ];\r\n\t\t\tminz = Math.min( minz, cz - hz );\r\n\t\t\tmaxz = Math.max( maxz, cz + hz );\r\n\r\n\t\t}\r\n\r\n\t\ttarget[ 0 ] = minx;\r\n\t\ttarget[ 1 ] = miny;\r\n\t\ttarget[ 2 ] = minz;\r\n\r\n\t\ttarget[ 3 ] = maxx;\r\n\t\ttarget[ 4 ] = maxy;\r\n\t\ttarget[ 5 ] = maxz;\r\n\r\n\t\treturn target;\r\n\r\n\t}\r\n\r\n\t// reorders `tris` such that for `count` elements after `offset`, elements on the left side of the split\r\n\t// will be on the left and elements on the right side of the split will be on the right. returns the index\r\n\t// of the first element on the right side, or offset + count if there are no elements on the right side.\r\n\tpartition( offset, count, split ) {\r\n\r\n\t\tlet left = offset;\r\n\t\tlet right = offset + count - 1;\r\n\t\tconst pos = split.pos;\r\n\t\tconst axisOffset = split.axis * 2;\r\n\t\tconst index = this.geo.index.array;\r\n\t\tconst bounds = this.bounds;\r\n\t\tconst sahplanes = this.sahplanes;\r\n\r\n\t\t// hoare partitioning, see e.g. https://en.wikipedia.org/wiki/Quicksort#Hoare_partition_scheme\r\n\t\twhile ( true ) {\r\n\r\n\t\t\twhile ( left <= right && bounds[ left * 6 + axisOffset ] < pos ) {\r\n\r\n\t\t\t\tleft ++;\r\n\r\n\t\t\t}\r\n\r\n\t\t\twhile ( left <= right && bounds[ right * 6 + axisOffset ] >= pos ) {\r\n\r\n\t\t\t\tright --;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( left < right ) {\r\n\r\n\t\t\t\t// we need to swap all of the information associated with the triangles at index\r\n\t\t\t\t// left and right; that's the verts in the geometry index, the bounds,\r\n\t\t\t\t// and perhaps the SAH planes\r\n\r\n\t\t\t\tfor ( let i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\t\t\tlet t0 = index[ left * 3 + i ];\r\n\t\t\t\t\tindex[ left * 3 + i ] = index[ right * 3 + i ];\r\n\t\t\t\t\tindex[ right * 3 + i ] = t0;\r\n\t\t\t\t\tlet t1 = bounds[ left * 6 + i * 2 + 0 ];\r\n\t\t\t\t\tbounds[ left * 6 + i * 2 + 0 ] = bounds[ right * 6 + i * 2 + 0 ];\r\n\t\t\t\t\tbounds[ right * 6 + i * 2 + 0 ] = t1;\r\n\t\t\t\t\tlet t2 = bounds[ left * 6 + i * 2 + 1 ];\r\n\t\t\t\t\tbounds[ left * 6 + i * 2 + 1 ] = bounds[ right * 6 + i * 2 + 1 ];\r\n\t\t\t\t\tbounds[ right * 6 + i * 2 + 1 ] = t2;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( sahplanes ) {\r\n\r\n\t\t\t\t\tfor ( let i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\t\t\t\tlet t = sahplanes[ i ][ left ];\r\n\t\t\t\t\t\tsahplanes[ i ][ left ] = sahplanes[ i ][ right ];\r\n\t\t\t\t\t\tsahplanes[ i ][ right ] = t;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tleft ++;\r\n\t\t\t\tright --;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\treturn left;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tgetOptimalSplit( bounds, offset, count, strategy ) {\r\n\r\n\t\tlet axis = - 1;\r\n\t\tlet pos = 0;\r\n\r\n\t\t// Center\r\n\t\tif ( strategy === CENTER ) {\r\n\r\n\t\t\taxis = getLongestEdgeIndex( bounds );\r\n\t\t\tif ( axis !== - 1 ) {\r\n\r\n\t\t\t\tpos = ( bounds[ axis + 3 ] + bounds[ axis ] ) / 2;\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( strategy === AVERAGE ) {\r\n\r\n\t\t\taxis = getLongestEdgeIndex( bounds );\r\n\t\t\tif ( axis !== - 1 ) {\r\n\r\n\t\t\t\tpos = this.getAverage( offset, count, axis );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( strategy === SAH ) {\r\n\r\n\t\t\t// Surface Area Heuristic\r\n\t\t\t// In order to make this code more terse, the x, y, and z\r\n\t\t\t// variables of various structures have been stuffed into\r\n\t\t\t// 0, 1, and 2 array indices so they can be easily computed\r\n\t\t\t// and accessed within array iteration\r\n\r\n\t\t\t// Cost values defineed for operations. We're using bounds for traversal, so\r\n\t\t\t// the cost of traversing one more layer is more than intersecting a triangle.\r\n\t\t\tconst TRAVERSAL_COST = 3;\r\n\t\t\tconst INTERSECTION_COST = 1;\r\n\t\t\tconst bb = arrayToBox( bounds, boxtemp );\r\n\r\n\t\t\t// Define the width, height, and depth of the bounds as a box\r\n\t\t\tconst dim = [\r\n\t\t\t\tbb.max.x - bb.min.x,\r\n\t\t\t\tbb.max.y - bb.min.y,\r\n\t\t\t\tbb.max.z - bb.min.z\r\n\t\t\t];\r\n\t\t\tconst sa = 2 * ( dim[ 0 ] * dim[ 1 ] + dim[ 0 ] * dim[ 2 ] + dim[ 1 ] * dim[ 2 ] );\r\n\r\n\t\t\t// Get the precalculated planes based for the triangles we're\r\n\t\t\t// testing here\r\n\t\t\tconst filteredLists = [[], [], []];\r\n\t\t\tfor ( let i = offset, end = offset + count; i < end; i ++ ) {\r\n\r\n\t\t\t\tfor ( let v = 0; v < 3; v ++ ) {\r\n\r\n\t\t\t\t\tfilteredLists[ v ].push( this.sahplanes[ v ][ i ] );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\t\t\tfilteredLists.forEach( planes => planes.sort( ( a, b ) => a.p - b.p ) );\r\n\r\n\t\t\t// this bounds surface area, left bound SA, left triangles, right bound SA, right triangles\r\n\t\t\tconst getCost = ( sa, sal, nl, sar, nr ) =>\r\n\t\t\t\t  TRAVERSAL_COST + INTERSECTION_COST * ( ( sal / sa ) * nl + ( sar / sa ) * nr );\r\n\r\n\t\t\t// the cost of _not_ splitting into smaller bounds\r\n\t\t\tconst noSplitCost = INTERSECTION_COST * count;\r\n\r\n\t\t\taxis = - 1;\r\n\t\t\tlet bestCost = noSplitCost;\r\n\t\t\tfor ( let i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\t\t// o1 and o2 represent the _other_ two axes in the\r\n\t\t\t\t// the space. So if we're checking the x (0) dimension,\r\n\t\t\t\t// then o1 and o2 would be y and z (1 and 2)\r\n\t\t\t\tconst o1 = ( i + 1 ) % 3;\r\n\t\t\t\tconst o2 = ( i + 2 ) % 3;\r\n\r\n\t\t\t\tconst bmin = bb.min[ xyzFields[ i ] ];\r\n\t\t\t\tconst bmax = bb.max[ xyzFields[ i ] ];\r\n\t\t\t\tconst planes = filteredLists[ i ];\r\n\r\n\t\t\t\t// The number of left and right triangles on either side\r\n\t\t\t\t// given the current split\r\n\t\t\t\tlet nl = 0;\r\n\t\t\t\tlet nr = count;\r\n\t\t\t\tfor ( let p = 0; p < planes.length; p ++ ) {\r\n\r\n\t\t\t\t\tconst pinfo = planes[ p ];\r\n\r\n\t\t\t\t\t// As the plane moves, we have to increment or decrement the\r\n\t\t\t\t\t// number of triangles on either side of the plane\r\n\t\t\t\t\tnl ++;\r\n\t\t\t\t\tnr --;\r\n\r\n\t\t\t\t\t// the distance from the plane to the edge of the broader bounds\r\n\t\t\t\t\tconst ldim = pinfo.p - bmin;\r\n\t\t\t\t\tconst rdim = bmax - pinfo.p;\r\n\r\n\t\t\t\t\t// same for the other two dimensions\r\n\t\t\t\t\tlet ldimo1 = dim[ o1 ], rdimo1 = dim[ o1 ];\r\n\t\t\t\t\tlet ldimo2 = dim[ o2 ], rdimo2 = dim[ o2 ];\r\n\r\n\t\t\t\t\t/*\r\n\t\t\t\t\t// compute the other bounding planes for the box\r\n\t\t\t\t\t// if only the current triangles are considered to\r\n\t\t\t\t\t// be in the box\r\n\t\t\t\t\t// This is really slow and probably not really worth it\r\n\t\t\t\t\tconst o1planes = this.sahplanes[o1];\r\n\t\t\t\t\tconst o2planes = this.sahplanes[o2];\r\n\t\t\t\t\tlet lmin = Infinity, lmax = -Infinity;\r\n\t\t\t\t\tlet rmin = Infinity, rmax = -Infinity;\r\n\t\t\t\t\tplanes.forEach((p, i) => {\r\n\t\t\t\t\tconst tri2 = p.tri * 2;\r\n\t\t\t\t\tconst inf1 = o1planes[tri2 + 0];\r\n\t\t\t\t\tconst inf2 = o1planes[tri2 + 1];\r\n\t\t\t\t\tif (i <= nl) {\r\n\t\t\t\t\tlmin = Math.min(inf1.p, inf2.p, lmin);\r\n\t\t\t\t\tlmax = Math.max(inf1.p, inf2.p, lmax);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (i >= nr) {\r\n\t\t\t\t\trmin = Math.min(inf1.p, inf2.p, rmin);\r\n\t\t\t\t\trmax = Math.max(inf1.p, inf2.p, rmax);\r\n\t\t\t\t\t}\r\n\t\t\t\t\t})\r\n\t\t\t\t\tldimo1 = Math.min(lmax - lmin, ldimo1);\r\n\t\t\t\t\trdimo1 = Math.min(rmax - rmin, rdimo1);\r\n\r\n\t\t\t\t\tplanes.forEach((p, i) => {\r\n\t\t\t\t\tconst tri2 = p.tri * 2;\r\n\t\t\t\t\tconst inf1 = o2planes[tri2 + 0];\r\n\t\t\t\t\tconst inf2 = o2planes[tri2 + 1];\r\n\t\t\t\t\tif (i <= nl) {\r\n\t\t\t\t\tlmin = Math.min(inf1.p, inf2.p, lmin);\r\n\t\t\t\t\tlmax = Math.max(inf1.p, inf2.p, lmax);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (i >= nr) {\r\n\t\t\t\t\trmin = Math.min(inf1.p, inf2.p, rmin);\r\n\t\t\t\t\trmax = Math.max(inf1.p, inf2.p, rmax);\r\n\t\t\t\t\t}\r\n\t\t\t\t\t})\r\n\t\t\t\t\tldimo2 = Math.min(lmax - lmin, ldimo2);\r\n\t\t\t\t\trdimo2 = Math.min(rmax - rmin, rdimo2);\r\n\t\t\t\t\t*/\r\n\r\n\t\t\t\t\t// surface areas and cost\r\n\t\t\t\t\tconst sal = 2 * ( ldimo1 * ldimo2 + ldimo1 * ldim + ldimo2 * ldim );\r\n\t\t\t\t\tconst sar = 2 * ( rdimo1 * rdimo2 + rdimo1 * rdim + rdimo2 * rdim );\r\n\t\t\t\t\tconst cost = getCost( sa, sal, nl, sar, nr );\r\n\r\n\t\t\t\t\tif ( cost < bestCost ) {\r\n\r\n\t\t\t\t\t\taxis = i;\r\n\t\t\t\t\t\tpos = pinfo.p;\r\n\t\t\t\t\t\tbestCost = cost;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn { axis, pos };\r\n\r\n\t}\r\n\r\n}\r\n","import * as THREE from 'three';\r\nimport MeshBVHNode from './MeshBVHNode.js';\r\nimport BVHConstructionContext from './BVHConstructionContext.js';\r\nimport { arrayToBox, boxToArray } from './Utils/ArrayBoxUtilities.js';\r\nimport { CENTER } from './Constants.js';\r\n\r\nexport default class MeshBVH {\r\n\r\n\tconstructor( geo, options = {} ) {\r\n\r\n\t\tif ( ! geo.isBufferGeometry ) {\r\n\r\n\t\t\tthrow new Error( 'MeshBVH: Only BufferGeometries are supported.' );\r\n\r\n\t\t} else if ( geo.attributes.position.isInterleavedBufferAttribute ) {\r\n\r\n\t\t\tthrow new Error( 'MeshBVH: InterleavedBufferAttribute is not supported for the position attribute.' );\r\n\r\n\t\t} else if ( geo.index && geo.index.isInterleavedBufferAttribute ) {\r\n\r\n\t\t\tthrow new Error( 'MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.' );\r\n\r\n\t\t}\r\n\r\n\t\t// default options\r\n\t\toptions = Object.assign( {\r\n\r\n\t\t\tstrategy: CENTER,\r\n\t\t\tmaxDepth: 40,\r\n\t\t\tmaxLeafTris: 10,\r\n\t\t\tverbose: true\r\n\r\n\t\t}, options );\r\n\t\toptions.strategy = Math.max( 0, Math.min( 2, options.strategy ) );\r\n\r\n\t\tthis._roots = this._buildTree( geo, options );\r\n\r\n\r\n\t}\r\n\r\n\t/* Private Functions */\r\n\r\n\t_ensureIndex( geo ) {\r\n\r\n\t\tif ( ! geo.index ) {\r\n\r\n\t\t\tconst vertexCount = geo.attributes.position.count;\r\n\t\t\tconst index = new ( vertexCount > 65535 ? Uint32Array : Uint16Array )( vertexCount );\r\n\t\t\tgeo.setIndex( new THREE.BufferAttribute( index, 1 ) );\r\n\r\n\t\t\tfor ( let i = 0; i < vertexCount; i ++ ) {\r\n\r\n\t\t\t\tindex[ i ] = i;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// Computes the set of { offset, count } ranges which need independent BVH roots. Each\r\n\t// region in the geometry index that belongs to a different set of material groups requires\r\n\t// a separate BVH root, so that triangles indices belonging to one group never get swapped\r\n\t// with triangle indices belongs to another group. For example, if the groups were like this:\r\n\t//\r\n\t// [-------------------------------------------------------------]\r\n\t// |__________________|\r\n\t//   g0 = [0, 20]  |______________________||_____________________|\r\n\t//                      g1 = [16, 40]           g2 = [41, 60]\r\n\t//\r\n\t// we would need four BVH roots: [0, 15], [16, 20], [21, 40], [41, 60].\r\n\t//\r\n\t_getRootIndexRanges( geo ) {\r\n\r\n\t\tif ( ! geo.groups || ! geo.groups.length ) {\r\n\r\n\t\t\treturn [ { offset: 0, count: geo.index.count / 3 } ];\r\n\r\n\t\t}\r\n\r\n\t\tconst ranges = [];\r\n\t\tconst rangeBoundaries = new Set();\r\n\t\tfor ( const group of geo.groups ) {\r\n\r\n\t\t\trangeBoundaries.add( group.start );\r\n\t\t\trangeBoundaries.add( group.start + group.count );\r\n\r\n\t\t}\r\n\r\n\t\t// note that if you don't pass in a comparator, it sorts them lexicographically as strings :-(\r\n\t\tconst sortedBoundaries = Array.from( rangeBoundaries.values() ).sort( ( a, b ) => a - b );\r\n\t\tfor ( let i = 0; i < sortedBoundaries.length - 1; i ++ ) {\r\n\r\n\t\t\tconst start = sortedBoundaries[ i ], end = sortedBoundaries[ i + 1 ];\r\n\t\t\tranges.push( { offset: ( start / 3 ), count: ( end - start ) / 3 } );\r\n\r\n\t\t}\r\n\t\treturn ranges;\r\n\r\n\t}\r\n\r\n\t_buildTree( geo, options ) {\r\n\r\n\t\tthis._ensureIndex( geo );\r\n\r\n\t\tconst ctx = new BVHConstructionContext( geo, options );\r\n\t\tlet reachedMaxDepth = false;\r\n\r\n\t\t// either recursively splits the given node, creating left and right subtrees for it, or makes it a leaf node,\r\n\t\t// recording the offset and count of its triangles and writing them into the reordered geometry index.\r\n\t\tconst splitNode = ( node, offset, count, depth = 0 ) => {\r\n\r\n\t\t\tif ( depth >= options.maxDepth ) {\r\n\r\n\t\t\t\treachedMaxDepth = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// early out if we've met our capacity\r\n\t\t\tif ( count <= options.maxLeafTris || depth >= options.maxDepth ) {\r\n\r\n\t\t\t\tnode.offset = offset;\r\n\t\t\t\tnode.count = count;\r\n\t\t\t\treturn node;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Find where to split the volume\r\n\t\t\tconst split = ctx.getOptimalSplit( node.boundingData, offset, count, options.strategy );\r\n\t\t\tif ( split.axis === - 1 ) {\r\n\r\n\t\t\t\tnode.offset = offset;\r\n\t\t\t\tnode.count = count;\r\n\t\t\t\treturn node;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst splitOffset = ctx.partition( offset, count, split );\r\n\r\n\t\t\t// create the two new child nodes\r\n\t\t\tif ( splitOffset === offset || splitOffset === offset + count ) {\r\n\r\n\t\t\t\tnode.offset = offset;\r\n\t\t\t\tnode.count = count;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tnode.splitAxis = split.axis;\r\n\r\n\t\t\t\t// create the left child and compute its bounding box\r\n\t\t\t\tconst left = node.left = new MeshBVHNode();\r\n\t\t\t\tconst lstart = offset, lcount = splitOffset - offset;\r\n\t\t\t\tleft.boundingData = ctx.getBounds( lstart, lcount, new Float32Array( 6 ) );\r\n\t\t\t\tsplitNode( left, lstart, lcount, depth + 1 );\r\n\r\n\t\t\t\t// repeat for right\r\n\t\t\t\tconst right = node.right = new MeshBVHNode();\r\n\t\t\t\tconst rstart = splitOffset, rcount = count - lcount;\r\n\t\t\t\tright.boundingData = ctx.getBounds( rstart, rcount, new Float32Array( 6 ) );\r\n\t\t\t\tsplitNode( right, rstart, rcount, depth + 1 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn node;\r\n\r\n\t\t};\r\n\r\n\t\tconst roots = [];\r\n\t\tconst ranges = this._getRootIndexRanges( geo );\r\n\r\n\t\tif ( ranges.length === 1 ) {\r\n\r\n\t\t\tconst root = new MeshBVHNode();\r\n\t\t\tconst range = ranges[ 0 ];\r\n\r\n\t\t\tif ( geo.boundingBox != null ) {\r\n\r\n\t\t\t\troot.boundingData = boxToArray( geo.boundingBox );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\troot.boundingData = ctx.getBounds( range.offset, range.count, new Float32Array( 6 ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tsplitNode( root, range.offset, range.count );\r\n\t\t\troots.push( root );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tfor ( let range of ranges ) {\r\n\r\n\t\t\t\tconst root = new MeshBVHNode();\r\n\t\t\t\troot.boundingData = ctx.getBounds( range.offset, range.count, new Float32Array( 6 ) );\r\n\t\t\t\tsplitNode( root, range.offset, range.count );\r\n\t\t\t\troots.push( root );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( reachedMaxDepth && options.verbose ) {\r\n\r\n\t\t\tconsole.warn( `MeshBVH: Max depth of ${ options.maxDepth } reached when generating BVH. Consider increasing maxDepth.` );\r\n\t\t\tconsole.warn( this, geo );\r\n\r\n\t\t}\r\n\r\n\t\t// if the geometry doesn't have a bounding box, then let's politely populate it using\r\n\t\t// the work we did to determine the BVH root bounds\r\n\r\n\t\tif ( geo.boundingBox == null ) {\r\n\r\n\t\t\tconst rootBox = new THREE.Box3();\r\n\t\t\tgeo.boundingBox = new THREE.Box3();\r\n\r\n\t\t\tfor ( let root of roots ) {\r\n\r\n\t\t\t\tgeo.boundingBox.union( arrayToBox( root.boundingData, rootBox ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn roots;\r\n\r\n\t}\r\n\r\n\traycast( mesh, raycaster, ray, intersects ) {\r\n\r\n\t\tfor ( const root of this._roots ) {\r\n\r\n\t\t\troot.raycast( mesh, raycaster, ray, intersects );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\traycastFirst( mesh, raycaster, ray ) {\r\n\r\n\t\tlet closestResult = null;\r\n\r\n\t\tfor ( const root of this._roots ) {\r\n\r\n\t\t\tconst result = root.raycastFirst( mesh, raycaster, ray );\r\n\t\t\tif ( result != null && ( closestResult == null || result.distance < closestResult.distance ) ) {\r\n\r\n\t\t\t\tclosestResult = result;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn closestResult;\r\n\r\n\t}\r\n\r\n\tintersectsGeometry( mesh, geometry, geomToMesh ) {\r\n\r\n\t\tfor ( const root of this._roots ) {\r\n\r\n\t\t\tif ( root.intersectsGeometry( mesh, geometry, geomToMesh ) ) return true;\r\n\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\r\n\t}\r\n\r\n\tshapecast( mesh, intersectsBoundsFunc, intersectsTriangleFunc = null, orderNodesFunc = null ) {\r\n\r\n\t\tfor ( const root of this._roots ) {\r\n\r\n\t\t\tif ( root.shapecast( mesh, intersectsBoundsFunc, intersectsTriangleFunc, orderNodesFunc ) ) return true;\r\n\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\r\n\t}\r\n\r\n\tintersectsBox( mesh, box, boxToMesh ) {\r\n\r\n\t\tfor ( const root of this._roots ) {\r\n\r\n\t\t\tif ( root.intersectsBox( mesh, box, boxToMesh ) ) return true;\r\n\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\r\n\t}\r\n\r\n\tintersectsSphere( mesh, sphere ) {\r\n\r\n\t\tfor ( const root of this._roots ) {\r\n\r\n\t\t\tif ( root.intersectsSphere( mesh, sphere ) ) return true;\r\n\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\r\n\t}\r\n\r\n\tclosestPointToGeometry( mesh, geom, matrix, target1, target2, minThreshold, maxThreshold ) {\r\n\r\n\t\tlet closestDistance = Infinity;\r\n\t\tfor ( const root of this._roots ) {\r\n\r\n\t\t\tconst dist = root.closestPointToGeometry( mesh, geom, matrix, target1, target2, minThreshold, maxThreshold );\r\n\t\t\tif ( dist < closestDistance ) closestDistance = dist;\r\n\t\t\tif ( dist < minThreshold ) return dist;\r\n\r\n\t\t}\r\n\r\n\t\treturn closestDistance;\r\n\r\n\t}\r\n\r\n\tdistanceToGeometry( mesh, geom, matrix, minThreshold, maxThreshold ) {\r\n\r\n\t\treturn this.closestPointToGeometry( mesh, geom, matrix, null, null, minThreshold, maxThreshold );\r\n\r\n\t}\r\n\r\n\tclosestPointToPoint( mesh, point, target, minThreshold, maxThreshold ) {\r\n\r\n\t\tlet closestDistance = Infinity;\r\n\t\tfor ( const root of this._roots ) {\r\n\r\n\t\t\tconst dist = root.closestPointToPoint( mesh, point, target, minThreshold, maxThreshold );\r\n\t\t\tif ( dist < closestDistance ) closestDistance = dist;\r\n\t\t\tif ( dist < minThreshold ) return dist;\r\n\r\n\t\t}\r\n\r\n\t\treturn closestDistance;\r\n\r\n\t}\r\n\r\n\tdistanceToPoint( mesh, point, minThreshold, maxThreshold ) {\r\n\r\n\t\treturn this.closestPointToPoint( mesh, point, null, minThreshold, maxThreshold );\r\n\r\n\t}\r\n\r\n}\r\n","import * as THREE from 'three';\r\nimport { arrayToBox } from './Utils/ArrayBoxUtilities.js';\r\n\r\nconst wiremat = new THREE.LineBasicMaterial( { color: 0x00FF88, transparent: true, opacity: 0.3 } );\r\nconst boxGeom = new THREE.Box3Helper().geometry;\r\nlet boundingBox = new THREE.Box3();\r\n\r\nclass MeshBVHRootVisualizer extends THREE.Object3D {\r\n\r\n\tconstructor( mesh, depth = 10, group = 0 ) {\r\n\r\n\t\tsuper( 'MeshBVHRootVisualizer' );\r\n\r\n\t\tthis.depth = depth;\r\n\t\tthis._oldDepth = - 1;\r\n\t\tthis._mesh = mesh;\r\n\t\tthis._boundsTree = null;\r\n\t\tthis._group = group;\r\n\r\n\t\tthis.update();\r\n\r\n\t}\r\n\r\n\tupdate() {\r\n\r\n\t\tif ( this._mesh.geometry.boundsTree !== this._boundsTree || this._oldDepth !== this.depth ) {\r\n\r\n\t\t\tthis._oldDepth = this.depth;\r\n\t\t\tthis._boundsTree = this._mesh.geometry.boundsTree;\r\n\r\n\t\t\tlet requiredChildren = 0;\r\n\t\t\tif ( this._boundsTree ) {\r\n\r\n\t\t\t\tconst recurse = ( n, d ) => {\r\n\r\n\t\t\t\t\tlet isLeaf = 'count' in n;\r\n\r\n\t\t\t\t\tif ( d === this.depth ) return;\r\n\r\n\t\t\t\t\tif ( d === this.depth - 1 || isLeaf ) {\r\n\r\n\t\t\t\t\t\tlet m = requiredChildren < this.children.length ? this.children[ requiredChildren ] : null;\r\n\t\t\t\t\t\tif ( ! m ) {\r\n\r\n\t\t\t\t\t\t\tm = new THREE.LineSegments( boxGeom, wiremat );\r\n\t\t\t\t\t\t\tm.raycast = () => [];\r\n\t\t\t\t\t\t\tthis.add( m );\r\n\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\trequiredChildren ++;\r\n\t\t\t\t\t\tarrayToBox( n.boundingData, boundingBox );\r\n\t\t\t\t\t\tboundingBox.getCenter( m.position );\r\n\t\t\t\t\t\tm.scale.subVectors( boundingBox.max, boundingBox.min ).multiplyScalar( 0.5 );\r\n\r\n\t\t\t\t\t\tif ( m.scale.x === 0 ) m.scale.x = Number.EPSILON;\r\n\t\t\t\t\t\tif ( m.scale.y === 0 ) m.scale.y = Number.EPSILON;\r\n\t\t\t\t\t\tif ( m.scale.z === 0 ) m.scale.z = Number.EPSILON;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( ! isLeaf ) {\r\n\r\n\t\t\t\t\t\trecurse( n.left, d + 1 );\r\n\t\t\t\t\t\trecurse( n.right, d + 1 );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t};\r\n\r\n\t\t\t\trecurse( this._boundsTree._roots[ this._group ], 0 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\twhile ( this.children.length > requiredChildren ) this.remove( this.children.pop() );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\nclass MeshBVHVisualizer extends THREE.Object3D {\r\n\r\n\tconstructor( mesh, depth = 10 ) {\r\n\r\n\t\tsuper( 'MeshBVHVisualizer' );\r\n\r\n\t\tthis.depth = depth;\r\n\t\tthis._mesh = mesh;\r\n\t\tthis._roots = [];\r\n\r\n\t\tthis.update();\r\n\r\n\t}\r\n\r\n\tupdate() {\r\n\r\n\t\tconst bvh = this._mesh.geometry.boundsTree;\r\n\t\tconst totalRoots = bvh ? bvh._roots.length : 0;\r\n\t\twhile ( this._roots.length > totalRoots ) {\r\n\r\n\t\t\tthis._roots.pop();\r\n\r\n\t\t}\r\n\r\n\t\tfor ( let i = 0; i < totalRoots; i ++ ) {\r\n\r\n\t\t\tif ( i >= this._roots.length ) {\r\n\r\n\t\t\t\tconst root = new MeshBVHRootVisualizer( this._mesh, this.depth, i );\r\n\t\t\t\tthis.add( root );\r\n\t\t\t\tthis._roots.push( root );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tlet root = this._roots[ i ];\r\n\t\t\t\troot.depth = this.depth;\r\n\t\t\t\troot.update();\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tthis.position.copy( this._mesh.position );\r\n\t\tthis.rotation.copy( this._mesh.rotation );\r\n\t\tthis.scale.copy( this._mesh.scale );\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\nexport default MeshBVHVisualizer;\r\n","import * as THREE from 'three';\r\nimport MeshBVH from './MeshBVH.js';\r\nimport Visualizer from './MeshBVHVisualizer.js';\r\nimport { CENTER, AVERAGE, SAH } from './Constants.js';\r\n\r\nconst ray = new THREE.Ray();\r\nconst tmpInverseMatrix = new THREE.Matrix4();\r\nconst origMeshRaycastFunc = THREE.Mesh.prototype.raycast;\r\n\r\nfunction acceleratedRaycast( raycaster, intersects ) {\r\n\r\n\tif ( this.geometry.boundsTree ) {\r\n\r\n\t\tif ( this.material === undefined ) return;\r\n\r\n\t\ttmpInverseMatrix.getInverse( this.matrixWorld );\r\n\t\tray.copy( raycaster.ray ).applyMatrix4( tmpInverseMatrix );\r\n\r\n\t\tif ( raycaster.firstHitOnly === true ) {\r\n\r\n\t\t\tconst res = this.geometry.boundsTree.raycastFirst( this, raycaster, ray );\r\n\t\t\tif ( res ) intersects.push( res );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.geometry.boundsTree.raycast( this, raycaster, ray, intersects );\r\n\r\n\t\t}\r\n\r\n\t} else {\r\n\r\n\t\torigMeshRaycastFunc.call( this, raycaster, intersects );\r\n\r\n\t}\r\n\r\n}\r\n\r\nfunction computeBoundsTree( options ) {\r\n\r\n\tthis.boundsTree = new MeshBVH( this, options );\r\n\treturn this.boundsTree;\r\n\r\n}\r\n\r\nfunction disposeBoundsTree() {\r\n\r\n\tthis.boundsTree = null;\r\n\r\n}\r\n\r\nexport {\r\n\tMeshBVH, Visualizer,\r\n\tacceleratedRaycast, computeBoundsTree, disposeBoundsTree,\r\n\tCENTER, AVERAGE, SAH\r\n};\r\n","import * as THREE from 'three'\nimport {Layout} from './layout/Layout'\nimport {Transitioner} from './layout/Transitioner'\n\n// accelerated raycasting\nimport { computeBoundsTree, disposeBoundsTree, acceleratedRaycast } from 'three-mesh-bvh'\nTHREE.BufferGeometry.prototype.computeBoundsTree = computeBoundsTree\nTHREE.BufferGeometry.prototype.disposeBoundsTree = disposeBoundsTree\nTHREE.Mesh.prototype.raycast = acceleratedRaycast\ndeclare module 'three/src/core/BufferGeometry' {\n    interface BufferGeometry {\n        computeBoundsTree() : void\n        disposeBoundsTree() : void\n        boundsTree?: any\n    }\n}\n\ndeclare module 'three/src/core/Object3D' {\n    interface Object3D {\n        /**\n         * Layout properties\n         */\n        layout: Layout\n        /**\n         * When active, enables pose (position, quaternion, scale) \n         * and layout (align, origin, size) properties to be used \n         * as transition targets for smooth interpolation.\n         */\n        transitioner: Transitioner\n        updateWorldMatrix(updateParents:boolean, updateChildren:boolean, updateLayout?:boolean) : void\n    }\n}\n\nlet _s = new THREE.Vector3\nTHREE.Object3D.prototype.updateMatrix = function(this:THREE.Object3D) {\n    const {position, quaternion, scale} = this\n    _s.copy(scale) // allow scale of 0 by making it very small\n    if (_s.x === 0) _s.x = 1e-10\n    if (_s.y === 0) _s.y = 1e-10\n    if (_s.z === 0) _s.z = 1e-10\n    this.matrix.compose(position, quaternion, scale)\n}\n\n// modify updateMatrixWorld to rely on updateWorldMatrix method\nTHREE.Object3D.prototype.updateMatrixWorld = function(force) {\n    if (this._inUpdateWorldMatrix) return\n    this.updateWorldMatrix(false, true, true)\n}\n\n// modify Object3D.updateWorldMatrix to apply layout\nTHREE.Object3D.prototype.updateWorldMatrix = function(this:THREE.Object3D, updateParents:boolean, updateChildren:boolean, updateLayout=true) {\n\n    const parent = this.parent\n\n    // update parents\n\n    if ( updateParents === true && parent !== null ) {\n\n        parent.updateWorldMatrix( true, false, true )\n\n    }\n\n    // update without layout\n\n    if ( this.matrixAutoUpdate ) this.updateMatrix()\n\n    if ( this.parent === null ) {\n\n        this.matrixWorld.copy( this.matrix )\n\n    } else {\n\n        this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix )\n\n    }\n\n    // update children without layout\n\n    const children = this.children;\n\n    if ( updateChildren === true ) {\n\n        for ( var i = 0, l = children.length; i < l; i ++ ) {\n\n            children[ i ].updateWorldMatrix( false, true, false )\n\n        }\n    }\n\n    // update and apply layout\n\n    if ( updateLayout === true ) {\n\n        updateChildren && this.layout.invalidateBounds() // only invalidate when traversing down\n        this.layout.updateMatrix()\n        const layoutMatrix = this.layout.matrix\n        const transitioner = this.transitioner as Transitioner\n        // const {matrixTarget, layoutMatrixTarget} = transitioner\n        \n        transitioner.matrixLocal.target.multiplyMatrices( this.layout.matrix, this.matrix )\n        const matrixLocal = transitioner.active ? transitioner.matrixLocal.current : transitioner.matrixLocal.target\n\n        if ( parent === null ) {\n            transitioner.matrixWorldTarget.copy(transitioner.matrixLocal.target)\n            this.matrixWorld.copy(matrixLocal)\n            // this.matrixWorld.multiplyMatrices( layoutMatrix, this.matrix )\n            // transitioner.targetMatrixWorld.multiplyMatrices( layoutMatrixTarget, matrixTarget )\n            \n        } else {\n\n            transitioner.matrixWorldTarget.multiplyMatrices( parent.transitioner.matrixWorldTarget, transitioner.matrixLocal.target)\n            this.matrixWorld.multiplyMatrices( parent.matrixWorld, matrixLocal )\n            // this.matrixWorld.multiplyMatrices( parent.matrixWorld, layoutMatrix ).multiply(this.matrix)\n            // transitioner.targetMatrixWorld.multiplyMatrices( parent.transitioner.targetMatrixWorld, layoutMatrixTarget).multiply( matrixTarget )\n\n        }\n\n        // update children with layout\n\n        if ( updateChildren === true ) {\n\n            for ( var i = 0, l = children.length; i < l; i ++ ) {\n\n                children[ i ].updateWorldMatrix( false, true, true );\n        \n            }\n\n        }\n\n    }\n    \n    this['_inUpdateWorldMatrix'] = true\n    this.updateMatrixWorld() // some three.js Object3D subclasses have special behavior here\n    this['_inUpdateWorldMatrix'] = false\n\n}\n\n// create a SpatialLayout instance on first access of the `layout` property \nObject.defineProperty(THREE.Object3D.prototype, 'layout', {\n    get: function getLayout(this:THREE.Object3D) {\n        if (this === THREE.Object3D.prototype) return undefined\n        Object.defineProperty(this, 'layout', {\n            value: new Layout(this),\n            writable: true,\n            enumerable: true\n        })\n        return this.layout\n    }\n})\n\n// create a SpatialTransitioner instance on first access of the `transitioner` property \nObject.defineProperty(THREE.Object3D.prototype, 'transitioner', {\n    get: function getTransitioner(this:THREE.Object3D) {\n        if (this === THREE.Object3D.prototype) return undefined\n        Object.defineProperty(this, 'transitioner', {\n            value: new Transitioner(this),\n            writable: true,\n            enumerable: true\n        })\n        return this.transitioner\n    }\n})","import * as THREE from 'three'\nimport { Box3Helper } from 'three'\n\nexport class LayoutHelper extends THREE.Object3D {\n\n    private _transitional = new THREE.Object3D \n    private _transitionalBoxHelper = new Box3Helper(this._transitional.layout.inner)\n    private _target = new THREE.Object3D \n    private _targetBoxHelper = new Box3Helper(this._target.layout.inner)\n\n    constructor() {\n        super()\n        this.add(this._transitional)\n        this._transitional.layout.innerAutoUpdate = false\n        this._transitional.layout.forceBoundsExclusion = true\n        this._transitional.add(this._transitionalBoxHelper)\n        this._transitionalBoxHelper.layout.forceBoundsExclusion = true\n        this.add(this._target)\n        this._target.layout.innerAutoUpdate = false\n        this._target.layout.forceBoundsExclusion = true\n        this._target.add(this._targetBoxHelper)\n        this._targetBoxHelper.layout.forceBoundsExclusion = true\n        ;(this._targetBoxHelper.material as THREE.LineBasicMaterial).color.setStyle('magenta')\n    }\n\n    updateWorldMatrix(parents:boolean, children:boolean, layout?:boolean) {\n        super.updateWorldMatrix(parents, children, layout)\n        if (this.parent) {\n            this._target.layout.inner.copy(this.parent.layout.computedInnerBounds)\n            this._target.matrixWorld.copy(this.parent.transitioner.matrixWorldTarget)\n            this._targetBoxHelper.updateMatrixWorld()\n            this._transitional.layout.inner.copy(this.parent.layout.computedInnerBounds)\n            this._transitional.updateMatrixWorld()\n        }\n    }\n\n}","export abstract class Behavior {\n    object:THREE.Object3D\n    init?(this:Behavior)\n    update?(this:Behavior, deltaTime:number)\n    postUpdate?(this:Behavior, deltaTime:number)\n}","import { Behavior } from './Behavior'\nimport { SpatialMetrics } from '../metrics/SpatialMetrics'\nimport { Transitioner } from '../layout/Transitioner'\n\ntype FunctionPropertyNames<T> = { [K in keyof T]: T[K] extends Function ? K : never }[keyof T]\ntype FunctionProperties<T> = Pick<T, FunctionPropertyNames<Required<T>>>\n\n/**\n * When many objects in a scene-graph have behaviors that adapt to the\n * behavior of other objects, it is crucial that these chains of adaptive \n * behavior update in a way that minimizes unecessary scene-graph calculations \n * while also not adapting in the wrong order (which would cause some behaviors\n * to be permanently lagging behind one or more frames as they adapt to stale state). \n * \n * This class supports efficient execution of adaptive behaviors\n * in an optimal order such that all behaviors are adapting to fresh state \n * with minimal traversal of the scene-graph. \n */\nexport class AdaptivityManager {\n\n    private static _getBehaviors = Symbol('getBehaviors')\n\n    private static _didUpdate = Symbol('didUpdate')\n\n    static addBehavior(object:THREE.Object3D, behavior:FunctionProperties<Behavior>|NonNullable<typeof Behavior.prototype.update>) {\n        const behaviors = object[AdaptivityManager._getBehaviors] = object[AdaptivityManager._getBehaviors] || []\n        let b:Behavior\n        if (typeof behavior === 'function') b = {object, update:behavior} \n        else b = <Behavior>behavior\n        b.object = object\n        b.init && b.init()\n        behaviors.push(b)\n    }\n\n    static getBehaviors(object:THREE.Object3D) {\n        return object[AdaptivityManager._getBehaviors] as Behavior[]\n    }\n    \n    static currentScene:THREE.Scene\n    static currentCamera:THREE.Camera\n    static currentDeltaTime:number\n\n    static update(scene:THREE.Scene, camera:THREE.Camera, deltaTime:number) {\n        AdaptivityManager.currentScene = scene\n        AdaptivityManager.currentCamera = camera\n        AdaptivityManager.currentDeltaTime = deltaTime\n        scene.updateWorldMatrix(true, true)\n        AdaptivityManager.ensureUpdate(camera)\n        scene.traverse(AdaptivityManager.ensureUpdate)\n        AdaptivityManager.currentScene = undefined as any\n        AdaptivityManager.currentCamera = undefined as any\n        AdaptivityManager.currentDeltaTime = undefined as any\n        Promise.resolve(scene).then(AdaptivityManager.clearUpdateFlag)\n    }\n\n    static clearUpdateFlag(scene:THREE.Scene) {\n        scene.traverse((obj) => obj[AdaptivityManager._didUpdate] = false)\n    }\n\n    static ensureUpdate(obj:THREE.Object3D) {\n        if (!AdaptivityManager.currentScene) throw new Error('AdaptivityManager.ensureUpdate: must be called inside a Behavior callback')\n        if (obj[AdaptivityManager._didUpdate]) return\n        obj[AdaptivityManager._didUpdate] = true\n        obj.parent && AdaptivityManager.ensureUpdate(obj.parent)\n        const behaviors = AdaptivityManager.getBehaviors(obj)\n        Transitioner.disableAllTransitions = true\n        if (behaviors) for (const b of behaviors) {\n            if (b.update) {\n                b.update(AdaptivityManager.currentDeltaTime!)\n                obj.updateWorldMatrix(false, true)\n            }\n        }\n        Transitioner.disableAllTransitions = false\n        obj.transitioner.update(AdaptivityManager.currentDeltaTime!, false)\n        if (behaviors) for (const b of behaviors) {\n            if (b.postUpdate) {\n                b.postUpdate(AdaptivityManager.currentDeltaTime!)\n                obj.updateWorldMatrix(false, true)\n            }\n        }\n    }\n}","import * as THREE from 'three'\nimport { Behavior } from './Behavior'\nimport { SpatialMetrics, Box3 } from '../metrics/SpatialMetrics'\nimport { vectors } from '../utils'\nimport { AdaptivityManager } from './AdaptivityManager'\nimport { Transitionable } from '../layout/Transitioner'\n\n// TODO: take occluder velocity into account, ignore fast moving occluders\n// TODO: clip change threshold to minimize small corrections\n\nexport class AdaptiveClippingBehavior extends Behavior {\n\n    private _boxA = new Box3\n    private _boxB = new Box3\n\n    occluders = [] as THREE.Object3D[]\n\n    occluderInfluenceDelay = 0.5\n\n    occlusionTime = new WeakMap<THREE.Object3D, number>()\n\n    update(deltaTime:number) {\n        const camera = AdaptivityManager.currentCamera\n        const cameraMetrics = SpatialMetrics.get(camera)\n\n        const object = this.object\n        object.layout.clip.makeEmpty()\n        object.updateWorldMatrix(true, true)\n        const objectMetrics = SpatialMetrics.get(object)\n        const objectDistance = cameraMetrics.getDistanceOf(object)\n        const objectBounds = this._boxA.copy(object.layout.computedInnerBounds)\n        objectBounds.min.z = -Infinity\n        objectBounds.max.z = Infinity\n\n        const clip = object.layout.clip\n        // const clip = this.clipTarget.target.makeEmpty()\n\n        // for each occluder, need to crop the layout by at most \n        // a single cut that minimizes the lost space \n        for (let i = 0; i < this.occluders.length; i++) {\n            const occluder = this.occluders[i]\n\n            // todo: add priority rule to allow adaptation to background (rather than foreground) objects\n            const occluderDistance = cameraMetrics.getDistanceOf(occluder)\n            if (occluderDistance > objectDistance) {\n                this.occlusionTime.set(occluder, 0)\n                continue\n            }\n\n            // make sure potential occluder behaviors have already executed\n            AdaptivityManager.ensureUpdate(occluder)\n\n            const occluderBounds = objectMetrics.getBoundsOf(occluder, this._boxB)\n            occluderBounds.min.z = -Infinity\n            occluderBounds.max.z = Infinity\n\n            if (!objectBounds.intersectsBox(occluderBounds)) {\n                this.occlusionTime.set(occluder, 0)\n                continue\n            }\n\n            let occlusionTime = (this.occlusionTime.get(occluder) || 0) + deltaTime\n            this.occlusionTime.set(occluder, occlusionTime)\n\n            if (occlusionTime < this.occluderInfluenceDelay) {\n                continue\n            }\n\n            const occluderCenter = occluderBounds.getCenter(vectors.get())\n            if (occluderCenter.x > 0) clip.max.x = isFinite(clip.max.x) ? Math.min(occluderBounds.min.x, clip.max.x) : occluderBounds.min.x\n            if (occluderCenter.x < 0) clip.min.x = isFinite(clip.min.x) ? Math.max(occluderBounds.max.x, clip.min.x) : occluderBounds.max.x\n            if (occluderCenter.y > 0) clip.max.y = isFinite(clip.max.y) ? Math.min(occluderBounds.min.y, clip.max.y) : occluderBounds.min.y\n            if (occluderCenter.y < 0) clip.min.y = isFinite(clip.min.y) ? Math.max(occluderBounds.max.y, clip.min.y) : occluderBounds.max.y\n        }\n    }\n\n    postUpdate() {\n        // this.object.layout.clip.copy(this.clipTarget.current)\n        // this.object.updateWorldMatrix(true, true)\n    }\n}"],"names":["V_00","Object","freeze","THREE","V_11","V_000","V_100","V_010","V_001","V_111","Q_IDENTITY","next","Promise","resolve","Pool","constructor","_factory","_reset","Set","_nextAutoPool","undefined","_poolAll","get","object","this","_pool","pop","_unpooled","add","then","_autoPool","pool","o","push","delete","size","vectors2","vec","set","vectors","vectors4","quaternions","quat","matrices3","mat","identity","matrices","traverse","each","bind","call","children","line3","plane","closestPoint","triangle","Visible","v1","QuickHull","tolerance","faces","newFaces","assigned","VertexList","unassigned","vertices","Face","normal","midpoint","area","constant","outside","mark","edge","HalfEdge","vertex","face","prev","twin","VertexNode","point","head","tail","assign","prototype","setFromPoints","points","Array","isArray","console","error","length","makeEmpty","i","l","compute","setFromObject","updateMatrixWorld","node","geometry","isGeometry","clone","applyMatrix4","matrixWorld","isBufferGeometry","attribute","attributes","position","count","fromBufferAttribute","containsPoint","distanceToPoint","intersectRay","ray","target","tNear","Infinity","tFar","vN","origin","vD","dot","direction","t","Math","min","max","at","intersectsRay","addVertexToFace","append","insertBefore","removeVertexFromFace","remove","removeAllVerticesFromFace","start","end","removeSubList","deleteFaceVertices","absorbingFace","faceVertices","appendChain","nextVertex","resolveUnassignedPoints","isEmpty","first","maxDistance","maxFace","distance","computeExtremes","j","minVertices","maxVertices","copy","getComponent","setComponent","Number","EPSILON","abs","x","y","z","computeInitialHull","v0","v2","v3","extremes","index","closestPointToPoint","distanceToSquared","setFromCoplanarPoints","create","getEdge","setTwin","reindexFaces","activeFaces","nextVertexToAdd","eyeVertex","eyeFace","computeHorizon","eyePoint","crossEdge","horizon","twinEdge","oppositeFace","addAdjoiningFace","horizonEdge","addNewFaces","firstSideEdge","previousSideEdge","sideEdge","addVertexToHull","clear","cleanup","a","b","c","e0","e1","e2","getNormal","getMidpoint","getArea","distanceTo","lengthSquared","last","insertAfter","ConvexGeometry","fromBufferGeometry","ConvexBufferGeometry","mergeVertices","normals","addAttribute","SimplifyModifier","cb","ab","removeFromArray","array","k","indexOf","splice","computeEdgeCollapseCost","u","v","edgelength","curvature","sideFaces","il","hasVertex","minCurvature","dotProd","computeEdgeCostAtVertex","neighbors","collapseNeighbor","collapseCost","minCost","totalCost","costCount","removeVertex","assert","removeFace","f","vs","removeIfNonNeighbor","collapse","tmpVertices","replaceVertex","minimumCostEdge","least","Triangle","computeNormal","addUniqueNeighbor","Vertex","id","vA","vB","subVectors","cross","normalize","oldv","newv","n","offset","modify","oldVertices","oldFaces","log","simplifiedGeometry","setIndex","SimplifiedHull","maxPoints","bufferGeometry","type","normalGeometry","hulls","modifier","hull","simplified","WeakMap","Box3","SpatialMetrics","objectFilter","_onObjectTraverse","_objectExpandFunction","objectExpansion","expandByObjectGeometry","expandByObjectHull","expandByObjectBox","vector","_vector","mesh","updateWorldMatrix","_getCoordinateSystemTransform","expandByPoint","getAttribute","itemSize","getX","getY","getZ","box","_box","boundingBox","computeBoundingBox","union","mat4","_mat4","coordinateSystem","getInverse","transitioner","matrixWorldTarget","multiply","relativeToAbsolute","relativePosition","out","multiplyScalar","center","_center","_size","getCenter","getSize","absoluteToRelative","absolutePosition","sub","divide","isFinite","rotateY180","setFromAxisAngle","PI","VisualFrustum","prototypeAccessors","left","leftClamped","minClamped","top","topClamped","maxClamped","right","rightClamped","bottom","bottomClamped","near","nearClamped","far","farClamped","horizontal","horizontalClamped","vertical","verticalClamped","depth","depthClamped","diagonal","minDirection","getCartesianForSphericalDirection","maxDirection","angleTo","RAD2DEG","diagonalClamped","getClampedCenter","getClampedSize","getPositionForOffset","getClampedPositionForOffset","setFromPerspectiveProjectionMatrix","projectionMatrix","inverseProjection","_applyClamping","m","isMesh","vertexPosition","_vec3","localToReferenceFrame","metrics","vertexVisualPosition","getVisualPositionForCartesianPosition","_boxPoints","const","p","minClamp","maxClamp","_metrics","has","sphericalDirection","visualElevationRadians","DEG2RAD","visualAzimuthRadians","sin","cos","getSphericalDirectionForCartesian","cartesian","asin","atan2","getSphericalPositionForCartesian","getCartesianForSphericalPosition","sphericalPosition","visualDirection","getMatrixWorld","matrixWorldGetter","getCartesianForVisualDirection","isCamera","applyQuaternion","getVisualDirectionForCartesian","cartesianPosition","getCartesianForVisualPosition","visualPosition","getPositionOf","setFromMatrixPosition","invMatrixWorld","getDistanceOf","result","getDirectionOf","lengthSq","getWorldDirectionOf","transformDirection","getClosestOrthogonalOrientationOf","closestForwardDirection","closestUpDirection","viewToObjectMat","extractRotation","orientation","setFromRotationMatrix","forwardDirection","upDirection","distForward","distUp","directions","dir","dist","lookAt","getOrientationOf","rotMat","targetWorldOrientation","inverseThisWorldOrientation","inverse","multiplyQuaternions","getVisualDirectionOf","getVisualAngleOf","getBoundsOf","getVisualFrustumOf","_visualFrustum","getVisualOffsetOf","layout","isBoundingContext","Layout","computedInnerBounds","fit","_fit","fitTargets","invalidateBounds","_boundsValid","resetLayout","absolute","relative","resetPose","setScalar","quaternion","scale","reset","isPassive","forceBoundsExclusion","updateMatrix","bounds","computedBounds","matrix","updateInnerBounds","updateOuterBounds","computedOuterBounds","clip","clipMax","clipMin","minSize","minRelativeSize","minAbsoluteSize","innerSize","layoutScale","adjustScaleForFit","finalSize","multiplyVectors","orient","makeRotationFromQuaternion","halfFinalSize","divideScalar","layoutAlignOffset","fitAlign","innerAlignOffset","layoutPosition","compose","inner","parentBounds","parent","cameraParent","projectionMatrixInverse","projectionZ","sizeScale","fitScale","_fitScale","clamp","ax","ay","az","fill","lerp","contain","contain3d","cover","cover3d","reversed","easing","mirrored","createReversedEasing","createMirroredEasing","createExpoIn","power","pow","createBackIn","createAnticipateEasing","backEasing","easeIn","easeOut","easeInOut","circIn","acos","circOut","circInOut","backIn","bounceOut","p2","FLOAT_32_SUPPORTED","Float32Array","a1","a2","getSlope","calcBezier","mX1","mY1","mX2","mY2","sampleValues","calcSampleValues","aX","guessForT","initialSlope","intervalStart","currentSample","K_SPLINE_TABLE_SIZE","aGuessT","currentSlope","newtonRaphsonIterate","aA","aB","currentX","currentT","binarySubdivide","getTForX","defined","obj","Transitionable","config","current","update","deltaTime","changePercent","_updateConfig","queue","targetQueue","_changePercent","_computePercentChange","multiplier","threshold","_delayTime","delay","committedTarget","_debounceTime","_waitTime","debounce","maxWait","value","duration","elapsed","shift","_setCurrent","previousTarget","_addTargetInfluence","alpha","s","e","pos","decompose","sPos","sQuat","sScale","tPos","tQuat","tScale","slerp","amount","_c","_cBlack","minAmount","maxAmount","range","ePos","eQuat","eScale","posPercent","equals","quatPercent","scalePercent","percent","r","g","minPercent","maxPercent","_config","Transitioner","DEFAULT_CONFIG","LocalMatrixTransitionable","autoRange","synchronizeComponents","matrixLocal","active","_active","disableAllTransitions","transitionable","customTransitionables","autoActive","_setParent","parentTarget","originalMatrixWorld","inverseParentMatrixWorld","Vector3","vC","uvA","Vector2","uvB","uvC","intersectionPoint","intersectionPointWorld","intersectTri","geo","raycaster","tri","intersections","triOffset","intersection","uv","material","pA","pB","pC","side","BackSide","intersectTriangle","DoubleSide","checkIntersection","getUV","Face3","faceIndex","checkBufferGeometryIntersection","arrayToBox","arr","getLongestEdgeIndex","splitDimIdx","splitDist","SeparatingAxisBounds","[object Object]","field","val","axis","other","setFromBox","boxMin","boxMax","closestPointLineToLine","dir1","dir2","v02","l1","l2","v10","v32","d0232","d3210","d3232","d0210","denom","d","d2","closestPointsSegmentToSegment","paramResult","temp1","temp2","target1","target2","closestPoint2","sphereIntersectTriangle","closestPointTemp","projectedPointTemp","planeTemp","Plane","lineTemp","Line3","sphere","radius","getPlane","pp","projectPoint","SeparatingAxisTriangle","args","super","isSeparatingAxisTriangle","satAxes","map","satBounds","Sphere","axis0","sab0","axis1","sab1","axis2","sab2","axis3","sab3","intersectsTriangle","saTri2","arr1","arr2","cachedSatBounds","cachedSatBounds2","cachedAxis","satBounds1","satAxes1","sb","isSeparated","satBounds2","satAxes2","sa1","i2","crossVectors","distanceToTriangle","point2","cornerFields","line1","line2","closestDistanceSq","otherVec","thisVec","sqrt","OrientedBox","isOrientedBox","Matrix4","invMatrix","alignedSatBounds","minVec","setFromPointsField","intersectsBox","aabbBounds","intersectsSphere","saTri","pointsArr","triSatBounds","triSatAxes","distanceToBox","xyzFields","segments1","segments2","point1","threshold2","i1","nextIndex","nextIndex2","f1","f2","f3","THREE.Box3","boxIntersection","THREE.Vector3","setTriangle","ta","tb","tc","i3","MeshBVHNode","boundingData","intersectBox","intersects","intersectTris","raycast","res","intersectClosestTri","splitAxis","xyzAxis","c1","c2","c1Result","raycastFirst","rayOrig","toPoint","toChild1","toChild2","toPointSq","c2Result","shapecast","cachedBox1","cachedBox2","intersectsBoundsFunc","intersectsTriangleFunc","nodeScoreFunc","score1","score2","box1","box2","temp","tempBox","intersectsGeometry","triangle2","cachedMesh","THREE.Mesh","invertedMat","THREE.Matrix4","obb","obb2","geometryToBvh","cachedObb","thisGeometry","thisIndex","thisPos","boundsTree","boxToBvh","minThreshold","maxThreshold","closestDistance","isLeaf","score","closestPointToGeometry","tri2","tempTarget1","tempTarget2","sphere1","sphere2","CENTER","AVERAGE","SAH","boxtemp","BVHConstructionContext","options","verts","triCount","ai","bi","ci","el","halfExtents","computeBounds","sahplanes","strategy","avg","minx","miny","minz","maxx","maxy","maxz","cx","hx","cy","hy","cz","hz","split","axisOffset","t0","t1","t2","getAverage","TRAVERSAL_COST","INTERSECTION_COST","bb","dim","sa","filteredLists","forEach","planes","sort","getCost","sal","nl","sar","nr","bestCost","o1","o2","bmin","bmax","pinfo","ldim","rdim","ldimo1","rdimo1","ldimo2","rdimo2","cost","MeshBVH","Error","isInterleavedBufferAttribute","maxDepth","maxLeafTris","verbose","_roots","_buildTree","vertexCount","Uint32Array","Uint16Array","THREE.BufferAttribute","groups","ranges","rangeBoundaries","group","sortedBoundaries","from","values","_ensureIndex","ctx","reachedMaxDepth","splitNode","getOptimalSplit","splitOffset","partition","lstart","lcount","getBounds","rstart","rcount","roots","_getRootIndexRanges","root","bx","boxToArray","warn","rootBox","closestResult","geomToMesh","orderNodesFunc","boxToMesh","geom","THREE.LineBasicMaterial","color","transparent","opacity","THREE.Box3Helper","THREE.Ray","tmpInverseMatrix","origMeshRaycastFunc","computeBoundsTree","disposeBoundsTree","firstHitOnly","let","_s","force","_inUpdateWorldMatrix","updateParents","updateChildren","updateLayout","matrixAutoUpdate","multiplyMatrices","defineProperty","writable","enumerable","LayoutHelper","Box3Helper","_transitional","_target","innerAutoUpdate","_transitionalBoxHelper","_targetBoxHelper","setStyle","parents","Behavior","AdaptivityManager","addBehavior","behavior","behaviors","_getBehaviors","init","getBehaviors","scene","camera","currentScene","currentCamera","currentDeltaTime","ensureUpdate","clearUpdateFlag","_didUpdate","postUpdate","Symbol","AdaptiveClippingBehavior","cameraMetrics","objectMetrics","objectDistance","objectBounds","_boxA","occluders","occluder","occlusionTime","occluderBounds","_boxB","occluderInfluenceDelay","occluderCenter","fill3d"],"mappings":"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"}