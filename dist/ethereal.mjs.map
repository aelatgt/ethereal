{"version":3,"file":"ethereal.mjs","sources":["../src/utils.ts","../src/metrics/QuickHull.js","../src/metrics/ConvexGeometry.ts","../src/metrics/SimplifyModifier.js","../src/metrics/SpatialMetrics.ts","../src/layout/Layout.ts","../node_modules/@popmotion/easing/dist/easing.es.js","../src/layout/Transitioner.ts","../node_modules/three-mesh-bvh/src/Utils/ThreeIntersectionUtilities.js","../node_modules/three-mesh-bvh/src/Utils/ArrayBoxUtilities.js","../node_modules/three-mesh-bvh/src/Utils/SeparatingAxisBounds.js","../node_modules/three-mesh-bvh/src/Utils/MathUtilities.js","../node_modules/three-mesh-bvh/src/Utils/SeparatingAxisTriangle.js","../node_modules/three-mesh-bvh/src/Utils/OrientedBox.js","../node_modules/three-mesh-bvh/src/MeshBVHNode.js","../node_modules/three-mesh-bvh/src/Utils/RayIntersectTriUtlities.js","../node_modules/three-mesh-bvh/src/Constants.js","../node_modules/three-mesh-bvh/src/BVHConstructionContext.js","../node_modules/three-mesh-bvh/src/MeshBVH.js","../node_modules/three-mesh-bvh/src/MeshBVHVisualizer.js","../node_modules/three-mesh-bvh/src/index.js","../src/THREE_Extensions.ts","../src/layout/LayoutHelper.ts","../src/adaptivity/Behavior.ts","../src/adaptivity/AdaptivityManager.ts","../src/adaptivity/AdaptiveOcclusionBehavior.ts"],"sourcesContent":["import * as THREE from 'three'\n\nexport const V_00 = Object.freeze(new THREE.Vector2)\nexport const V_11 = Object.freeze(new THREE.Vector2)\nexport const V_000 = Object.freeze(new THREE.Vector3)\nexport const V_100 = Object.freeze(new THREE.Vector3(1,0,0))\nexport const V_010 = Object.freeze(new THREE.Vector3(0,1,0))\nexport const V_001 = Object.freeze(new THREE.Vector3(0,0,1))\nexport const V_111 = Object.freeze(new THREE.Vector3(1,1,1))\nexport const Q_IDENTITY = Object.freeze(new THREE.Quaternion)\n\nconst next = Promise.resolve()\n\nexport class Pool<T> {\n\n  constructor(private _factory:() => T, private _reset:(t:T) => T) {}\n\n  private _pool = [] as T[]\n  private _unpooled = new Set<T>()\n  private _nextAutoPool?:Promise<void>\n\n  get() { \n    const object = this._pool.pop() || this._reset(this._factory())\n    this._unpooled.add(object)\n    if (!this._nextAutoPool) this._nextAutoPool = next.then(this._autoPool)\n    return object\n  }\n\n  pool(o:T) {\n    this._pool.push(o)\n    this._unpooled.delete(o)\n    this._reset(o)\n  }\n\n  private _poolAll() {\n    if (this._unpooled.size === 0) return\n    for (const o of this._unpooled) this.pool(o)\n  }\n\n  private _autoPool = () => {\n    this._nextAutoPool = undefined\n    this._poolAll()\n  }\n}\n\nexport const vectors2 = new Pool<THREE.Vector2>(\n  () => new THREE.Vector2, \n  (vec) => vec.set(0,0)\n)\n\nexport const vectors = new Pool<THREE.Vector3>(\n    () => new THREE.Vector3, \n    (vec) => vec.set(0,0,0)\n)\n\nexport const vectors4 = new Pool<THREE.Vector4>(\n    () => new THREE.Vector4, \n    (vec) => vec.set(0,0,0,1)\n)\n\nexport const quaternions = new Pool<THREE.Quaternion>(\n    () => new THREE.Quaternion, \n    (quat) => quat.set(0,0,0,1)\n)\n\nexport const matrices3 = new Pool<THREE.Matrix3>(\n  () => new THREE.Matrix3, \n  (mat) => mat.identity()\n)\n\nexport const matrices = new Pool<THREE.Matrix4>(\n    () => new THREE.Matrix4, \n    (mat) => mat.identity()\n)\n\nexport function traverse(\n  object: THREE.Object3D,\n  each: (node: THREE.Object3D) => boolean,\n  bind?: any\n) {\n  if (!each.call(bind, object)) return\n  for (let child of object.children) {\n    traverse(child, each, bind)\n  }\n}","import * as THREE from 'three'\n\n/**\n * @author Mugen87 / https://github.com/Mugen87\n *\n * Ported from: https://github.com/maurizzzio/quickhull3d/ by Mauricio Poppe (https://github.com/maurizzzio)\n *\n */\n\n\nvar Visible = 0;\nvar Deleted = 1;\n\nvar v1 = new THREE.Vector3();\n\nexport function QuickHull() {\n\n\tthis.tolerance = - 1;\n\n\tthis.faces = []; // the generated faces of the convex hull\n\tthis.newFaces = []; // this array holds the faces that are generated within a single iteration\n\n\t// the vertex lists work as follows:\n\t//\n\t// let 'a' and 'b' be 'Face' instances\n\t// let 'v' be points wrapped as instance of 'Vertex'\n\t//\n\t//     [v, v, ..., v, v, v, ...]\n\t//      ^             ^\n\t//      |             |\n\t//  a.outside     b.outside\n\t//\n\tthis.assigned = new VertexList();\n\tthis.unassigned = new VertexList();\n\n\tthis.vertices = []; \t// vertices of the hull (internal representation of given geometry data)\n\n}\n\nObject.assign( QuickHull.prototype, {\n\n\tsetFromPoints: function ( points ) {\n\n\t\tif ( Array.isArray( points ) !== true ) {\n\n\t\t\tconsole.error( 'THREE.QuickHull: Points parameter is not an array.' );\n\n\t\t}\n\n\t\tif ( points.length < 4 ) {\n\n\t\t\tconsole.error( 'THREE.QuickHull: The algorithm needs at least four points.' );\n\n\t\t}\n\n\t\tthis.makeEmpty();\n\n\t\tfor ( var i = 0, l = points.length; i < l; i ++ ) {\n\n\t\t\tthis.vertices.push( new VertexNode( points[ i ] ) );\n\n\t\t}\n\n\t\tthis.compute();\n\n\t\treturn this;\n\n\t},\n\n\tsetFromObject: function ( object ) {\n\n\t\tvar points = [];\n\n\t\tobject.updateMatrixWorld( true );\n\n\t\tobject.traverse( function ( node ) {\n\n\t\t\tvar i, l, point;\n\n\t\t\tvar geometry = node.geometry;\n\n\t\t\tif ( geometry !== undefined ) {\n\n\t\t\t\tif ( geometry.isGeometry ) {\n\n\t\t\t\t\tvar vertices = geometry.vertices;\n\n\t\t\t\t\tfor ( i = 0, l = vertices.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tpoint = vertices[ i ].clone();\n\t\t\t\t\t\tpoint.applyMatrix4( node.matrixWorld );\n\n\t\t\t\t\t\tpoints.push( point );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( geometry.isBufferGeometry ) {\n\n\t\t\t\t\tvar attribute = geometry.attributes.position;\n\n\t\t\t\t\tif ( attribute !== undefined ) {\n\n\t\t\t\t\t\tfor ( i = 0, l = attribute.count; i < l; i ++ ) {\n\n\t\t\t\t\t\t\tpoint = new THREE.Vector3();\n\n\t\t\t\t\t\t\tpoint.fromBufferAttribute( attribute, i ).applyMatrix4( node.matrixWorld );\n\n\t\t\t\t\t\t\tpoints.push( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} );\n\n\t\treturn this.setFromPoints( points );\n\n\t},\n\n\tcontainsPoint: function ( point ) {\n\n\t\tvar faces = this.faces;\n\n\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\t\tvar face = faces[ i ];\n\n\t\t\t// compute signed distance and check on what half space the point lies\n\n\t\t\tif ( face.distanceToPoint( point ) > this.tolerance ) return false;\n\n\t\t}\n\n\t\treturn true;\n\n\t},\n\n\tintersectRay: function ( ray, target ) {\n\n\t\t// based on \"Fast Ray-Convex Polyhedron Intersection\"  by Eric Haines, GRAPHICS GEMS II\n\n\t\tvar faces = this.faces;\n\n\t\tvar tNear = - Infinity;\n\t\tvar tFar = Infinity;\n\n\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\t\tvar face = faces[ i ];\n\n\t\t\t// interpret faces as planes for the further computation\n\n\t\t\tvar vN = face.distanceToPoint( ray.origin );\n\t\t\tvar vD = face.normal.dot( ray.direction );\n\n\t\t\t// if the origin is on the positive side of a plane (so the plane can \"see\" the origin) and\n\t\t\t// the ray is turned away or parallel to the plane, there is no intersection\n\n\t\t\tif ( vN > 0 && vD >= 0 ) return null;\n\n\t\t\t// compute the distance from the rayâ€™s origin to the intersection with the plane\n\n\t\t\tvar t = ( vD !== 0 ) ? ( - vN / vD ) : 0;\n\n\t\t\t// only proceed if the distance is positive. a negative distance means the intersection point\n\t\t\t// lies \"behind\" the origin\n\n\t\t\tif ( t <= 0 ) continue;\n\n\t\t\t// now categorized plane as front-facing or back-facing\n\n\t\t\tif ( vD > 0 ) {\n\n\t\t\t\t//  plane faces away from the ray, so this plane is a back-face\n\n\t\t\t\ttFar = Math.min( t, tFar );\n\n\t\t\t} else {\n\n\t\t\t\t// front-face\n\n\t\t\t\ttNear = Math.max( t, tNear );\n\n\t\t\t}\n\n\t\t\tif ( tNear > tFar ) {\n\n\t\t\t\t// if tNear ever is greater than tFar, the ray must miss the convex hull\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// evaluate intersection point\n\n\t\t// always try tNear first since its the closer intersection point\n\n\t\tif ( tNear !== - Infinity ) {\n\n\t\t\tray.at( tNear, target );\n\n\t\t} else {\n\n\t\t\tray.at( tFar, target );\n\n\t\t}\n\n\t\treturn target;\n\n\t},\n\n\tintersectsRay: function ( ray ) {\n\n\t\treturn this.intersectRay( ray, v1 ) !== null;\n\n\t},\n\n\tmakeEmpty: function () {\n\n\t\tthis.faces = [];\n\t\tthis.vertices = [];\n\n\t\treturn this;\n\n\t},\n\n\t// Adds a vertex to the 'assigned' list of vertices and assigns it to the given face\n\n\taddVertexToFace: function ( vertex, face ) {\n\n\t\tvertex.face = face;\n\n\t\tif ( face.outside === null ) {\n\n\t\t\tthis.assigned.append( vertex );\n\n\t\t} else {\n\n\t\t\tthis.assigned.insertBefore( face.outside, vertex );\n\n\t\t}\n\n\t\tface.outside = vertex;\n\n\t\treturn this;\n\n\t},\n\n\t// Removes a vertex from the 'assigned' list of vertices and from the given face\n\n\tremoveVertexFromFace: function ( vertex, face ) {\n\n\t\tif ( vertex === face.outside ) {\n\n\t\t\t// fix face.outside link\n\n\t\t\tif ( vertex.next !== null && vertex.next.face === face ) {\n\n\t\t\t\t// face has at least 2 outside vertices, move the 'outside' reference\n\n\t\t\t\tface.outside = vertex.next;\n\n\t\t\t} else {\n\n\t\t\t\t// vertex was the only outside vertex that face had\n\n\t\t\t\tface.outside = null;\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.assigned.remove( vertex );\n\n\t\treturn this;\n\n\t},\n\n\t// Removes all the visible vertices that a given face is able to see which are stored in the 'assigned' vertext list\n\n\tremoveAllVerticesFromFace: function ( face ) {\n\n\t\tif ( face.outside !== null ) {\n\n\t\t\t// reference to the first and last vertex of this face\n\n\t\t\tvar start = face.outside;\n\t\t\tvar end = face.outside;\n\n\t\t\twhile ( end.next !== null && end.next.face === face ) {\n\n\t\t\t\tend = end.next;\n\n\t\t\t}\n\n\t\t\tthis.assigned.removeSubList( start, end );\n\n\t\t\t// fix references\n\n\t\t\tstart.prev = end.next = null;\n\t\t\tface.outside = null;\n\n\t\t\treturn start;\n\n\t\t}\n\n\t},\n\n\t// Removes all the visible vertices that 'face' is able to see\n\n\tdeleteFaceVertices: function ( face, absorbingFace ) {\n\n\t\tvar faceVertices = this.removeAllVerticesFromFace( face );\n\n\t\tif ( faceVertices !== undefined ) {\n\n\t\t\tif ( absorbingFace === undefined ) {\n\n\t\t\t\t// mark the vertices to be reassigned to some other face\n\n\t\t\t\tthis.unassigned.appendChain( faceVertices );\n\n\n\t\t\t} else {\n\n\t\t\t\t// if there's an absorbing face try to assign as many vertices as possible to it\n\n\t\t\t\tvar vertex = faceVertices;\n\n\t\t\t\tdo {\n\n\t\t\t\t\t// we need to buffer the subsequent vertex at this point because the 'vertex.next' reference\n\t\t\t\t\t// will be changed by upcoming method calls\n\n\t\t\t\t\tvar nextVertex = vertex.next;\n\n\t\t\t\t\tvar distance = absorbingFace.distanceToPoint( vertex.point );\n\n\t\t\t\t\t// check if 'vertex' is able to see 'absorbingFace'\n\n\t\t\t\t\tif ( distance > this.tolerance ) {\n\n\t\t\t\t\t\tthis.addVertexToFace( vertex, absorbingFace );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tthis.unassigned.append( vertex );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// now assign next vertex\n\n\t\t\t\t\tvertex = nextVertex;\n\n\t\t\t\t} while ( vertex !== null );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\t// Reassigns as many vertices as possible from the unassigned list to the new faces\n\n\tresolveUnassignedPoints: function ( newFaces ) {\n\n\t\tif ( this.unassigned.isEmpty() === false ) {\n\n\t\t\tvar vertex = this.unassigned.first();\n\n\t\t\tdo {\n\n\t\t\t\t// buffer 'next' reference, see .deleteFaceVertices()\n\n\t\t\t\tvar nextVertex = vertex.next;\n\n\t\t\t\tvar maxDistance = this.tolerance;\n\n\t\t\t\tvar maxFace = null;\n\n\t\t\t\tfor ( var i = 0; i < newFaces.length; i ++ ) {\n\n\t\t\t\t\tvar face = newFaces[ i ];\n\n\t\t\t\t\tif ( face.mark === Visible ) {\n\n\t\t\t\t\t\tvar distance = face.distanceToPoint( vertex.point );\n\n\t\t\t\t\t\tif ( distance > maxDistance ) {\n\n\t\t\t\t\t\t\tmaxDistance = distance;\n\t\t\t\t\t\t\tmaxFace = face;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( maxDistance > 1000 * this.tolerance ) break;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// 'maxFace' can be null e.g. if there are identical vertices\n\n\t\t\t\tif ( maxFace !== null ) {\n\n\t\t\t\t\tthis.addVertexToFace( vertex, maxFace );\n\n\t\t\t\t}\n\n\t\t\t\tvertex = nextVertex;\n\n\t\t\t} while ( vertex !== null );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\t// Computes the extremes of a simplex which will be the initial hull\n\n\tcomputeExtremes: function () {\n\n\t\tvar min = new THREE.Vector3();\n\t\tvar max = new THREE.Vector3();\n\n\t\tvar minVertices = [];\n\t\tvar maxVertices = [];\n\n\t\tvar i, l, j;\n\n\t\t// initially assume that the first vertex is the min/max\n\n\t\tfor ( i = 0; i < 3; i ++ ) {\n\n\t\t\tminVertices[ i ] = maxVertices[ i ] = this.vertices[ 0 ];\n\n\t\t}\n\n\t\tmin.copy( this.vertices[ 0 ].point );\n\t\tmax.copy( this.vertices[ 0 ].point );\n\n\t\t// compute the min/max vertex on all six directions\n\n\t\tfor ( i = 0, l = this.vertices.length; i < l; i ++ ) {\n\n\t\t\tvar vertex = this.vertices[ i ];\n\t\t\tvar point = vertex.point;\n\n\t\t\t// update the min coordinates\n\n\t\t\tfor ( j = 0; j < 3; j ++ ) {\n\n\t\t\t\tif ( point.getComponent( j ) < min.getComponent( j ) ) {\n\n\t\t\t\t\tmin.setComponent( j, point.getComponent( j ) );\n\t\t\t\t\tminVertices[ j ] = vertex;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// update the max coordinates\n\n\t\t\tfor ( j = 0; j < 3; j ++ ) {\n\n\t\t\t\tif ( point.getComponent( j ) > max.getComponent( j ) ) {\n\n\t\t\t\t\tmax.setComponent( j, point.getComponent( j ) );\n\t\t\t\t\tmaxVertices[ j ] = vertex;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// use min/max vectors to compute an optimal epsilon\n\n\t\tthis.tolerance = 3 * Number.EPSILON * (\n\t\t\tMath.max( Math.abs( min.x ), Math.abs( max.x ) ) +\n\t\t\tMath.max( Math.abs( min.y ), Math.abs( max.y ) ) +\n\t\t\tMath.max( Math.abs( min.z ), Math.abs( max.z ) )\n\t\t);\n\n\t\treturn { min: minVertices, max: maxVertices };\n\n\t},\n\n\t// Computes the initial simplex assigning to its faces all the points\n\t// that are candidates to form part of the hull\n\n\tcomputeInitialHull: function () {\n\n\t\tvar line3, plane, closestPoint;\n\n\t\treturn function computeInitialHull() {\n\n\t\t\tif ( line3 === undefined ) {\n\n\t\t\t\tline3 = new THREE.Line3();\n\t\t\t\tplane = new THREE.Plane();\n\t\t\t\tclosestPoint = new THREE.Vector3();\n\n\t\t\t}\n\n\t\t\tvar vertex, vertices = this.vertices;\n\t\t\tvar extremes = this.computeExtremes();\n\t\t\tvar min = extremes.min;\n\t\t\tvar max = extremes.max;\n\n\t\t\tvar v0, v1, v2, v3;\n\t\t\tvar i, l, j;\n\n\t\t\t// 1. Find the two vertices 'v0' and 'v1' with the greatest 1d separation\n\t\t\t// (max.x - min.x)\n\t\t\t// (max.y - min.y)\n\t\t\t// (max.z - min.z)\n\n\t\t\tvar distance, maxDistance = 0;\n\t\t\tvar index = 0;\n\n\t\t\tfor ( i = 0; i < 3; i ++ ) {\n\n\t\t\t\tdistance = max[ i ].point.getComponent( i ) - min[ i ].point.getComponent( i );\n\n\t\t\t\tif ( distance > maxDistance ) {\n\n\t\t\t\t\tmaxDistance = distance;\n\t\t\t\t\tindex = i;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tv0 = min[ index ];\n\t\t\tv1 = max[ index ];\n\n\t\t\t// 2. The next vertex 'v2' is the one farthest to the line formed by 'v0' and 'v1'\n\n\t\t\tmaxDistance = 0;\n\t\t\tline3.set( v0.point, v1.point );\n\n\t\t\tfor ( i = 0, l = this.vertices.length; i < l; i ++ ) {\n\n\t\t\t\tvertex = vertices[ i ];\n\n\t\t\t\tif ( vertex !== v0 && vertex !== v1 ) {\n\n\t\t\t\t\tline3.closestPointToPoint( vertex.point, true, closestPoint );\n\n\t\t\t\t\tdistance = closestPoint.distanceToSquared( vertex.point );\n\n\t\t\t\t\tif ( distance > maxDistance ) {\n\n\t\t\t\t\t\tmaxDistance = distance;\n\t\t\t\t\t\tv2 = vertex;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// 3. The next vertex 'v3' is the one farthest to the plane 'v0', 'v1', 'v2'\n\n\t\t\tmaxDistance = - 1;\n\t\t\tplane.setFromCoplanarPoints( v0.point, v1.point, v2.point );\n\n\t\t\tfor ( i = 0, l = this.vertices.length; i < l; i ++ ) {\n\n\t\t\t\tvertex = vertices[ i ];\n\n\t\t\t\tif ( vertex !== v0 && vertex !== v1 && vertex !== v2 ) {\n\n\t\t\t\t\tdistance = Math.abs( plane.distanceToPoint( vertex.point ) );\n\n\t\t\t\t\tif ( distance > maxDistance ) {\n\n\t\t\t\t\t\tmaxDistance = distance;\n\t\t\t\t\t\tv3 = vertex;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar faces = [];\n\n\t\t\tif ( plane.distanceToPoint( v3.point ) < 0 ) {\n\n\t\t\t\t// the face is not able to see the point so 'plane.normal' is pointing outside the tetrahedron\n\n\t\t\t\tfaces.push(\n\t\t\t\t\tFace.create( v0, v1, v2 ),\n\t\t\t\t\tFace.create( v3, v1, v0 ),\n\t\t\t\t\tFace.create( v3, v2, v1 ),\n\t\t\t\t\tFace.create( v3, v0, v2 )\n\t\t\t\t);\n\n\t\t\t\t// set the twin edge\n\n\t\t\t\tfor ( i = 0; i < 3; i ++ ) {\n\n\t\t\t\t\tj = ( i + 1 ) % 3;\n\n\t\t\t\t\t// join face[ i ] i > 0, with the first face\n\n\t\t\t\t\tfaces[ i + 1 ].getEdge( 2 ).setTwin( faces[ 0 ].getEdge( j ) );\n\n\t\t\t\t\t// join face[ i ] with face[ i + 1 ], 1 <= i <= 3\n\n\t\t\t\t\tfaces[ i + 1 ].getEdge( 1 ).setTwin( faces[ j + 1 ].getEdge( 0 ) );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// the face is able to see the point so 'plane.normal' is pointing inside the tetrahedron\n\n\t\t\t\tfaces.push(\n\t\t\t\t\tFace.create( v0, v2, v1 ),\n\t\t\t\t\tFace.create( v3, v0, v1 ),\n\t\t\t\t\tFace.create( v3, v1, v2 ),\n\t\t\t\t\tFace.create( v3, v2, v0 )\n\t\t\t\t);\n\n\t\t\t\t// set the twin edge\n\n\t\t\t\tfor ( i = 0; i < 3; i ++ ) {\n\n\t\t\t\t\tj = ( i + 1 ) % 3;\n\n\t\t\t\t\t// join face[ i ] i > 0, with the first face\n\n\t\t\t\t\tfaces[ i + 1 ].getEdge( 2 ).setTwin( faces[ 0 ].getEdge( ( 3 - i ) % 3 ) );\n\n\t\t\t\t\t// join face[ i ] with face[ i + 1 ]\n\n\t\t\t\t\tfaces[ i + 1 ].getEdge( 0 ).setTwin( faces[ j + 1 ].getEdge( 1 ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// the initial hull is the tetrahedron\n\n\t\t\tfor ( i = 0; i < 4; i ++ ) {\n\n\t\t\t\tthis.faces.push( faces[ i ] );\n\n\t\t\t}\n\n\t\t\t// initial assignment of vertices to the faces of the tetrahedron\n\n\t\t\tfor ( i = 0, l = vertices.length; i < l; i ++ ) {\n\n\t\t\t\tvertex = vertices[ i ];\n\n\t\t\t\tif ( vertex !== v0 && vertex !== v1 && vertex !== v2 && vertex !== v3 ) {\n\n\t\t\t\t\tmaxDistance = this.tolerance;\n\t\t\t\t\tvar maxFace = null;\n\n\t\t\t\t\tfor ( j = 0; j < 4; j ++ ) {\n\n\t\t\t\t\t\tdistance = this.faces[ j ].distanceToPoint( vertex.point );\n\n\t\t\t\t\t\tif ( distance > maxDistance ) {\n\n\t\t\t\t\t\t\tmaxDistance = distance;\n\t\t\t\t\t\t\tmaxFace = this.faces[ j ];\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( maxFace !== null ) {\n\n\t\t\t\t\t\tthis.addVertexToFace( vertex, maxFace );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\t// Removes inactive faces\n\n\treindexFaces: function () {\n\n\t\tvar activeFaces = [];\n\n\t\tfor ( var i = 0; i < this.faces.length; i ++ ) {\n\n\t\t\tvar face = this.faces[ i ];\n\n\t\t\tif ( face.mark === Visible ) {\n\n\t\t\t\tactiveFaces.push( face );\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.faces = activeFaces;\n\n\t\treturn this;\n\n\t},\n\n\t// Finds the next vertex to create faces with the current hull\n\n\tnextVertexToAdd: function () {\n\n\t\t// if the 'assigned' list of vertices is empty, no vertices are left. return with 'undefined'\n\n\t\tif ( this.assigned.isEmpty() === false ) {\n\n\t\t\tvar eyeVertex, maxDistance = 0;\n\n\t\t\t// grap the first available face and start with the first visible vertex of that face\n\n\t\t\tvar eyeFace = this.assigned.first().face;\n\t\t\tvar vertex = eyeFace.outside;\n\n\t\t\t// now calculate the farthest vertex that face can see\n\n\t\t\tdo {\n\n\t\t\t\tvar distance = eyeFace.distanceToPoint( vertex.point );\n\n\t\t\t\tif ( distance > maxDistance ) {\n\n\t\t\t\t\tmaxDistance = distance;\n\t\t\t\t\teyeVertex = vertex;\n\n\t\t\t\t}\n\n\t\t\t\tvertex = vertex.next;\n\n\t\t\t} while ( vertex !== null && vertex.face === eyeFace );\n\n\t\t\treturn eyeVertex;\n\n\t\t}\n\n\t},\n\n\t// Computes a chain of half edges in CCW order called the 'horizon'.\n\t// For an edge to be part of the horizon it must join a face that can see\n\t// 'eyePoint' and a face that cannot see 'eyePoint'.\n\n\tcomputeHorizon: function ( eyePoint, crossEdge, face, horizon ) {\n\n\t\t// moves face's vertices to the 'unassigned' vertex list\n\n\t\tthis.deleteFaceVertices( face );\n\n\t\tface.mark = Deleted;\n\n\t\tvar edge;\n\n\t\tif ( crossEdge === null ) {\n\n\t\t\tedge = crossEdge = face.getEdge( 0 );\n\n\t\t} else {\n\n\t\t\t// start from the next edge since 'crossEdge' was already analyzed\n\t\t\t// (actually 'crossEdge.twin' was the edge who called this method recursively)\n\n\t\t\tedge = crossEdge.next;\n\n\t\t}\n\n\t\tdo {\n\n\t\t\tvar twinEdge = edge.twin;\n\t\t\tvar oppositeFace = twinEdge.face;\n\n\t\t\tif ( oppositeFace.mark === Visible ) {\n\n\t\t\t\tif ( oppositeFace.distanceToPoint( eyePoint ) > this.tolerance ) {\n\n\t\t\t\t\t// the opposite face can see the vertex, so proceed with next edge\n\n\t\t\t\t\tthis.computeHorizon( eyePoint, twinEdge, oppositeFace, horizon );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// the opposite face can't see the vertex, so this edge is part of the horizon\n\n\t\t\t\t\thorizon.push( edge );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tedge = edge.next;\n\n\t\t} while ( edge !== crossEdge );\n\n\t\treturn this;\n\n\t},\n\n\t// Creates a face with the vertices 'eyeVertex.point', 'horizonEdge.tail' and 'horizonEdge.head' in CCW order\n\n\taddAdjoiningFace: function ( eyeVertex, horizonEdge ) {\n\n\t\t// all the half edges are created in ccw order thus the face is always pointing outside the hull\n\n\t\tvar face = Face.create( eyeVertex, horizonEdge.tail(), horizonEdge.head() );\n\n\t\tthis.faces.push( face );\n\n\t\t// join face.getEdge( - 1 ) with the horizon's opposite edge face.getEdge( - 1 ) = face.getEdge( 2 )\n\n\t\tface.getEdge( - 1 ).setTwin( horizonEdge.twin );\n\n\t\treturn face.getEdge( 0 ); // the half edge whose vertex is the eyeVertex\n\n\n\t},\n\n\t//  Adds 'horizon.length' faces to the hull, each face will be linked with the\n\t//  horizon opposite face and the face on the left/right\n\n\taddNewFaces: function ( eyeVertex, horizon ) {\n\n\t\tthis.newFaces = [];\n\n\t\tvar firstSideEdge = null;\n\t\tvar previousSideEdge = null;\n\n\t\tfor ( var i = 0; i < horizon.length; i ++ ) {\n\n\t\t\tvar horizonEdge = horizon[ i ];\n\n\t\t\t// returns the right side edge\n\n\t\t\tvar sideEdge = this.addAdjoiningFace( eyeVertex, horizonEdge );\n\n\t\t\tif ( firstSideEdge === null ) {\n\n\t\t\t\tfirstSideEdge = sideEdge;\n\n\t\t\t} else {\n\n\t\t\t\t// joins face.getEdge( 1 ) with previousFace.getEdge( 0 )\n\n\t\t\t\tsideEdge.next.setTwin( previousSideEdge );\n\n\t\t\t}\n\n\t\t\tthis.newFaces.push( sideEdge.face );\n\t\t\tpreviousSideEdge = sideEdge;\n\n\t\t}\n\n\t\t// perform final join of new faces\n\n\t\tfirstSideEdge.next.setTwin( previousSideEdge );\n\n\t\treturn this;\n\n\t},\n\n\t// Adds a vertex to the hull\n\n\taddVertexToHull: function ( eyeVertex ) {\n\n\t\tvar horizon = [];\n\n\t\tthis.unassigned.clear();\n\n\t\t// remove 'eyeVertex' from 'eyeVertex.face' so that it can't be added to the 'unassigned' vertex list\n\n\t\tthis.removeVertexFromFace( eyeVertex, eyeVertex.face );\n\n\t\tthis.computeHorizon( eyeVertex.point, null, eyeVertex.face, horizon );\n\n\t\tthis.addNewFaces( eyeVertex, horizon );\n\n\t\t// reassign 'unassigned' vertices to the new faces\n\n\t\tthis.resolveUnassignedPoints( this.newFaces );\n\n\t\treturn\tthis;\n\n\t},\n\n\tcleanup: function () {\n\n\t\tthis.assigned.clear();\n\t\tthis.unassigned.clear();\n\t\tthis.newFaces = [];\n\n\t\treturn this;\n\n\t},\n\n\tcompute: function () {\n\n\t\tvar vertex;\n\n\t\tthis.computeInitialHull();\n\n\t\t// add all available vertices gradually to the hull\n\n\t\twhile ( ( vertex = this.nextVertexToAdd() ) !== undefined ) {\n\n\t\t\tthis.addVertexToHull( vertex );\n\n\t\t}\n\n\t\tthis.reindexFaces();\n\n\t\tthis.cleanup();\n\n\t\treturn this;\n\n\t}\n\n} );\n\n//\n\nfunction Face() {\n\n\tthis.normal = new THREE.Vector3();\n\tthis.midpoint = new THREE.Vector3();\n\tthis.area = 0;\n\n\tthis.constant = 0; // signed distance from face to the origin\n\tthis.outside = null; // reference to a vertex in a vertex list this face can see\n\tthis.mark = Visible;\n\tthis.edge = null;\n\n}\n\nObject.assign( Face, {\n\n\tcreate: function ( a, b, c ) {\n\n\t\tvar face = new Face();\n\n\t\tvar e0 = new HalfEdge( a, face );\n\t\tvar e1 = new HalfEdge( b, face );\n\t\tvar e2 = new HalfEdge( c, face );\n\n\t\t// join edges\n\n\t\te0.next = e2.prev = e1;\n\t\te1.next = e0.prev = e2;\n\t\te2.next = e1.prev = e0;\n\n\t\t// main half edge reference\n\n\t\tface.edge = e0;\n\n\t\treturn face.compute();\n\n\t}\n\n} );\n\nObject.assign( Face.prototype, {\n\n\tgetEdge: function ( i ) {\n\n\t\tvar edge = this.edge;\n\n\t\twhile ( i > 0 ) {\n\n\t\t\tedge = edge.next;\n\t\t\ti --;\n\n\t\t}\n\n\t\twhile ( i < 0 ) {\n\n\t\t\tedge = edge.prev;\n\t\t\ti ++;\n\n\t\t}\n\n\t\treturn edge;\n\n\t},\n\n\tcompute: function () {\n\n\t\tvar triangle;\n\n\t\treturn function compute() {\n\n\t\t\tif ( triangle === undefined ) triangle = new THREE.Triangle();\n\n\t\t\tvar a = this.edge.tail();\n\t\t\tvar b = this.edge.head();\n\t\t\tvar c = this.edge.next.head();\n\n\t\t\ttriangle.set( a.point, b.point, c.point );\n\n\t\t\ttriangle.getNormal( this.normal );\n\t\t\ttriangle.getMidpoint( this.midpoint );\n\t\t\tthis.area = triangle.getArea();\n\n\t\t\tthis.constant = this.normal.dot( this.midpoint );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\tdistanceToPoint: function ( point ) {\n\n\t\treturn this.normal.dot( point ) - this.constant;\n\n\t}\n\n} );\n\n// Entity for a Doubly-Connected Edge List (DCEL).\n\nfunction HalfEdge( vertex, face ) {\n\n\tthis.vertex = vertex;\n\tthis.prev = null;\n\tthis.next = null;\n\tthis.twin = null;\n\tthis.face = face;\n\n}\n\nObject.assign( HalfEdge.prototype, {\n\n\thead: function () {\n\n\t\treturn this.vertex;\n\n\t},\n\n\ttail: function () {\n\n\t\treturn this.prev ? this.prev.vertex : null;\n\n\t},\n\n\tlength: function () {\n\n\t\tvar head = this.head();\n\t\tvar tail = this.tail();\n\n\t\tif ( tail !== null ) {\n\n\t\t\treturn tail.point.distanceTo( head.point );\n\n\t\t}\n\n\t\treturn - 1;\n\n\t},\n\n\tlengthSquared: function () {\n\n\t\tvar head = this.head();\n\t\tvar tail = this.tail();\n\n\t\tif ( tail !== null ) {\n\n\t\t\treturn tail.point.distanceToSquared( head.point );\n\n\t\t}\n\n\t\treturn - 1;\n\n\t},\n\n\tsetTwin: function ( edge ) {\n\n\t\tthis.twin = edge;\n\t\tedge.twin = this;\n\n\t\treturn this;\n\n\t}\n\n} );\n\n// A vertex as a double linked list node.\n\nfunction VertexNode( point ) {\n\n\tthis.point = point;\n\tthis.prev = null;\n\tthis.next = null;\n\tthis.face = null; // the face that is able to see this vertex\n\n}\n\n// A double linked list that contains vertex nodes.\n\nfunction VertexList() {\n\n\tthis.head = null;\n\tthis.tail = null;\n\n}\n\nObject.assign( VertexList.prototype, {\n\n\tfirst: function () {\n\n\t\treturn this.head;\n\n\t},\n\n\tlast: function () {\n\n\t\treturn this.tail;\n\n\t},\n\n\tclear: function () {\n\n\t\tthis.head = this.tail = null;\n\n\t\treturn this;\n\n\t},\n\n\t// Inserts a vertex before the target vertex\n\n\tinsertBefore: function ( target, vertex ) {\n\n\t\tvertex.prev = target.prev;\n\t\tvertex.next = target;\n\n\t\tif ( vertex.prev === null ) {\n\n\t\t\tthis.head = vertex;\n\n\t\t} else {\n\n\t\t\tvertex.prev.next = vertex;\n\n\t\t}\n\n\t\ttarget.prev = vertex;\n\n\t\treturn this;\n\n\t},\n\n\t// Inserts a vertex after the target vertex\n\n\tinsertAfter: function ( target, vertex ) {\n\n\t\tvertex.prev = target;\n\t\tvertex.next = target.next;\n\n\t\tif ( vertex.next === null ) {\n\n\t\t\tthis.tail = vertex;\n\n\t\t} else {\n\n\t\t\tvertex.next.prev = vertex;\n\n\t\t}\n\n\t\ttarget.next = vertex;\n\n\t\treturn this;\n\n\t},\n\n\t// Appends a vertex to the end of the linked list\n\n\tappend: function ( vertex ) {\n\n\t\tif ( this.head === null ) {\n\n\t\t\tthis.head = vertex;\n\n\t\t} else {\n\n\t\t\tthis.tail.next = vertex;\n\n\t\t}\n\n\t\tvertex.prev = this.tail;\n\t\tvertex.next = null; // the tail has no subsequent vertex\n\n\t\tthis.tail = vertex;\n\n\t\treturn this;\n\n\t},\n\n\t// Appends a chain of vertices where 'vertex' is the head.\n\n\tappendChain: function ( vertex ) {\n\n\t\tif ( this.head === null ) {\n\n\t\t\tthis.head = vertex;\n\n\t\t} else {\n\n\t\t\tthis.tail.next = vertex;\n\n\t\t}\n\n\t\tvertex.prev = this.tail;\n\n\t\t// ensure that the 'tail' reference points to the last vertex of the chain\n\n\t\twhile ( vertex.next !== null ) {\n\n\t\t\tvertex = vertex.next;\n\n\t\t}\n\n\t\tthis.tail = vertex;\n\n\t\treturn this;\n\n\t},\n\n\t// Removes a vertex from the linked list\n\n\tremove: function ( vertex ) {\n\n\t\tif ( vertex.prev === null ) {\n\n\t\t\tthis.head = vertex.next;\n\n\t\t} else {\n\n\t\t\tvertex.prev.next = vertex.next;\n\n\t\t}\n\n\t\tif ( vertex.next === null ) {\n\n\t\t\tthis.tail = vertex.prev;\n\n\t\t} else {\n\n\t\t\tvertex.next.prev = vertex.prev;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\t// Removes a list of vertices whose 'head' is 'a' and whose 'tail' is b\n\n\tremoveSubList: function ( a, b ) {\n\n\t\tif ( a.prev === null ) {\n\n\t\t\tthis.head = b.next;\n\n\t\t} else {\n\n\t\t\ta.prev.next = b.next;\n\n\t\t}\n\n\t\tif ( b.next === null ) {\n\n\t\t\tthis.tail = a.prev;\n\n\t\t} else {\n\n\t\t\tb.next.prev = a.prev;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tisEmpty: function () {\n\n\t\treturn this.head === null;\n\n\t}\n\n} );","/**\n * @author Mugen87 / https://github.com/Mugen87\n * \n * adapted for Typescript by Gheric Speiginer\n */\n\nimport * as THREE from 'three'\nimport {QuickHull} from './QuickHull'\n\n// ConvexGeometry\nexport class ConvexGeometry extends THREE.Geometry {\n\n    constructor(public points:THREE.Vector3[]) {\n        super()\n        this.fromBufferGeometry( new ConvexBufferGeometry( points ) );\n        this.mergeVertices();\n    }\n\n}\n\n// ConvexBufferGeometry\n\nexport class ConvexBufferGeometry extends THREE.BufferGeometry { \n\n    constructor(public points:THREE.Vector3[]) {\n        super()\n\n        // buffers\n\n        var vertices = [] as number[];\n        var normals = [] as number[];\n\n        // execute QuickHull\n\n        if ( QuickHull === undefined ) {\n\n            console.error( 'THREE.ConvexBufferGeometry: ConvexBufferGeometry relies on THREE.QuickHull' );\n\n        }\n\n        var quickHull = new (QuickHull as any)().setFromPoints( points );\n\n        // generate vertices and normals\n\n        var faces = quickHull.faces;\n\n        for ( var i = 0; i < faces.length; i ++ ) {\n\n            var face = faces[ i ];\n            var edge = face.edge;\n\n            // we move along a doubly-connected edge list to access all face points (see HalfEdge docs)\n\n            do {\n\n                var point = edge.head().point;\n\n                vertices.push( point.x, point.y, point.z );\n                normals.push( face.normal.x, face.normal.y, face.normal.z );\n\n                edge = edge.next;\n\n            } while ( edge !== face.edge );\n\n        }\n\n        // build geometry\n\n        this.addAttribute( 'position', new THREE.Float32BufferAttribute( vertices, 3 ) );\n        this.addAttribute( 'normal', new THREE.Float32BufferAttribute( normals, 3 ) );\n    }\n}","/*\n *\t@author zz85 / http://twitter.com/blurspline / http://www.lab4games.net/zz85/blog\n *\n *\tSimplification Geometry Modifier\n *    - based on code and technique\n *\t  - by Stan Melax in 1998\n *\t  - Progressive Mesh type Polygon Reduction Algorithm\n *    - http://www.melax.com/polychop/\n */\n\nimport * as THREE from 'three'\n\nexport var SimplifyModifier = function () {};\n\n( function () {\n\n\tvar cb = new THREE.Vector3(), ab = new THREE.Vector3();\n\n\tfunction pushIfUnique( array, object ) {\n\n\t\tif ( array.indexOf( object ) === - 1 ) array.push( object );\n\n\t}\n\n\tfunction removeFromArray( array, object ) {\n\n\t\tvar k = array.indexOf( object );\n\t\tif ( k > - 1 ) array.splice( k, 1 );\n\n\t}\n\n\tfunction computeEdgeCollapseCost( u, v ) {\n\n\t\t// if we collapse edge uv by moving u to v then how\n\t\t// much different will the model change, i.e. the \"error\".\n\n\t\tvar edgelength = v.position.distanceTo( u.position );\n\t\tvar curvature = 0;\n\n\t\tvar sideFaces = [];\n\t\tvar i, il = u.faces.length, face, sideFace;\n\n\t\t// find the \"sides\" triangles that are on the edge uv\n\t\tfor ( i = 0; i < il; i ++ ) {\n\n\t\t\tface = u.faces[ i ];\n\n\t\t\tif ( face.hasVertex( v ) ) {\n\n\t\t\t\tsideFaces.push( face );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// use the triangle facing most away from the sides\n\t\t// to determine our curvature term\n\t\tfor ( i = 0; i < il; i ++ ) {\n\n\t\t\tvar minCurvature = 1;\n\t\t\tface = u.faces[ i ];\n\n\t\t\tfor ( var j = 0; j < sideFaces.length; j ++ ) {\n\n\t\t\t\tsideFace = sideFaces[ j ];\n\t\t\t\t// use dot product of face normals.\n\t\t\t\tvar dotProd = face.normal.dot( sideFace.normal );\n\t\t\t\tminCurvature = Math.min( minCurvature, ( 1.001 - dotProd ) / 2 );\n\n\t\t\t}\n\n\t\t\tcurvature = Math.max( curvature, minCurvature );\n\n\t\t}\n\n\t\t// crude approach in attempt to preserve borders\n\t\t// though it seems not to be totally correct\n\t\tvar borders = 0;\n\t\tif ( sideFaces.length < 2 ) {\n\n\t\t\t// we add some arbitrary cost for borders,\n\t\t\t// borders += 10;\n\t\t\tcurvature = 1;\n\n\t\t}\n\n\t\tvar amt = edgelength * curvature + borders;\n\n\t\treturn amt;\n\n\t}\n\n\tfunction computeEdgeCostAtVertex( v ) {\n\n\t\t// compute the edge collapse cost for all edges that start\n\t\t// from vertex v.  Since we are only interested in reducing\n\t\t// the object by selecting the min cost edge at each step, we\n\t\t// only cache the cost of the least cost edge at this vertex\n\t\t// (in member variable collapse) as well as the value of the\n\t\t// cost (in member variable collapseCost).\n\n\t\tif ( v.neighbors.length === 0 ) {\n\n\t\t\t// collapse if no neighbors.\n\t\t\tv.collapseNeighbor = null;\n\t\t\tv.collapseCost = - 0.01;\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tv.collapseCost = 100000;\n\t\tv.collapseNeighbor = null;\n\n\t\t// search all neighboring edges for \"least cost\" edge\n\t\tfor ( var i = 0; i < v.neighbors.length; i ++ ) {\n\n\t\t\tvar collapseCost = computeEdgeCollapseCost( v, v.neighbors[ i ] );\n\n\t\t\tif ( ! v.collapseNeighbor ) {\n\n\t\t\t\tv.collapseNeighbor = v.neighbors[ i ];\n\t\t\t\tv.collapseCost = collapseCost;\n\t\t\t\tv.minCost = collapseCost;\n\t\t\t\tv.totalCost = 0;\n\t\t\t\tv.costCount = 0;\n\n\t\t\t}\n\n\t\t\tv.costCount ++;\n\t\t\tv.totalCost += collapseCost;\n\n\t\t\tif ( collapseCost < v.minCost ) {\n\n\t\t\t\tv.collapseNeighbor = v.neighbors[ i ];\n\t\t\t\tv.minCost = collapseCost;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// we average the cost of collapsing at this vertex\n\t\tv.collapseCost = v.totalCost / v.costCount;\n\t\t// v.collapseCost = v.minCost;\n\n\t}\n\n\tfunction removeVertex( v, vertices ) {\n\n\t\tconsole.assert( v.faces.length === 0 );\n\n\t\twhile ( v.neighbors.length ) {\n\n\t\t\tvar n = v.neighbors.pop();\n\t\t\tremoveFromArray( n.neighbors, v );\n\n\t\t}\n\n\t\tremoveFromArray( vertices, v );\n\n\t}\n\n\tfunction removeFace( f, faces ) {\n\n\t\tremoveFromArray( faces, f );\n\n\t\tif ( f.v1 ) removeFromArray( f.v1.faces, f );\n\t\tif ( f.v2 ) removeFromArray( f.v2.faces, f );\n\t\tif ( f.v3 ) removeFromArray( f.v3.faces, f );\n\n\t\t// TODO optimize this!\n\t\tvar vs = [ f.v1, f.v2, f.v3 ];\n\t\tvar v1, v2;\n\n\t\tfor ( var i = 0; i < 3; i ++ ) {\n\n\t\t\tv1 = vs[ i ];\n\t\t\tv2 = vs[ ( i + 1 ) % 3 ];\n\n\t\t\tif ( ! v1 || ! v2 ) continue;\n\n\t\t\tv1.removeIfNonNeighbor( v2 );\n\t\t\tv2.removeIfNonNeighbor( v1 );\n\n\t\t}\n\n\t}\n\n\tfunction collapse( vertices, faces, u, v ) { // u and v are pointers to vertices of an edge\n\n\t\t// Collapse the edge uv by moving vertex u onto v\n\n\t\tif ( ! v ) {\n\n\t\t\t// u is a vertex all by itself so just delete it..\n\t\t\tremoveVertex( u, vertices );\n\t\t\treturn;\n\n\t\t}\n\n\t\tvar i;\n\t\tvar tmpVertices = [];\n\n\t\tfor ( i = 0; i < u.neighbors.length; i ++ ) {\n\n\t\t\ttmpVertices.push( u.neighbors[ i ] );\n\n\t\t}\n\n\n\t\t// delete triangles on edge uv:\n\t\tfor ( i = u.faces.length - 1; i >= 0; i -- ) {\n\n\t\t\tif ( u.faces[ i ].hasVertex( v ) ) {\n\n\t\t\t\tremoveFace( u.faces[ i ], faces );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// update remaining triangles to have v instead of u\n\t\tfor ( i = u.faces.length - 1; i >= 0; i -- ) {\n\n\t\t\tu.faces[ i ].replaceVertex( u, v );\n\n\t\t}\n\n\n\t\tremoveVertex( u, vertices );\n\n\t\t// recompute the edge collapse costs in neighborhood\n\t\tfor ( i = 0; i < tmpVertices.length; i ++ ) {\n\n\t\t\tcomputeEdgeCostAtVertex( tmpVertices[ i ] );\n\n\t\t}\n\n\t}\n\n\n\n\tfunction minimumCostEdge( vertices ) {\n\n\t\t// O(n * n) approach. TODO optimize this\n\n\t\tvar least = vertices[ 0 ];\n\n\t\tfor ( var i = 0; i < vertices.length; i ++ ) {\n\n\t\t\tif ( vertices[ i ].collapseCost < least.collapseCost ) {\n\n\t\t\t\tleast = vertices[ i ];\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn least;\n\n\t}\n\n\t// we use a triangle class to represent structure of face slightly differently\n\n\tfunction Triangle( v1, v2, v3, a, b, c ) {\n\n\t\tthis.a = a;\n\t\tthis.b = b;\n\t\tthis.c = c;\n\n\t\tthis.v1 = v1;\n\t\tthis.v2 = v2;\n\t\tthis.v3 = v3;\n\n\t\tthis.normal = new THREE.Vector3();\n\n\t\tthis.computeNormal();\n\n\t\tv1.faces.push( this );\n\t\tv1.addUniqueNeighbor( v2 );\n\t\tv1.addUniqueNeighbor( v3 );\n\n\t\tv2.faces.push( this );\n\t\tv2.addUniqueNeighbor( v1 );\n\t\tv2.addUniqueNeighbor( v3 );\n\n\n\t\tv3.faces.push( this );\n\t\tv3.addUniqueNeighbor( v1 );\n\t\tv3.addUniqueNeighbor( v2 );\n\n\t}\n\n\tTriangle.prototype.computeNormal = function () {\n\n\t\tvar vA = this.v1.position;\n\t\tvar vB = this.v2.position;\n\t\tvar vC = this.v3.position;\n\n\t\tcb.subVectors( vC, vB );\n\t\tab.subVectors( vA, vB );\n\t\tcb.cross( ab ).normalize();\n\n\t\tthis.normal.copy( cb );\n\n\t};\n\n\tTriangle.prototype.hasVertex = function ( v ) {\n\n\t\treturn v === this.v1 || v === this.v2 || v === this.v3;\n\n\t};\n\n\tTriangle.prototype.replaceVertex = function ( oldv, newv ) {\n\n\t\tif ( oldv === this.v1 ) this.v1 = newv;\n\t\telse if ( oldv === this.v2 ) this.v2 = newv;\n\t\telse if ( oldv === this.v3 ) this.v3 = newv;\n\n\t\tremoveFromArray( oldv.faces, this );\n\t\tnewv.faces.push( this );\n\n\n\t\toldv.removeIfNonNeighbor( this.v1 );\n\t\tthis.v1.removeIfNonNeighbor( oldv );\n\n\t\toldv.removeIfNonNeighbor( this.v2 );\n\t\tthis.v2.removeIfNonNeighbor( oldv );\n\n\t\toldv.removeIfNonNeighbor( this.v3 );\n\t\tthis.v3.removeIfNonNeighbor( oldv );\n\n\t\tthis.v1.addUniqueNeighbor( this.v2 );\n\t\tthis.v1.addUniqueNeighbor( this.v3 );\n\n\t\tthis.v2.addUniqueNeighbor( this.v1 );\n\t\tthis.v2.addUniqueNeighbor( this.v3 );\n\n\t\tthis.v3.addUniqueNeighbor( this.v1 );\n\t\tthis.v3.addUniqueNeighbor( this.v2 );\n\n\t\tthis.computeNormal();\n\n\t};\n\n\tfunction Vertex( v, id ) {\n\n\t\tthis.position = v;\n\n\t\tthis.id = id; // old index id\n\n\t\tthis.faces = []; // faces vertex is connected\n\t\tthis.neighbors = []; // neighbouring vertices aka \"adjacentVertices\"\n\n\t\t// these will be computed in computeEdgeCostAtVertex()\n\t\tthis.collapseCost = 0; // cost of collapsing this vertex, the less the better. aka objdist\n\t\tthis.collapseNeighbor = null; // best candinate for collapsing\n\n\t}\n\n\tVertex.prototype.addUniqueNeighbor = function ( vertex ) {\n\n\t\tpushIfUnique( this.neighbors, vertex );\n\n\t};\n\n\tVertex.prototype.removeIfNonNeighbor = function ( n ) {\n\n\t\tvar neighbors = this.neighbors;\n\t\tvar faces = this.faces;\n\n\t\tvar offset = neighbors.indexOf( n );\n\t\tif ( offset === - 1 ) return;\n\t\tfor ( var i = 0; i < faces.length; i ++ ) {\n\n\t\t\tif ( faces[ i ].hasVertex( n ) ) return;\n\n\t\t}\n\n\t\tneighbors.splice( offset, 1 );\n\n\t};\n\n\tSimplifyModifier.prototype.modify = function ( geometry, count ) {\n\n\t\tif ( geometry.isBufferGeometry ) {\n\n\t\t\tgeometry = new THREE.Geometry().fromBufferGeometry( geometry );\n\n\t\t}\n\n\t\tgeometry.mergeVertices();\n\n\t\tvar oldVertices = geometry.vertices; // Three Position\n\t\tvar oldFaces = geometry.faces; // Three Face\n\n\t\t// conversion\n\t\tvar vertices = [];\n\t\tvar faces = [];\n\n\t\tvar i, il;\n\n\t\t//\n\t\t// put data of original geometry in different data structures\n\t\t//\n\n\t\t// add vertices\n\n\t\tfor ( i = 0, il = oldVertices.length; i < il; i ++ ) {\n\n\t\t\tvar vertex = new Vertex( oldVertices[ i ], i );\n\t\t\tvertices.push( vertex );\n\n\t\t}\n\n\t\t// add faces\n\n\t\tfor ( i = 0, il = oldFaces.length; i < il; i ++ ) {\n\n\t\t\tvar face = oldFaces[ i ];\n\n\t\t\tvar a = face.a;\n\t\t\tvar b = face.b;\n\t\t\tvar c = face.c;\n\n\t\t\tvar triangle = new Triangle( vertices[ a ], vertices[ b ], vertices[ c ], a, b, c );\n\t\t\tfaces.push( triangle );\n\n\t\t}\n\n\t\t// compute all edge collapse costs\n\n\t\tfor ( i = 0, il = vertices.length; i < il; i ++ ) {\n\n\t\t\tcomputeEdgeCostAtVertex( vertices[ i ] );\n\n\t\t}\n\n\t\tvar nextVertex;\n\n\t\tvar z = count;\n\n\t\twhile ( z -- ) {\n\n\t\t\tnextVertex = minimumCostEdge( vertices );\n\n\t\t\tif ( ! nextVertex ) {\n\n\t\t\t\tconsole.log( 'THREE.SimplifyModifier: No next vertex' );\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tcollapse( vertices, faces, nextVertex, nextVertex.collapseNeighbor );\n\n\t\t}\n\n\t\t//\n\n\t\tvar simplifiedGeometry = new THREE.BufferGeometry();\n\t\tvar position = [];\n\t\tvar index = [];\n\n\t\t//\n\n\t\tfor ( i = 0; i < vertices.length; i ++ ) {\n\n\t\t\tvar vertex = vertices[ i ].position;\n\t\t\tposition.push( vertex.x, vertex.y, vertex.z );\n\n\t\t}\n\n\t\t//\n\n\t\tfor ( i = 0; i < faces.length; i ++ ) {\n\n\t\t\tvar face = faces[ i ];\n\n\t\t\tvar a = vertices.indexOf( face.v1 );\n\t\t\tvar b = vertices.indexOf( face.v2 );\n\t\t\tvar c = vertices.indexOf( face.v3 );\n\n\t\t\tindex.push( a, b, c );\n\n\t\t}\n\n\t\t//\n\n\t\tsimplifiedGeometry.addAttribute( 'position', new THREE.Float32BufferAttribute( position, 3 ) );\n\t\tsimplifiedGeometry.setIndex( index );\n\n\t\treturn simplifiedGeometry;\n\n\t};\n\n} )();\n","import * as THREE from 'three'\nimport {vectors2, vectors, quaternions, matrices, traverse, V_000, V_001, V_010} from '../utils'\nimport {ConvexGeometry} from './ConvexGeometry'\nimport {SimplifyModifier} from './SimplifyModifier'\n\nexport class SimplifiedHull {\n    static hulls = new WeakMap<THREE.Geometry|THREE.BufferGeometry, THREE.Geometry|undefined>()\n  \n    static compute(geometry:THREE.Geometry|THREE.BufferGeometry, maxPoints = 30) {\n      const bufferGeometry = (geometry as THREE.BufferGeometry).type === 'BufferGeometry' ? \n        geometry as THREE.BufferGeometry : null\n      const normalGeometry = bufferGeometry ? \n        new THREE.Geometry().fromBufferGeometry(bufferGeometry) : geometry as THREE.Geometry\n      if (normalGeometry.vertices.length < maxPoints) {\n        this.hulls.set(geometry, normalGeometry)\n        return normalGeometry\n      }\n    \n      const modifier = new (SimplifyModifier as any)()\n      let hull = new ConvexGeometry(normalGeometry.vertices) as THREE.Geometry\n      const count = hull.vertices.length\n      if (count > maxPoints) {\n        const simplified = modifier.modify( hull, hull.vertices.length - maxPoints )\n        hull = new THREE.Geometry().fromBufferGeometry(simplified)\n      }\n      this.hulls.set(geometry, hull)\n      return hull\n    } \n    \n    static get(geometry:THREE.Geometry|THREE.BufferGeometry) {\n        return this.hulls.get(geometry) || geometry\n    }\n}\n\nexport class Box3 extends THREE.Box3 {\n    objectFilter? = SpatialMetrics.objectFilter\n    objectExpansion = 'box' as 'geometry'|'hull'|'box'\n    coordinateSystem = undefined as THREE.Object3D|undefined\n\n    private _objectExpandFunction:(o:THREE.Object3D)=>void\n\n    private _onObjectTraverse( node: THREE.Object3D, ) {\n        if (this.objectFilter && !this.objectFilter(node)) return false\n        this._objectExpandFunction.call(this, node)\n        return true\n    }\n\n    setFromObject( object:THREE.Object3D ) {\n\n        this.makeEmpty()\n\n        switch (this.objectExpansion) {\n            case 'geometry': this._objectExpandFunction = this.expandByObjectGeometry; break;\n            case 'hull': this._objectExpandFunction = this.expandByObjectHull; break;\n            case 'box':   \n            default: this._objectExpandFunction = this.expandByObjectBox; break;\n        }\n\n        this._objectExpandFunction.call(this, object)\n        for (const c of object.children) {\n            traverse(c, this._onObjectTraverse, this)\n        }\n\n        return this\n    }\n\n    private _vector = new THREE.Vector3\n    private _mat4 = new THREE.Matrix4\n\n    expandByObjectGeometry ( node: THREE.Object3D ) {\n        let i, l\n        const vector = this._vector\n        const mesh = node as THREE.Mesh\n\t\tnode.updateWorldMatrix( false, false )\n\t\tvar geometry = mesh.geometry as THREE.Geometry&THREE.BufferGeometry\n\t\tif ( geometry !== undefined ) {\n            const mat = this._getCoordinateSystemTransform(node)\n\t\t\tif ( geometry.isGeometry ) {\n\t\t\t\tvar vertices = geometry.vertices\n\t\t\t\tfor ( i = 0, l = vertices.length; i < l; i ++ ) {\n\t\t\t\t\tvector.copy( vertices[ i ] )\n\t\t\t\t\tvector.applyMatrix4( mat )\n\t\t\t\t\tthis.expandByPoint( vector )\n\t\t\t\t}\n\t\t\t} else if ( geometry.isBufferGeometry ) {\n\t\t\t\tvar attribute = geometry.attributes.position\n\t\t\t\tif ( attribute !== undefined ) {\n\t\t\t\t\tfor ( i = 0, l = attribute.count; i < l; i ++ ) {\n\t\t\t\t\t\tvector.fromBufferAttribute( attribute as any, i ).applyMatrix4( mat )\n\t\t\t\t\t\tthis.expandByPoint( vector )\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn this\n    }\n\n    expandByObjectHull( node: THREE.Object3D ) {\n        const mesh = node as THREE.Mesh\n        const vector = this._vector\n        let geometry = mesh.geometry\n        if (!geometry) return this\n        const mat = this._getCoordinateSystemTransform(node) \n        geometry = SimplifiedHull.get(geometry)\n        if (geometry && 'vertices' in geometry) {\n            const vertices = geometry.vertices    \n            for (let i = 0; i < vertices.length; ++i) {\n                const v = vertices[i]\n                vector.copy( v ).applyMatrix4( mat )\n                this.expandByPoint( vector )\n            }\n        } else {\n            const vertices = geometry.getAttribute('position')  \n            for (let i = 0; i < vertices.count; i+=vertices.itemSize) {\n                vector.set( vertices.getX(i), vertices.getY(i), vertices.getZ(i) ).applyMatrix4( mat )\n                this.expandByPoint( vector )\n            }\n        }\n        return this\n    }\n\n    private _box = new THREE.Box3\n\n    expandByObjectBox ( node:THREE.Object3D ) {\n        const box = this._box\n        const mesh = node as THREE.Mesh\n        const geometry = mesh.geometry\n        if (!geometry) return this\n        if ( geometry.boundingBox === null ) {\n            geometry.computeBoundingBox()\n        }\n        box.copy( geometry.boundingBox )\n        box.applyMatrix4( this._getCoordinateSystemTransform(node) )\n        this.union( box )\n        return this\n    }\n\n    private _getCoordinateSystemTransform(node: THREE.Object3D) {\n        const mat4 = this._mat4\n        if (this.coordinateSystem) {\n            mat4.getInverse(this.coordinateSystem.transitioner.matrixWorldTarget).multiply( node.transitioner.matrixWorldTarget )\n        } else {\n            mat4.copy( node.transitioner.matrixWorldTarget )\n        }\n        return mat4\n    }\n\n    private _center = new THREE.Vector3\n    private _size = new THREE.Vector3\n\n    relativeToAbsolute(relativePosition:THREE.Vector3, out = relativePosition) {\n        if (!this.isEmpty()) {\n            const center = this._center\n            const size = this._size\n            this.getCenter(center)\n            this.getSize(size)\n            out.copy(relativePosition).multiplyScalar(0.5).multiply(size).add(center)\n        } else {\n            out.copy(relativePosition).multiplyScalar(0)\n        }\n        // if (!isFinite(out.x)) out.x = 0\n        // if (!isFinite(out.y)) out.y = 0\n        // if (!isFinite(out.z)) out.z = 0\n        return out\n    }\n\n    absoluteToRelative(absolutePosition:THREE.Vector3, out = absolutePosition) {\n        if (!this.isEmpty()) {  \n            const center = this._center\n            const size = this._size\n            this.getCenter(center)\n            this.getSize(size)\n            out.copy(absolutePosition).sub(center).divide(size).multiplyScalar(2)\n        } else {\n            out.copy(absolutePosition).multiplyScalar(0)\n        }\n        // if (!isFinite(out.x)) out.x = 0\n        // if (!isFinite(out.y)) out.y = 0\n        // if (!isFinite(out.z)) out.z = 0\n        return out\n    }\n\n    isEmpty() {\n        return !isFinite(this.min.x) && !isFinite(this.min.y) && !isFinite(this.min.z) &&\n        !isFinite(this.max.x) && !isFinite(this.max.y) && !isFinite(this.max.z)\n    }\n}\n\nconst rotateY180 = new THREE.Quaternion().setFromAxisAngle(V_010, Math.PI)\n\n/**\n * A visual viewing frustum, with angles specified in DEGREES\n */\nexport class VisualFrustum {\n    \n    objectFilter? = SpatialMetrics.objectFilter\n    objectExpansion = 'box' as 'geometry'|'hull'|'box'\n    private _objectExpandFunction:(o:THREE.Object3D)=>void\n\n    min = new THREE.Vector3(Infinity,Infinity,Infinity)\n    max = new THREE.Vector3(-Infinity,-Infinity,-Infinity)\n    minClamped = new THREE.Vector3\n    maxClamped = new THREE.Vector3\n\n    minClamp?:THREE.Vector3\n    maxClamp?:THREE.Vector3\n\n    constructor(public coordinateSystem: THREE.Object3D) {}\n\n    get left() {\n        if (this.isEmpty()) return 0\n        return this.min.x\n    }\n\n    get leftClamped() {\n        if (this.isEmpty()) return 0\n        return this.minClamped.x\n    } \n\n    get top() {\n        if (this.isEmpty()) return 0\n        return this.max.y\n    }\n\n    get topClamped() {\n        if (this.isEmpty()) return 0\n        return this.maxClamped.y\n    }\n\n    get right() {\n        if (this.isEmpty()) return 0\n        return this.max.x   \n    }\n\n    get rightClamped() {\n        if (this.isEmpty()) return 0\n        return this.maxClamped.x   \n    }\n\n    get bottom() {\n        if (this.isEmpty()) return 0\n        return this.min.y\n    }\n\n    get bottomClamped() {\n        if (this.isEmpty()) return 0\n        return this.minClamped.y \n    }\n\n    get near() {\n        if (this.isEmpty()) return 0\n        return this.min.z\n    }\n\n    get nearClamped() {\n        if (this.isEmpty()) return 0\n        return this.minClamped.z\n    }\n\n    get far() {\n        if (this.isEmpty()) return 0\n        return this.max.z\n    }\n\n    get farClamped() {\n        if (this.isEmpty()) return 0\n        return this.maxClamped.z\n    }\n\n    get horizontal() {\n        if (this.isEmpty()) return 0\n        return this.right - this.left\n    }\n\n    get horizontalClamped() {\n        if (this.isEmpty()) return 0\n        return this.rightClamped - this.leftClamped\n    }\n\n    get vertical() {\n        if (this.isEmpty()) return 0\n        return this.top - this.bottom\n    }\n\n    get verticalClamped() {\n        if (this.isEmpty()) return 0\n        return this.topClamped - this.bottomClamped\n    }\n\n    get depth() {\n        if (this.isEmpty()) return 0\n        return this.far - this.near\n    }\n\n    get depthClamped() {\n        if (this.isEmpty()) return 0\n        return this.farClamped - this.nearClamped\n    }\n\n    get diagonal() {\n        if (this.isEmpty()) return 0\n        const minDirection = SpatialMetrics.getCartesianForSphericalDirection(this.min, vectors.get())\n        const maxDirection = SpatialMetrics.getCartesianForSphericalDirection(this.max, vectors.get())\n        const diagonal = minDirection.angleTo(maxDirection)\n        vectors.pool(minDirection)\n        vectors.pool(maxDirection)\n        return diagonal * THREE.Math.RAD2DEG\n    }\n\n    get diagonalClamped() {\n        if (this.isEmpty()) return 0\n        const minDirection = SpatialMetrics.getCartesianForSphericalDirection(this.minClamped, vectors.get())\n        const maxDirection = SpatialMetrics.getCartesianForSphericalDirection(this.maxClamped, vectors.get())\n        const diagonal = minDirection.angleTo(maxDirection)\n        vectors.pool(minDirection)\n        vectors.pool(maxDirection)\n        return diagonal * THREE.Math.RAD2DEG\n    }\n\n\tisEmpty(){\n\t\treturn this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z\n\t}\n\n    getCenter(out:THREE.Vector3) {\n        return out.set( \n            this.right - this.horizontal / 2, \n            this.top - this.vertical / 2,\n            this.far - this.depth / 2,\n        )\n    }\n\n    getClampedCenter(out:THREE.Vector3) {\n        return out.set( \n            this.rightClamped - this.horizontalClamped / 2, \n            this.topClamped - this.verticalClamped / 2,\n            this.farClamped - this.depthClamped / 2,\n        )\n    }\n\n    getSize(out:THREE.Vector3) {\n        return out.set(\n            this.horizontal, \n            this.vertical, \n            this.depth\n        )\n    }\n\n    getClampedSize(out:THREE.Vector3) {\n        return out.set(\n            this.horizontalClamped, \n            this.verticalClamped, \n            this.depthClamped\n        )\n    }\n\n    getPositionForOffset(offset:THREE.Vector3, out:THREE.Vector3) {\n        const center = this.getCenter(vectors.get())\n        const size = this.getSize(vectors.get())\n        out.copy(offset).multiplyScalar(0.5).multiply(size).add(center)\n        vectors.pool(center)\n        vectors.pool(size)\n        return out\n    }\n\n    getClampedPositionForOffset(offset:THREE.Vector3, out:THREE.Vector3) {\n        const center = this.getClampedCenter(vectors.get())\n        const size = this.getClampedSize(vectors.get())\n        out.copy(offset).multiplyScalar(0.5).multiply(size).add(center)\n        vectors.pool(center) \n        vectors.pool(size)\n        return out\n    }\n    \n    setFromPerspectiveProjectionMatrix(projectionMatrix:THREE.Matrix4) {\n        const inverseProjection = matrices.get().getInverse(projectionMatrix)\n        const vec = vectors.get()\n        this.min.x = -vec.set(-1,0,-1).applyMatrix4(inverseProjection).angleTo(V_001) * THREE.Math.RAD2DEG\n        this.max.x = vec.set(1,0,-1).applyMatrix4(inverseProjection).angleTo(V_001) * THREE.Math.RAD2DEG\n        this.min.y = -vec.set(0,-1,-1).applyMatrix4(inverseProjection).angleTo(V_001) * THREE.Math.RAD2DEG\n        this.max.y = vec.set(0,1,-1).applyMatrix4(inverseProjection).angleTo(V_001) * THREE.Math.RAD2DEG\n        this.min.z = -vec.set(0,0,-1).applyMatrix4(inverseProjection).z\n        this.max.z = -vec.set(0,0,1).applyMatrix4(inverseProjection).z\n        matrices.pool(inverseProjection)\n        vectors.pool(vec)\n        this._applyClamping()\n    }\n\n    makeEmpty() {\n        this.min.set(Infinity,Infinity,Infinity)\n        this.max.set(-Infinity,-Infinity,-Infinity)\n    }\n\n    setFromObject( object:THREE.Object3D ) {\n\n        this.makeEmpty()\n\n        switch (this.objectExpansion) {\n            case 'geometry': //this._objectExpandFunction = this.expandByObjectGeometry; break;\n            case 'hull': this._objectExpandFunction = this.expandByObjectHull; break;\n            case 'box':   \n            default: this._objectExpandFunction = this.expandByObjectBox; break;\n        }\n\n        this._objectExpandFunction.call(this, object)\n        for (const c of object.children) {\n            traverse(c, this._onObjectTraverse, this)\n        }\n\n        return this\n    }\n    \n    private _onObjectTraverse( node: THREE.Object3D, ) {\n        if (this.objectFilter && !this.objectFilter(node)) return false\n        this._objectExpandFunction.call(this, node)\n        return true\n    }\n\n    private _vec3 = new THREE.Vector3\n    private _mat4 = new THREE.Matrix4\n\n    private expandByObjectHull(object:THREE.Object3D) {\n        const m = object as THREE.Mesh\n        if (!m.isMesh) return\n\n        const coordinateSystem = this.coordinateSystem\n        const vertexPosition = this._vec3\n        const localToReferenceFrame = this._mat4.getInverse(coordinateSystem.matrixWorld).multiply(m.matrixWorld)\n        const hull = SimplifiedHull.get(m.geometry)!\n        const metrics = SpatialMetrics.get(coordinateSystem)\n\n        if ('vertices' in hull) {\n            for (const vertex of hull.vertices) {\n                vertexPosition.copy(vertex).applyMatrix4(localToReferenceFrame)\n                const vertexVisualPosition = metrics.getVisualPositionForCartesianPosition(vertexPosition, vertexPosition)\n                this.min.min(vertexVisualPosition)\n                this.max.max(vertexVisualPosition)\n            }\n        } else {\n            const vertices = hull.getAttribute('position')\n            for (let i = 0; i < vertices.count; i += vertices.itemSize) {\n                vertexPosition.set(vertices.getX(i), vertices.getY(i), vertices.getZ(i)).applyMatrix4(localToReferenceFrame)\n                const vertexVisualPosition = metrics.getVisualPositionForCartesianPosition(vertexPosition, vertexPosition)\n                this.min.min(vertexVisualPosition)\n                this.max.max(vertexVisualPosition)\n            }\n        }\n\n        this._applyClamping()\n    }\n\n    private _boxPoints = [\n        new THREE.Vector3(),\n        new THREE.Vector3(),\n        new THREE.Vector3(),\n        new THREE.Vector3(),\n        new THREE.Vector3(),\n        new THREE.Vector3(),\n        new THREE.Vector3(),\n        new THREE.Vector3()\n    ] as THREE.Vector3[]\n\n    expandByObjectBox ( node:THREE.Object3D ) {\n        const mat4 = this._mat4\n        const mesh = node as THREE.Mesh\n        const geometry = mesh.geometry\n        if (!geometry) return this\n\n        if ( geometry.boundingBox === null ) {\n            geometry.computeBoundingBox()\n        }\n    \n        const box = geometry.boundingBox\n        const points = this._boxPoints\n\t\tpoints[ 0 ].set( box.min.x, box.min.y, box.min.z ) // 000\n\t\tpoints[ 1 ].set( box.min.x, box.min.y, box.max.z ) // 001\n\t\tpoints[ 2 ].set( box.min.x, box.max.y, box.min.z ) // 010\n\t\tpoints[ 3 ].set( box.min.x, box.max.y, box.max.z ) // 011\n\t\tpoints[ 4 ].set( box.max.x, box.min.y, box.min.z ) // 100\n\t\tpoints[ 5 ].set( box.max.x, box.min.y, box.max.z ) // 101\n\t\tpoints[ 6 ].set( box.max.x, box.max.y, box.min.z ) // 110\n        points[ 7 ].set( box.max.x, box.max.y, box.max.z ) // 111\n\n        const coordinateSystem = this.coordinateSystem\n        const metrics = SpatialMetrics.get(coordinateSystem)\n        const localToReferenceFrame = mat4.getInverse(coordinateSystem.matrixWorld).multiply(mesh.matrixWorld)\n\n        for (const p of points) {\n            p.applyMatrix4(localToReferenceFrame)\n            const vertexVisualPosition = metrics.getVisualPositionForCartesianPosition(p, p)\n            this.min.min(vertexVisualPosition)\n            this.max.max(vertexVisualPosition)\n        }\n        \n        this._applyClamping()\n    }\n\n    private _applyClamping() {\n        this.minClamped.copy(this.min)\n        this.maxClamped.copy(this.max)\n        if (this.minClamp) this.minClamped.min(this.minClamp)\n        if (this.maxClamp) this.maxClamped.max(this.maxClamp)\n    }\n\n}\n\n/**\n * Calculate spatial metrics between a primary object and a target object.\n *\n * The results are always in one of two *local* coordinate systems:\n * `object-space` -\n *      Local *cartesian* coordinate system [X,Y,Z]. By convention, this local coordinate system is\n *      interpreted in two different ways, depending on whether or not the object is a camera:\n *          Typical objects: [+X = left, +Y = up, +Z = forward]\n *          Camera objects: [+X = right, +Y = up, -Z = forward]\n * `visual-space` -\n *      Local *spherical* coordinate system [azimuth, elevation, distance], where:\n *          `azimuth` (-180 to 180 DEGREES) an angle around the horizontal plane\n *              (increasing from left to right, with 0deg being aligned with this object's natural `forward` vector)\n *          `elevation` (-90 to 90 DEGREES ) an angle above or below the horizontal plane\n *              (increases from below to above, with 0deg at the horizon)\n *          `distance` is distance along the direction defined by the azimuth and elevation\n *      Unlike object-space, visual-space is consistent for camera and non-camera objects.\n */\nexport class SpatialMetrics {\n\n    public matrixWorldGetter = 'target' as 'current' | 'target'\n\n    private static _metrics = new WeakMap<THREE.Object3D, SpatialMetrics>()\n\n    public static objectFilter = (o:THREE.Object3D) => !o.layout.isBoundingContext()\n\n    static get(o:THREE.Object3D) {\n        if (this._metrics.has(o)) return this._metrics.get(o)!\n        this._metrics.set(o, new SpatialMetrics(o))\n        return this._metrics.get(o)!\n    }\n\n    static getCartesianForSphericalDirection(sphericalDirection: THREE.Vector2|THREE.Vector3, out: THREE.Vector3) { \n        const visualElevationRadians = THREE.Math.DEG2RAD * sphericalDirection.y\n        const visualAzimuthRadians = THREE.Math.DEG2RAD * sphericalDirection.x\n        const y = Math.sin(visualElevationRadians)\n        const x = Math.cos(visualElevationRadians) * Math.sin(visualAzimuthRadians)\n        const z = - Math.cos(visualElevationRadians) * Math.cos(visualAzimuthRadians)\n        out.set(x, y, z).normalize()\n        return out\n    }\n\n    static getSphericalDirectionForCartesian(cartesian: THREE.Vector3, out: THREE.Vector2) {\n        const direction = vectors.get().copy(cartesian).normalize()\n        out.y = Math.asin(direction.y) * THREE.Math.RAD2DEG\n        out.x = Math.atan2(direction.x, -direction.z) * THREE.Math.RAD2DEG\n        vectors.pool(direction)\n        return out\n    }\n\n    static getSphericalPositionForCartesian(cartesian: THREE.Vector3, out: THREE.Vector3) {\n        const distance = cartesian.length()\n        const direction = out.copy(cartesian).normalize()\n        out.y = Math.asin(direction.y) * THREE.Math.RAD2DEG\n        out.x = Math.atan2(direction.x, -direction.z) * THREE.Math.RAD2DEG\n        out.z = distance\n        return out\n    }\n\n    static getCartesianForSphericalPosition(sphericalPosition:THREE.Vector3, out: THREE.Vector3) {\n        const distance = sphericalPosition.z\n        const visualDirection = vectors2.get().set(sphericalPosition.x, sphericalPosition.y)\n        SpatialMetrics.getCartesianForSphericalDirection(visualDirection, out).multiplyScalar(distance)\n        vectors2.pool(visualDirection)\n        return out\n    }\n\n    private constructor(public object: THREE.Object3D) {}\n\n    private getMatrixWorld(o:THREE.Object3D) {\n        return this.matrixWorldGetter === 'current' ? \n            o.matrixWorld : o.transitioner.matrixWorldTarget\n    }\n\n    getCartesianForVisualDirection(visualDirection: THREE.Vector2, out: THREE.Vector3) {\n        SpatialMetrics.getCartesianForSphericalDirection(visualDirection, out)\n        if (!(this.object as THREE.Camera).isCamera) { out.applyQuaternion(rotateY180) }\n        return out\n    }\n\n    getVisualDirectionForCartesian(cartesian: THREE.Vector3, out: THREE.Vector2) {\n        const cartesianPosition = vectors.get().copy(cartesian)\n        if (!(this.object as THREE.Camera).isCamera) { cartesianPosition.applyQuaternion(rotateY180) }\n        SpatialMetrics.getSphericalDirectionForCartesian(cartesianPosition, out)\n        vectors.pool(cartesianPosition)\n        return out\n    }\n\n    getVisualPositionForCartesianPosition(cartesianPosition: THREE.Vector3, out: THREE.Vector3) {\n        const position = out.copy(cartesianPosition)\n        if (!(this.object as THREE.Camera).isCamera) { position.applyQuaternion(rotateY180) }\n        SpatialMetrics.getSphericalPositionForCartesian(position, out)\n        return out\n    }\n\n    getCartesianForVisualPosition(visualPosition:THREE.Vector3, out: THREE.Vector3) {\n        const distance = visualPosition.z\n        const visualDirection = vectors2.get().set(visualPosition.x, visualPosition.y)\n        this.getCartesianForVisualDirection(visualDirection, out).multiplyScalar(distance)\n        vectors2.pool(visualDirection)\n        return out\n    }\n\n    /**\n     * Calculate the local position of target in `object space`\n     */\n    getPositionOf(target: THREE.Object3D, out: THREE.Vector3) {\n        out.setFromMatrixPosition(this.getMatrixWorld(target))  \n        const invMatrixWorld = matrices.get().getInverse(this.getMatrixWorld(this.object))\n        out.applyMatrix4(invMatrixWorld)\n        matrices.pool(invMatrixWorld)\n        return out\n    }\n\n    /**\n     * Calculate the local distance of the target object\n     * (Note: this is the same for both `object-space` and `visual-space`)\n     */\n    getDistanceOf(target: THREE.Object3D) {\n        const vec = vectors.get()\n        const result = this.getPositionOf(target, vec).length()\n        vectors.pool(vec)\n        return result\n    }\n\n    /**\n     * Calculate the local direction of the target object in `object-space`\n     *\n     * Remember, by convention:\n     *     Normal objects: [+X = left, +Y = up, +Z = forward]\n     *     Camera objects: [+X = right, +Y = up, -Z = forward]\n     * Special Case: if both objects are at the same *exact* position,\n     *      the result is a `forward` vector ([0,0,-1] for cameras, [0,0,1] for other objects)\n     */\n    getDirectionOf(target: THREE.Object3D, out: THREE.Vector3) {\n        const position = this.getPositionOf(target, out)\n        const distance = position.lengthSq()\n        if (distance === 0 || !isFinite(distance)) { // if distance is 0\n            if ((this.object as THREE.Camera).isCamera) { return out.set(0, 0, -1) }\n            return out.set(0, 0, 1)\n        }\n        return position.normalize()\n    }\n\n    /**\n     * Get the world direction of the target object.\n     *\n     * Special Case: if both objects are at the same *exact* position,\n     *      the result is a `forward` vector ([0,0,-1] for cameras, [0,0,1] for other objects),\n     *      transformed into world coordinates\n     */\n    getWorldDirectionOf(target: THREE.Object3D, out: THREE.Vector3) {\n        return this.getDirectionOf(target, out).transformDirection(this.getMatrixWorld(this.object))\n    }\n\n    getClosestOrthogonalOrientationOf(target: THREE.Object3D, out: THREE.Quaternion) {\n        const o = this.object\n        const viewToObjectMat = (o ? matrices.get().getInverse(this.getMatrixWorld(o)) : matrices.get())\n                .multiply(this.getMatrixWorld(target))\n        const mat = viewToObjectMat.extractRotation(viewToObjectMat)\n        const orientation = out.setFromRotationMatrix(mat)\n\n        const forwardDirection = vectors.get().set(0,0,1).applyQuaternion(orientation)\n        const upDirection = vectors.get().set(0,1,0).applyQuaternion(orientation)\n\n        let distForward = Infinity\n        let distUp = Infinity\n        let closestForwardDirection!:THREE.Vector3\n        let closestUpDirection!:THREE.Vector3\n\n        for (const dir of directions) {\n            let dist = upDirection.distanceToSquared(dir)\n            if (dist < distUp) {\n                distUp = dist\n                closestUpDirection = dir\n            }\n        }\n\n        for (const dir of directions) {\n            // avoid having forward & up defined on the same axis\n            if (dir.x && closestUpDirection.x) continue\n            if (dir.y && closestUpDirection.y) continue\n            if (dir.z && closestUpDirection.z) continue\n            let dist = forwardDirection.distanceToSquared(dir)\n            if (dist < distForward) {\n                distForward = dist\n                closestForwardDirection = dir\n            }\n        }\n\n        mat.identity()\n        mat.lookAt(closestForwardDirection, V_000, closestUpDirection)\n        orientation.setFromRotationMatrix(mat)\n        matrices.pool(mat)\n        o.updateMatrixWorld()\n    }\n\n    /**\n     * Set a position for the *target object*,\n     * based on the visual-space of *this object*.\n     *\n     * If the object has no bounding sphere, or if a visualSize is not specified,\n     * then the current distance will be assumed.\n     *\n     * @param target\n     * @param visualDirection the desired visual direction to the target\n     * @param visualSize the desired visual size of the target (in DEGREES)\n     * @param alpha a linear interpolation value (default is 1)\n     */\n    // setPositionFor( target: THREE.Object3D,\n    //                 visualDirection: THREE.Vector2,\n    //                 visualSize?: number,\n    //                 alpha = 1) {\n    //     let distance: number\n    //     if (typeof visualSize === 'number' && visualSize > 0) {\n    //         distance = this.computeDistanceFor(target, visualSize)\n    //     } else {\n    //         distance = this.getDistanceOf(target)\n    //     }\n    //     const start = vectors.get().copy(target.position)\n    //     const end = target.position\n    //     this.getCartesianForVisualDirection(visualDirection, end)\n    //     end.transformDirection(this.object.matrixWorld).multiplyScalar(distance)\n    //     target.parent && target.parent.worldToLocal(end)\n    //     target.position.copy(start.lerp(end, alpha))\n    //     vectors.pool(start)\n    // }\n\n    /**\n     * Set a new scale for the target that\n     * would make it have the desired visual size\n     * in this object's `visual-space`.\n     *\n     * @param target\n     * @param visualSize the desired visual size of the target (in DEGREES)\n     * @param alpha a linear interpolation value (default is 1)\n     */\n    // setScaleFor(target: THREE.Object3D, visualSize: number, alpha = 1) {\n    //     const idealDistance = this.computeDistanceFor(target, visualSize)\n    //     const currentDistance = this.getDistanceOf(target)\n    //     const distanceScale = idealDistance / currentDistance\n    //     const start = vectors.get().copy(target.scale)\n    //     const end = target.scale\n    //     if (isFinite(distanceScale)) { end.multiplyScalar(distanceScale) }\n    //     target.scale.copy(start.lerp(end, alpha))\n    //     vectors.pool(start)\n    // }\n\n    // /**\n    //  * Perform a look-at operation on the target object, based\n    //  * on this object's local up direction.\n    //  * @param target\n    //  */\n    // setOrientationFor(target: THREE.Object3D, alpha = 1) {\n    //     const localObjectUp = vectors.get().set(0, 1, 0)\n    //     const savedTargetUp = vectors.get().copy(target.up)\n    //     const globalObjectUp = localObjectUp.transformDirection(this.object.matrixWorld)\n    //     target.up.copy(globalObjectUp)\n    //     const start = quaternions.get().copy(target.quaternion)\n    //     const lookAtVector = vectors.get().setFromMatrixPosition(this.object.matrixWorld)\n    //     target.lookAt(lookAtVector)\n    //     target.up.copy(savedTargetUp)\n    //     const end = target.quaternion\n    //     target.quaternion.copy(start.slerp(end, alpha))\n    //     vectors.pool(localObjectUp, savedTargetUp, lookAtVector)\n    //     quaternions.pool(start)\n    // }\n\n\n    // computeDistanceFor(target: THREE.Object3D, visualSize: number): number {\n    //     if (visualSize < 0 || visualSize > 360) { throw new Error('Invalid visualSize, must be between [0-360]') }\n    //     const targetMatrixWorldInverse = matrices.get().getInverse(this.getMatrixWorld(target))\n    //     const frustum = this.getVisualFrustumOf(target)\n    //     return 0\n    //     // if (sphereRadius === 0) { return this.getDistanceOf(target) }\n\n    //     // if (visualSize > 180) {\n    //     //     // special case: linearly decrease distance with increasing visual size within the bounding sphere.\n    //     //     return (360 - visualSize / 180) * sphereRadius\n    //     // }\n\n    //     // // see https://stackoverflow.com/questions/21648630/radius-of-projected-sphere-in-screen-space\n    //     // return sphereRadius / Math.sin( THREE.Math.DEG2RAD * visualSize / 2 )\n    // }\n\n    getOrientationOf(target: THREE.Object3D, out: THREE.Quaternion) {\n        const rotMat = matrices.get()\n        const targetWorldOrientation = quaternions.get().setFromRotationMatrix(rotMat.extractRotation(this.getMatrixWorld(target)))\n        const inverseThisWorldOrientation = quaternions.get().setFromRotationMatrix(rotMat.extractRotation(this.getMatrixWorld(this.object))).inverse()\n        out.multiplyQuaternions(inverseThisWorldOrientation, targetWorldOrientation)\n        quaternions.pool(targetWorldOrientation) \n        quaternions.pool(inverseThisWorldOrientation)\n        matrices.pool(rotMat)\n        return out\n    } \n\n    /**\n     * Calculate the visual direction towards the target object.\n     * Assumes that a normal object faces +Z, and a camera faces -Z.\n     *\n     * If pointing directly towards the target object, the direction is [0,0] (forward)\n     * If pointing directly opposite of the target object, the direction is [0,-180] (backwards)\n     * Special Case: if both are at the same exact position, the direction is [0,0] (forward)\n     */\n    getVisualDirectionOf(target: THREE.Object3D, out: THREE.Vector2) {\n        const direction = this.getDirectionOf(target, vectors.get())\n        const visualDirection = this.getVisualDirectionForCartesian(direction, out)\n        vectors.pool(direction)\n        return visualDirection\n    }\n\n\n    /**\n     * Calculate the visual angle towards the target object.\n     * Assumes that a normal object faces +Z, and a camera faces -Z.\n     *\n     * If the target object is to the right of the forward vector, the angle is 0\n     * If the target object is above the forward vector, the angle is 90\n     * If the target object is to the left of the forward vector, then angle is 180\n     * If the target object is below the forward vector, the angle is 270\n     * If pointing directly towards the target object, the angle is 90 (up)\n     * If pointing directly opposite of the target object, the direction is [0,-180] (backwards)\n     * Special Case: if both are at the same exact position, the direction is [0,0] (forward)\n     */\n    getVisualAngleOf(target: THREE.Object3D, out: THREE.Vector2) {\n        const direction = this.getDirectionOf(target, vectors.get())\n        const visualDirection = this.getVisualDirectionForCartesian(direction, out)\n        vectors.pool(direction)\n        return visualDirection\n    }\n\n    /**\n     * Calculate the bounds of the target object, in the local `object-space` coordinate system. \n     * @param target \n     * @param out \n     */\n    getBoundsOf(target: THREE.Object3D, out = this._box) {\n        if (out === this._box) {\n            out.objectFilter = SpatialMetrics.objectFilter\n            out.objectExpansion = 'box'\n        }\n        out.coordinateSystem = this.object\n        return out.setFromObject(target)\n    }\n    private _box = new Box3\n\n\n    private _visualFrustum = new VisualFrustum(this.object)\n    getVisualFrustumOf(target: THREE.Object3D = this.object, out = this._visualFrustum) {\n        if (out === this._visualFrustum) out.objectFilter = SpatialMetrics.objectFilter\n        const camera = target as THREE.Camera\n        if (camera.isCamera) out.setFromPerspectiveProjectionMatrix(camera.projectionMatrix)\n        else out.setFromObject(target)\n        return out\n    }\n\n    // /**\n    //  * Calculate the visual bounds of the target object, in the local `visual-space` coordinate system\n    //  * @param target \n    //  * @param out \n    //  */\n    // getVisualBoundsOf(target: THREE.Object3D, out: VisualBounds) {\n    //     const direction = this.getDirectionOf(target, vectors.get())\n    //     const visualDirection = this.getVisualDirectionOf(target, vectors2.get())\n    //     const rotation = matrices.get().lookAt(V_000, direction, V_010)\n    //     const rotatedMatrixWorld = matrices.get().multiplyMatrices(rotation, this.object.matrixWorld)\n    //     const rotatedMatrixWorldInverse = rotatedMatrixWorld.getInverse(rotatedMatrixWorld)\n    //     _box.setFromObjectBoxes(target, rotatedMatrixWorldInverse)\n    //     this.getVisualPointFromCartesianPoint(_box.min, out.leftBottomNear)\n    //     this.getVisualPointFromCartesianPoint(_box.max, out.rightTopFar)\n        \n    //     matrices.pool(objectMatrixWorldInverse)\n    // }\n\n    /**\n     * Calculate the angular offset (in DEGREES) between this object's forward vector,\n     * and the direction towards the target object (as calculated by getDirectionOf).\n     * Assumes that a normal object faces +Z, and a camera faces -Z.\n     *\n     * If pointing directly towards the target object, the visual offset is 0\n     * If pointing directly opposite of the target object, the visual offset is 180\n     * Special Case: if both are at the same position, the visual offset is 180\n     */\n    getVisualOffsetOf(target: THREE.Object3D): number {\n        const direction = this.getDirectionOf(target, vectors.get())\n        if (!(this.object as THREE.Camera).isCamera) { direction.applyQuaternion(rotateY180) }\n        const result = V_001.angleTo(direction) * THREE.Math.RAD2DEG\n        vectors.pool(direction)\n        return result\n    }\n\n    /**\n     * Calculate the field of view of the target object as seen by this object.\n     *\n     * The `visual size` grows from 0 to 180 as the visual bouding box of the target grows in our\n     * field of view.\n     * Once we are inside the bounding box, the `visual size` continues to\n     * increase linearly, from 180 to 360 at the center of the bounding box.\n     * If the target object has no bounding sphere defined, the result is 0.\n     *\n     * @returns visual size of the target object in DEGREES, from [0-360], in horizontal and vertical dimensions\n     */\n    // getVisualSizeOf(target: THREE.Object3D, out:THREE.Vector2) {\n    //     const direction = this.getDirectionOf(target, vectors.get())\n    //     const rotation = matrices.get().lookAt(V_000, direction, V_010)\n    //     const rotatedMatrixWorld = matrices.get().multiplyMatrices(rotation, this.object.matrixWorld)\n    //     const rotatedMatrixWorldInverse = rotatedMatrixWorld.getInverse(rotatedMatrixWorld)\n    //     const facingBox = _box.setFromObjectBoxes(target, rotatedMatrixWorldInverse)\n    //     const facingBoxSize = facingBox.getSize(vectors.get())\n    //     // const linearSize = mode === 'horizontal' ? facingBoxSize.x : facingBoxSize.y\n    //     // const distance = this.getDistanceOf(target)\n    //     const near = \n    //     out.x = 2 * Math.atan2(facingBoxSize.x / 2, distance) * THREE.Math.RAD2DEG\n    //     out.y = 2 * Math.atan2(facingBoxSize.y / 2, distance) * THREE.Math.RAD2DEG\n    //     vectors.pool(direction, facingBoxSize)\n    //     matrices.pool(rotation, rotatedMatrixWorld)\n    //     return out\n\n    //     // const objectMatrixWorldInverse = matrices.get().getInverse(this.object.matrixWorld)\n    //     // _box.setFromObjectBoxes(target, objectMatrixWorldInverse)\n    //     // matrices.pool(objectMatrixWorldInverse)\n    //     // const sphere = _box.getBoundingSphere(_sphere)\n    //     // const sphereRadius = sphere.radius\n    //     // if (sphereRadius <= 0) { return 0 }\n    //     // const sphereDistance = this.getDistanceOf(target)\n    //     // if (sphereDistance <= sphereRadius) {\n    //     //     return 180 + (180 * sphereDistance / sphereRadius)\n    //     // } // we are inside the bounding sphere\n    //     // // see https://stackoverflow.com/questions/21648630/radius-of-projected-sphere-in-screen-space\n    //     // return 2 * Math.asin(sphereRadius / sphereDistance) * 180 / Math.PI\n    // }\n\n    // getVisualWidthOf(target: THREE.Object3D) {\n    //     const size = this.getVisualSizeOf(target, vectors2.get())\n    //     const width = size.x\n    //     vectors2.pool(size)\n    //     return width\n    // }\n\n    // getVisualHeightOf(target: THREE.Object3D) {\n    //     const size = this.getVisualSizeOf(target, vectors2.get())\n    //     const height = size.y\n    //     vectors2.pool(size)\n    //     return height\n    // }\n\n    // getVisualDiameterOf(target: THREE.Object3D) {\n    //     const size = this.getVisualSizeOf(target, vectors2.get())\n    //     const length = size.length()\n    //     vectors2.pool(size)\n    //     return length\n    // }\n\n    /**\n     * Calculate the perspective visual frustum which bounds the the target object.\n     * If no target is specified and the current object is a camera, returns \n     * a perspective visual frustum for the camera (assuming it is a perspective camera)\n     */\n    // getVisualFrustum(target:THREE.Object3D=this.object): VisualFrustum {\n    //     if (!this._visualFrustum) { this._visualFrustum =  new VisualFrustum }\n    //     const out = this._visualFrustum\n    //     const camera = this.object as THREE.Camera\n    //     if (camera.isCamera) { \n    //         const invProjection = matrices.get().getInverse(camera.projectionMatrix, true)\n    //         out.setFromBoundsMatrix(invProjection)\n    //         matrices.pool(invProjection)\n    //     } else {\n    //         const direction = this.getDirectionOf(target, vectors.get())\n    //         const rotation = matrices.get().lookAt(V_000, direction, V_010)\n    //         const rotatedMatrixWorld = matrices.get().multiplyMatrices(rotation, this.object.matrixWorld)\n    //         const rotatedMatrixWorldInverse = rotatedMatrixWorld.getInverse(rotatedMatrixWorld)\n    //         const facingBox = _box.setFromObjectBoxes(target, rotatedMatrixWorldInverse)\n    //         const facingBoxSize = facingBox.getSize(vectors.get())\n    //         const near = facingBox.min.z\n    //         const far = facingBox.max.z\n    //         const left = facingBox.min.x\n    //         out.x = 2 * Math.atan2(facingBoxSize.x / 2, distance) * THREE.Math.RAD2DEG\n    //         out.y = 2 * Math.atan2(facingBoxSize.y / 2, distance) * THREE.Math.RAD2DEG\n    //         matrices.get().makePerspective()\n    //     }\n    //     return out\n    // }\n\n}\n\n\nconst directions = [\n    new THREE.Vector3( 1, 0, 0),\n    new THREE.Vector3( 0, 1, 0), \n    new THREE.Vector3( 0, 0, 1), \n    new THREE.Vector3(-1, 0, 0), \n    new THREE.Vector3( 0,-1, 0), \n    new THREE.Vector3( 0, 0,-1), \n]\n\n\n// export function getMetrics(obj: THREE.Object3D) : SpatialMetrics {\n//     if (_metricsMap.has(obj)) return _metricsMap.get(obj)!\n//     const metrics = new SpatialMetrics(obj)\n//     _metricsMap.set(obj, metrics)\n//     return metrics\n// }","import * as THREE from 'three'\nimport { SpatialMetrics, Box3 } from '../metrics/SpatialMetrics'\nimport { matrices, vectors } from '../utils'\n\nexport const LayoutFit = {\n    contain: 'contain',\n    contain3d: 'contain3d',\n    cover: 'cover',\n    cover3d: 'cover3d',\n    fill: 'fill',\n    fill3d: 'fill3d',\n}\n\nconst FIT_CONTAIN_3D = {\n    contain: 0,\n    contain3d: 1,\n    cover: 0,\n    cover3d: 0,\n    fill: 0,\n    fill3d: 0,\n}\n\nexport type LayoutFitType = keyof typeof LayoutFit\n\nexport type LayoutX = number|'center'|'left'|'right'\nexport type LayoutY = number|'center'|'top'|'bottom'\nexport type LayoutZ = number|'center'|'front'|'back'\n\n\n/**\n * Extend THREE.Object3D functionality with 3D layout functionality.\n * \n * Features include:\n *  - automatic bounds computation\n *  - modify alignment, origin, and size with respect to bounds and parent bounds\n *  - pose & layout transitions\n */\nexport class Layout {\n\n    /**\n     * Force local layout bounds to be excluded from the parent bounding context \n     * (effectively, forces a new bounding context)\n     */\n    forceBoundsExclusion = false\n\n    /**\n     * Specifies the degree to which the layout properties (`absolute`, and `relative`) influence \n     * the final transform. At 0, the layout properties have no effect. At 1, they have\n     * their full intended effect. \n     */\n    weight = 1\n    \n    /**\n     * Specify absolute layout bounds. A mininum or maximum boundary\n     * can be set to `NaN` in any dimension to remain unspecified. \n     * \n     * Note: any specified `relative` and `absolute` bounds\n     * are combined to determine `computedBounds`\n     */\n    absolute =  new Box3\n\n    /**\n     * Specify relative layout bounds, with -1 to 1 spanning the \n     * range of `computedOuterBounds` for each dimension. A mininum or \n     * maximum boundary can be set to `NaN` in any dimension to remain \n     * unspecified. \n     * \n     * Note: any specified `relative` and `absolute` bounds\n     * are combined to determine `computedBounds`\n     */\n    relative = new Box3\n\n    /**\n     * Specify the orientation of the layout. Default is identity. \n     */\n    orientation = new THREE.Quaternion\n\n    /**\n     * \n     */\n    minRelativeSize = new THREE.Vector3\n\n    /**\n     * \n     */\n    minAbsoluteSize = new THREE.Vector3\n\n    /** \n     * Specifies how the object should fit within `absolute` and `relative` bounds,\n     * which determines the `computedBounds`\n    */\n    set fit(fit:LayoutFitType) {\n        this._fit = fit\n        for (const id in this.fitTargets) this.fitTargets[id as LayoutFitType] = 0\n        this.fitTargets[fit] = 1\n    }\n    get fit() {\n        return this._fit\n    }\n    private _fit = 'contain' as LayoutFitType\n\n    /** Used internally. */\n    fitTargets = {\n        contain: 1,\n        contain3d: 0,\n        cover: 0,\n        cover3d: 0,\n        fill: 0,\n        fill3d: 0,\n    }\n\n    /**\n     * \n     */\n    fitAlign = new THREE.Vector3\n\n    clip = new Box3\n\n    inner = new Box3\n    innerAutoUpdate = true\n\n    computedBounds = new Box3\n    computedInnerBounds = new Box3\n    computedOuterBounds = new Box3\n    computedClipBounds = new Box3\n\n    public matrix = new THREE.Matrix4\n\n    private _boundsValid = false\n\n    constructor(public object:THREE.Object3D) {\n        this.computedInnerBounds.objectFilter = SpatialMetrics.objectFilter\n        this.computedInnerBounds.objectExpansion = 'box'\n        this.computedInnerBounds.coordinateSystem = object\n    }\n\n    invalidateBounds() {\n        this._boundsValid = false\n    }\n\n    resetLayout() {\n        this.fit = 'contain'\n        this.absolute.makeEmpty()\n        this.relative.makeEmpty()\n    }\n\n    resetPose() {\n        this.object.position.setScalar(0)\n        this.object.quaternion.set(0,0,0,1)\n        this.object.scale.setScalar(1)\n    }\n\n    reset() {\n        this.resetLayout()\n        this.resetPose()\n    }\n\n    /**\n     * If true, the layout properties are effectively noop\n     */\n    isPassive() {\n        return this.absolute.isEmpty() && this.relative.isEmpty()\n    }\n\n    /**\n     * If true, the `object` should not be included in the bounding calculation\n     * for any parent layouts.\n     */\n    isBoundingContext() {\n        if (this.forceBoundsExclusion) return true\n        if (!this.isPassive()) {\n            this.forceBoundsExclusion = true\n            return true\n        }\n        return false\n    }\n\n    updateMatrix() {\n        const bounds = this.computedBounds\n        \n        if (this.isPassive()) {\n            this.matrix.identity()\n            return\n        }\n\n        if (!this._boundsValid) {\n            Layout.updateInnerBounds(this.object)\n            Layout.updateOuterBounds(this.object)\n            if (this.computedInnerBounds.isEmpty()) {\n                this.computedInnerBounds.copy(this.computedOuterBounds)\n            }\n            this._boundsValid = true\n        }\n\n        const {absolute, relative, fitTargets, orientation, computedInnerBounds, computedOuterBounds, clip} = this\n        \n        // combine relative and absolute bounds\n\n        bounds.makeEmpty()\n        computedOuterBounds.relativeToAbsolute(relative.min, bounds.min)\n        computedOuterBounds.relativeToAbsolute(relative.max, bounds.max)\n        if (isFinite(absolute.min.x)) bounds.min.x = (isFinite(bounds.min.x) ? bounds.min.x : 0) + absolute.min.x\n        if (isFinite(absolute.min.y)) bounds.min.y = (isFinite(bounds.min.y) ? bounds.min.y : 0) + absolute.min.y\n        if (isFinite(absolute.min.z)) bounds.min.z = (isFinite(bounds.min.z) ? bounds.min.z : 0) + absolute.min.z\n        if (isFinite(absolute.max.x)) bounds.max.x = (isFinite(bounds.max.x) ? bounds.max.x : 0) + absolute.max.x\n        if (isFinite(absolute.max.y)) bounds.max.y = (isFinite(bounds.max.y) ? bounds.max.y : 0) + absolute.max.y\n        if (isFinite(absolute.max.z)) bounds.max.z = (isFinite(bounds.max.z) ? bounds.max.z : 0) + absolute.max.z\n\n        // apply clip\n\n        if (!clip.isEmpty()) {\n            // const clipMax = vectors.get().copy(clip.max)//.subVectors(clip.max, bounds.max).min(V_000)\n            // const clipMin = vectors.get().copy(clip.min)//.subVectors(clip.min, bounds.min).max(V_000)\n            const clipMax = computedInnerBounds.absoluteToRelative(clip.max, vectors.get())//.subVectors(clip.max, bounds.max).min(V_000)\n            const clipMin = computedInnerBounds.absoluteToRelative(clip.min,Â vectors.get())//.subVectors(clip.min, bounds.min).max(V_000)\n            bounds.relativeToAbsolute(clipMax, clipMax)//.subVectors(clip.max, bounds.max).min(V_000)\n            bounds.relativeToAbsolute(clipMin, clipMin)//.subVectors(clip.min, bounds.min).max(V_000)\n            if (!isFinite(clipMax.x)) clipMax.x = Infinity\n            if (!isFinite(clipMax.y)) clipMax.y = Infinity\n            if (!isFinite(clipMax.z)) clipMax.z = Infinity\n            if (!isFinite(clipMin.x)) clipMin.x = -Infinity\n            if (!isFinite(clipMin.y)) clipMin.y = -Infinity\n            if (!isFinite(clipMin.z)) clipMin.z = -Infinity\n            bounds.max.min(clipMax)\n            bounds.min.max(clipMin)\n            vectors.pool(clipMax)\n            vectors.pool(clipMin)\n        }\n\n        // compute min size\n        const minSize = computedOuterBounds.getSize(vectors.get())\n            .multiply(this.minRelativeSize).max(this.minAbsoluteSize)\n\n        // compute final size\n        const innerSize = computedInnerBounds.getSize(vectors.get())\n        const layoutScale = bounds.getSize(vectors.get()).max(minSize).divide(innerSize)\n        Layout.adjustScaleForFit(fitTargets, layoutScale)\n        const finalSize = vectors.get().multiplyVectors(innerSize, layoutScale)\n        finalSize.x = Math.abs(finalSize.x)\n        finalSize.y = Math.abs(finalSize.y)\n        finalSize.z = Math.abs(finalSize.z)\n\n        if (!isFinite(bounds.min.x) && !isFinite(bounds.max.x)) {\n            bounds.max.x = finalSize.x / 2\n            bounds.min.x = - bounds.max.x\n        }\n        if (!isFinite(bounds.min.y) && !isFinite(bounds.max.y)) {\n            bounds.max.y = finalSize.y / 2\n            bounds.min.y = - bounds.max.y\n        }\n        if (!isFinite(bounds.min.z) && !isFinite(bounds.max.z)) {\n            bounds.max.z = finalSize.z / 2\n            bounds.min.z = - bounds.max.z\n        }\n        if (!isFinite(bounds.max.x)) bounds.max.x = bounds.min.x + finalSize.x\n        if (!isFinite(bounds.max.y)) bounds.max.y = bounds.min.y + finalSize.y\n        if (!isFinite(bounds.max.z)) bounds.max.z = bounds.min.z + finalSize.z\n        if (!isFinite(bounds.min.x)) bounds.min.x = bounds.max.x - finalSize.x\n        if (!isFinite(bounds.min.y)) bounds.min.y = bounds.max.y - finalSize.y\n        if (!isFinite(bounds.min.z)) bounds.min.z = bounds.max.z - finalSize.z\n\n        const orient = matrices.get().makeRotationFromQuaternion(orientation)\n        const halfFinalSize = finalSize.divideScalar(2)\n\n        const layoutAlignOffset = bounds.relativeToAbsolute(this.fitAlign, vectors.get())\n        bounds.min.copy(layoutAlignOffset).sub(halfFinalSize)\n        bounds.max.copy(layoutAlignOffset).add(halfFinalSize)\n        bounds.applyMatrix4(orient)\n\n        const innerAlignOffset = computedInnerBounds.relativeToAbsolute(this.fitAlign, vectors.get())\n        innerAlignOffset.multiply(layoutScale).applyMatrix4(orient)\n        bounds.min.sub(innerAlignOffset)\n        bounds.max.sub(innerAlignOffset)\n\n        // compose layout matrix\n\n        const layoutPosition = bounds.getCenter(vectors.get())\n        this.matrix.compose(layoutPosition, orientation, layoutScale)\n        \n        // cleanup\n\n        vectors.pool(innerSize)\n        vectors.pool(minSize)\n        vectors.pool(finalSize)\n        vectors.pool(layoutPosition)\n        vectors.pool(layoutScale)\n        vectors.pool(layoutAlignOffset)\n        // vectors.pool(innerAlignOffset)\n    }\n\n    public static updateInnerBounds(o:THREE.Object3D) {\n        const layout = o.layout\n        const bounds = layout.computedInnerBounds\n        if (layout._boundsValid) return bounds\n        bounds.coordinateSystem = o\n        bounds.setFromObject(o).union(layout.inner)\n        if (bounds.min.x === bounds.max.x) bounds.max.x += 1e-10\n        if (bounds.min.y === bounds.max.y) bounds.max.y += 1e-10\n        if (bounds.min.z === bounds.max.z) bounds.max.z += 1e-10\n        return bounds\n    }\n    \n    public static updateOuterBounds(o:THREE.Object3D) {\n        const layout = o.layout\n        const parentBounds = layout.computedOuterBounds\n\n        if (layout._boundsValid) return parentBounds\n\n        const parent = o.parent\n        const cameraParent = parent as THREE.Camera\n        if (cameraParent && cameraParent.isCamera) {\n            const position = vectors.get().setFromMatrixPosition(o.matrix)\n            const projectionMatrixInverse = matrices.get().getInverse(cameraParent.projectionMatrix)\n            const near = parentBounds.min.set(0,0,-1).applyMatrix4(projectionMatrixInverse).z\n            const far = parentBounds.min.set(0,0,1).applyMatrix4(projectionMatrixInverse).z\n            const projectionZ = parentBounds.min.set(0,0,position.z).applyMatrix4(cameraParent.projectionMatrix).z\n            parentBounds.min.set(-1, -1, projectionZ)\n            parentBounds.max.set(1, 1, projectionZ)\n            parentBounds.min.applyMatrix4(projectionMatrixInverse)\n            parentBounds.max.applyMatrix4(projectionMatrixInverse)\n            parentBounds.min.z = far\n            parentBounds.max.z = near\n            vectors.pool(position)\n            matrices.pool(projectionMatrixInverse)\n        } else if (parent) {\n            parentBounds.copy(parent.layout.computedInnerBounds)\n        } else {\n            parentBounds.makeEmpty()\n        }\n\n        const orient = matrices.get().makeRotationFromQuaternion(layout.orientation)\n        parentBounds.applyMatrix4(orient.getInverse(orient))\n        matrices.pool(orient)\n        return parentBounds\n    }\n\n    public static _fitScale = new THREE.Vector3\n    public static adjustScaleForFit(fitTargets:typeof Layout.prototype.fitTargets, sizeScale:THREE.Vector3) {\n        const fitScale = this._fitScale\n        const out = sizeScale\n        const min = 1e-10\n        const max = 1e10\n\n        if (!isFinite(out.x) && !isFinite(out.y) && !isFinite(out.z)) {\n            out.setScalar(1)\n            return out\n        }\n        \n        if (!isFinite(out.x)) out.x = max\n        if (!isFinite(out.y)) out.y = max\n        if (!isFinite(out.z)) out.z = max\n        out.x = out.x < 0 ? THREE.Math.clamp(out.x, -max, -min) : THREE.Math.clamp(out.x, min, max)\n        out.y = out.y < 0 ? THREE.Math.clamp(out.y, -max, -min) : THREE.Math.clamp(out.y, min, max)\n        out.z = out.z < 0 ? THREE.Math.clamp(out.z, -max, -min) : THREE.Math.clamp(out.z, min, max)\n        \n        const {x,y,z} = out\n        const ax = Math.abs(x)\n        const ay = Math.abs(y)\n        const az = Math.abs(z)\n\n        // fill3d: allow all dimensions to fill layout size\n        if (fitTargets.fill3d) {\n            // no-op\n        }\n\n        // fill (2D): set z to average of x and y\n        if (fitTargets.fill) {\n            fitScale.set(x, y, x + y / 2)\n            out.lerp(fitScale, fitTargets.fill)\n        }\n\n        // contain (2D): set all dimensions to smallest of x or y\n        if (fitTargets.contain) {\n            if (ax < ay) {\n                fitScale.set(x, x, x)\n            } else {\n                fitScale.set(y, y, y)\n            }\n            out.lerp(fitScale, fitTargets.contain)\n        }\n\n        // contain3d: set all dimensions to smallest of x or y or z\n        if (fitTargets.contain3d) {\n            if (ax < ay && ax < az) {\n                fitScale.set(x, x, x)\n            } else if (ay < ax && ay < az) {\n                fitScale.set(y, y, y)\n            } else {\n                fitScale.set(z, z, z)\n            }\n            out.lerp(fitScale, fitTargets.contain3d)\n        }\n\n        // cover (2D): set all dimensions to largest of x or y\n        if (fitTargets.cover) {\n            if (ax > ay) {\n                fitScale.set(x, x, x)\n            } else {\n                fitScale.set(y, y, y)\n            }\n            out.lerp(fitScale, fitTargets.cover)\n        }\n\n        // cover (3D): set all dimensions to largest of x or y or z\n        if (fitTargets.cover3d) {\n            if (ax > ay && ax > az) {\n                fitScale.set(x, x, x)\n            } else if (ay > ax && ay > az) {\n                fitScale.set(y, y, y)\n            } else {\n                fitScale.set(z, z, z)\n            }\n            out.lerp(fitScale, fitTargets.cover3d)\n        }\n\n        // clamp between 1e-10 and 1e10\n        if (!isFinite(out.x)) out.x = min\n        if (!isFinite(out.y)) out.y = min\n        if (!isFinite(out.z)) out.z = min\n        out.x = out.x < 0 ? THREE.Math.clamp(out.x, -max, -min) : THREE.Math.clamp(out.x, min, max)\n        out.y = out.y < 0 ? THREE.Math.clamp(out.y, -max, -min) : THREE.Math.clamp(out.y, min, max)\n        out.z = out.z < 0 ? THREE.Math.clamp(out.z, -max, -min) : THREE.Math.clamp(out.z, min, max)\n        return out\n    }\n}\n\n// function isNaN(a:number) {\n//     return a !== a\n// }","var DEFAULT_OVERSHOOT_STRENGTH = 1.525;\nvar reversed = function (easing) {\n    return function (p) {\n        return 1 - easing(1 - p);\n    };\n};\nvar mirrored = function (easing) {\n    return function (p) {\n        return p <= 0.5 ? easing(2 * p) / 2 : (2 - easing(2 * (1 - p))) / 2;\n    };\n};\nvar createReversedEasing = reversed;\nvar createMirroredEasing = mirrored;\nvar createExpoIn = function (power) {\n    return function (p) {\n        return Math.pow(p, power);\n    };\n};\nvar createBackIn = function (power) {\n    return function (p) {\n        return p * p * ((power + 1) * p - power);\n    };\n};\nvar createAnticipateEasing = function (power) {\n    var backEasing = createBackIn(power);\n    return function (p) {\n        return (p *= 2) < 1 ? 0.5 * backEasing(p) : 0.5 * (2 - Math.pow(2, -10 * (p - 1)));\n    };\n};\nvar linear = function (p) {\n    return p;\n};\nvar easeIn = /*#__PURE__*/createExpoIn(2);\nvar easeOut = /*#__PURE__*/reversed(easeIn);\nvar easeInOut = /*#__PURE__*/mirrored(easeIn);\nvar circIn = function (p) {\n    return 1 - Math.sin(Math.acos(p));\n};\nvar circOut = /*#__PURE__*/reversed(circIn);\nvar circInOut = /*#__PURE__*/mirrored(circOut);\nvar backIn = /*#__PURE__*/createBackIn(DEFAULT_OVERSHOOT_STRENGTH);\nvar backOut = /*#__PURE__*/reversed(backIn);\nvar backInOut = /*#__PURE__*/mirrored(backIn);\nvar anticipate = /*#__PURE__*/createAnticipateEasing(DEFAULT_OVERSHOOT_STRENGTH);\nvar BOUNCE_FIRST_THRESHOLD = 4.0 / 11.0;\nvar BOUNCE_SECOND_THRESHOLD = 8.0 / 11.0;\nvar BOUNCE_THIRD_THRESHOLD = 9.0 / 10.0;\nvar ca = 4356.0 / 361.0;\nvar cb = 35442.0 / 1805.0;\nvar cc = 16061.0 / 1805.0;\nvar bounceOut = function (p) {\n    var p2 = p * p;\n    return p < BOUNCE_FIRST_THRESHOLD ? 7.5625 * p2 : p < BOUNCE_SECOND_THRESHOLD ? 9.075 * p2 - 9.9 * p + 3.4 : p < BOUNCE_THIRD_THRESHOLD ? ca * p2 - cb * p + cc : 10.8 * p * p - 20.52 * p + 10.72;\n};\nvar bounceIn = function (p) {\n    return 1.0 - bounceOut(1.0 - p);\n};\nvar bounceInOut = function (p) {\n    return p < 0.5 ? 0.5 * (1.0 - bounceOut(1.0 - p * 2.0)) : 0.5 * bounceOut(p * 2.0 - 1.0) + 0.5;\n};\nvar NEWTON_ITERATIONS = 8;\nvar NEWTON_MIN_SLOPE = 0.001;\nvar SUBDIVISION_PRECISION = 0.0000001;\nvar SUBDIVISION_MAX_ITERATIONS = 10;\nvar K_SPLINE_TABLE_SIZE = 11;\nvar K_SAMPLE_STEP_SIZE = 1.0 / (K_SPLINE_TABLE_SIZE - 1.0);\nvar FLOAT_32_SUPPORTED = typeof Float32Array !== 'undefined';\nvar a = function (a1, a2) {\n    return 1.0 - 3.0 * a2 + 3.0 * a1;\n};\nvar b = function (a1, a2) {\n    return 3.0 * a2 - 6.0 * a1;\n};\nvar c = function (a1) {\n    return 3.0 * a1;\n};\nvar getSlope = function (t, a1, a2) {\n    return 3.0 * a(a1, a2) * t * t + 2.0 * b(a1, a2) * t + c(a1);\n};\nvar calcBezier = function (t, a1, a2) {\n    return ((a(a1, a2) * t + b(a1, a2)) * t + c(a1)) * t;\n};\nfunction cubicBezier(mX1, mY1, mX2, mY2) {\n    var sampleValues = FLOAT_32_SUPPORTED ? new Float32Array(K_SPLINE_TABLE_SIZE) : new Array(K_SPLINE_TABLE_SIZE);\n    var binarySubdivide = function (aX, aA, aB) {\n        var i = 0;\n        var currentX;\n        var currentT;\n        do {\n            currentT = aA + (aB - aA) / 2.0;\n            currentX = calcBezier(currentT, mX1, mX2) - aX;\n            if (currentX > 0.0) {\n                aB = currentT;\n            } else {\n                aA = currentT;\n            }\n        } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);\n        return currentT;\n    };\n    var newtonRaphsonIterate = function (aX, aGuessT) {\n        var i = 0;\n        var currentSlope = 0;\n        var currentX;\n        for (; i < NEWTON_ITERATIONS; ++i) {\n            currentSlope = getSlope(aGuessT, mX1, mX2);\n            if (currentSlope === 0.0) {\n                return aGuessT;\n            }\n            currentX = calcBezier(aGuessT, mX1, mX2) - aX;\n            aGuessT -= currentX / currentSlope;\n        }\n        return aGuessT;\n    };\n    var calcSampleValues = function () {\n        for (var i = 0; i < K_SPLINE_TABLE_SIZE; ++i) {\n            sampleValues[i] = calcBezier(i * K_SAMPLE_STEP_SIZE, mX1, mX2);\n        }\n    };\n    var getTForX = function (aX) {\n        var intervalStart = 0.0;\n        var currentSample = 1;\n        var lastSample = K_SPLINE_TABLE_SIZE - 1;\n        var dist = 0.0;\n        var guessForT = 0.0;\n        var initialSlope = 0.0;\n        for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {\n            intervalStart += K_SAMPLE_STEP_SIZE;\n        }\n        --currentSample;\n        dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);\n        guessForT = intervalStart + dist * K_SAMPLE_STEP_SIZE;\n        initialSlope = getSlope(guessForT, mX1, mX2);\n        if (initialSlope >= NEWTON_MIN_SLOPE) {\n            return newtonRaphsonIterate(aX, guessForT);\n        } else if (initialSlope === 0.0) {\n            return guessForT;\n        } else {\n            return binarySubdivide(aX, intervalStart, intervalStart + K_SAMPLE_STEP_SIZE);\n        }\n    };\n    calcSampleValues();\n    var resolver = function (aX) {\n        var returnValue;\n        if (mX1 === mY1 && mX2 === mY2) {\n            returnValue = aX;\n        } else if (aX === 0) {\n            returnValue = 0;\n        } else if (aX === 1) {\n            returnValue = 1;\n        } else {\n            returnValue = calcBezier(getTForX(aX), mY1, mY2);\n        }\n        return returnValue;\n    };\n    return resolver;\n}\n\nexport { reversed, mirrored, createReversedEasing, createMirroredEasing, createExpoIn, createBackIn, createAnticipateEasing, linear, easeIn, easeOut, easeInOut, circIn, circOut, circInOut, backIn, backOut, backInOut, anticipate, bounceOut, bounceIn, bounceInOut, cubicBezier };\n","import * as THREE from 'three'\nimport { vectors2, vectors, quaternions, matrices, V_00, V_000, Q_IDENTITY } from '../utils'\nimport * as easing from '@popmotion/easing'\n\nexport {easing}\n\nfunction defined(...obj:any[]) {\n    for (const o of obj) {\n        if (typeof o !== 'undefined') return o\n    }\n}\n\ntype WidenLiteral<T> = T extends number ? number : T\n\nexport type Multiplier<T> = number | (T extends THREE.Matrix4 ? {position?:number,scale?:number,quaternion?:number} : never)\n\nexport class TransitionTarget<T extends ValueType = ValueType>{\n    constructor(\n        public value: T,\n        public duration: number,\n        public easing: (number) => number\n    ) {}\n    public elapsed: 0\n}\n\ntype ValueTypes = number|THREE.Vector2|THREE.Vector3|THREE.Quaternion|THREE.Color|THREE.Matrix4|THREE.Box3\nexport type ValueType<T extends ValueTypes=ValueTypes> = WidenLiteral<T>\n\nexport type ValueRange<T> = T extends THREE.Vector2|THREE.Vector3 ? T : \n    T extends THREE.Matrix4|THREE.Box3 ? THREE.Vector3 : \n    T extends number ? number : never\n\nexport type TransitionableConstructorKeys = \n    'target'|'multiplier'|'duration'|'easing'|'threshold'|\n    'delay'|'debounce'|'maxWait'\nexport type TransitionerConstructOptions<T extends ValueType> = Pick<Transitionable<T>, TransitionableConstructorKeys>\n\nexport type TransitionableConfig = Pick<Transitionable<ValueType>,'delay'|'debounce'|'maxWait'|'multiplier'|'duration'|'easing'|'threshold'>\n\nexport class Transitionable<T extends ValueType = ValueType> {\n\n    constructor(config:TransitionerConstructOptions<T>) {\n        Object.assign(this, config)\n        const t = this.target\n        if (typeof this.current === 'undefined') \n            this.current = (typeof t === 'number' ? t : (t as any).clone()) as  WidenLiteral<T>\n        if (typeof this.start === 'undefined') \n            this.start = (typeof t === 'number' ? t : (t as any).clone()) as  WidenLiteral<T>\n    }\n\n    /**\n     * The desired target value\n     */\n    target: WidenLiteral<T>\n\n    /**\n     * The current value\n     */\n    current : WidenLiteral<T>\n\n    /**\n     * The start value\n     */\n    start : WidenLiteral<T>\n    \n    /**\n     * The typical range of the target value, used to determine percentage change\n     */\n    range: ValueRange<T>\n    /**\n     * The target value awaiting to be added to the `targetQueue`\n     */\n    committedTarget?: WidenLiteral<T>\n    /**\n     * A multiplier to influence the speed of the transition\n     */\n    multiplier?: number = undefined\n    /**\n     * The duration of the easing function\n     */\n    duration?: number  = undefined\n    /**\n     * The easing function \n     */\n    easing?: (alpha:number) => number = undefined\n    /**\n     * The percentage that the `target` must differ from the `committedTarget`, \n     * the last target added to the `targetQueue`, or the `current` value  (in  that order)\n     * before it is considered \"changed\". Depends on `range` being defined. \n     */\n    threshold?: number = undefined\n    /**\n     * The number of seconds in which the `target` value must remain \"changed\" before it\n     * becomes the `committedTarget`\n     */\n    delay?: number = undefined\n    /**\n     * The number of seconds in which the `committedTarget` must \n     * remain stable before it is pushed to the `targetQueue`\n     */\n    debounce?: number = undefined\n    /**\n     * The maximum number of seconds to wait before the `committedTarget`\n     * is pushed to the `targetQueue`\n     */\n    maxWait?: number = undefined\n    /**\n     * The queue of committed target values that are still influencing the current value\n     * (whose durations have not yet been exceeded)\n     */\n    targetQueue: TransitionTarget<WidenLiteral<T>>[] = []\n\n    _delayTime = 0\n    _debounceTime = 0\n    _waitTime = 0\n\n    _changePercent = 0\n\n    /**\n     * \n     */\n    update(deltaTime:number, c?:TransitionableConfig, changePercent?:number) {\n        const config = this._updateConfig(c)\n        const queue = this.targetQueue\n        const target = this.target\n        this._changePercent = changePercent = typeof changePercent === 'number' ? changePercent : this._computePercentChange()\n        deltaTime *= config.multiplier\n        \n        if (changePercent > config.threshold) {\n            if (this._delayTime > config.delay) {\n                if (typeof target === 'number') this.committedTarget = target as any\n                else {\n                    if (this.committedTarget) (this.committedTarget as any).copy(target)\n                    else this.committedTarget = (target as any).clone()\n                }\n                this._delayTime = 0\n                this._debounceTime = 0\n            }\n            this._delayTime += deltaTime\n        } else {\n            if (typeof this.committedTarget !== 'undefined') this._delayTime = 0\n            this._debounceTime += deltaTime\n        }\n\n        if (this.committedTarget) this._waitTime += deltaTime\n\n        if (this.committedTarget && (this._debounceTime > config.debounce || this._waitTime > config.maxWait)) {\n            queue.push({\n                value: this.committedTarget,\n                easing: config.easing,\n                duration: config.duration,\n                elapsed: 0\n            })\n            this.committedTarget = undefined\n            this._waitTime = 0\n        }\n        \n        while (queue.length && queue[0].elapsed > queue[0].duration) {\n            this.start = queue.shift()!.value\n        }\n        \n        this._setCurrent(this.start)\n        let previousTarget = this.start\n        for (const target of queue) {\n            target.elapsed += deltaTime\n            this._addTargetInfluence(previousTarget, target)\n            previousTarget = target.value\n        }\n    }\n\n    private static _c = new THREE.Color\n    private static _cBlack = new THREE.Color(0,0,0)\n\n    private _addTargetInfluence(start:WidenLiteral<T>, target:TransitionTarget<WidenLiteral<T>>) {\n        const alpha = target.duration > 0 ? target.easing( Math.min(target.elapsed, target.duration) / target.duration) : 1\n\n        if (typeof target.value !== 'number' && 'isMatrix4' in target.value) {\n            const c = this.current as THREE.Matrix4\n            const s = start as THREE.Matrix4\n            const e = target.value as THREE.Matrix4\n\n            const pos = vectors.get()\n            const quat = quaternions.get()\n            const scale = vectors.get()\n            c.decompose(pos, quat, scale)\n\n            const sPos = vectors.get()\n            const sQuat = quaternions.get()\n            const sScale = vectors.get()\n            s.decompose(sPos, sQuat, sScale)\n    \n            const tPos = vectors.get()\n            const tQuat = quaternions.get()\n            const tScale = vectors.get()\n            e.decompose(tPos, tQuat, tScale)\n    \n            pos.add(tPos.sub(sPos).lerp(V_000, 1-alpha))\n            quat.multiply(sQuat.inverse().multiply(tQuat).slerp(Q_IDENTITY, 1-alpha)).normalize()\n            scale.add(tScale.sub(sScale).lerp(V_000, 1-alpha))\n    \n            vectors.pool(pos)\n            quaternions.pool(quat)\n            vectors.pool(scale)\n            vectors.pool(sPos)\n            quaternions.pool(sQuat)\n            vectors.pool(sScale)\n            vectors.pool(tPos)\n            quaternions.pool(tQuat)\n            vectors.pool(tScale)\n            return\n        }\n\n        if (typeof target.value === 'number') {\n            this.current += THREE.Math.lerp(0, target.value-(startÂ as number), alpha) as any\n            return\n        } \n        \n        if ('isVector3' in target.value) {\n            const c = this.current as THREE.Vector3\n            const s = start as THREE.Vector3\n            const e = target.value as THREE.Vector3\n            const amount = vectors.get().copy(e).sub(s).lerp(V_000, 1-alpha)\n            c.add(amount)\n            vectors.pool(amount)\n            return\n        } \n        \n        if ('isVector2' in target.value) {\n            const c = this.current as THREE.Vector2\n            const s = start as THREE.Vector2\n            const e = target.value as THREE.Vector2\n            const amount = vectors2.get().copy(e).sub(s).lerp(V_00, 1-alpha)\n            c.add(amount)\n            vectors2.pool(amount)\n            return\n        } \n        \n        if ('isQuaternion' in target.value) {\n            const c = this.current as THREE.Quaternion\n            const s = start as THREE.Quaternion\n            const e = target.value as THREE.Quaternion\n            const amount = quaternions.get().copy(s).inverse().multiply(e).slerp(Q_IDENTITY, 1-alpha)\n            c.multiply(amount).normalize()\n            quaternions.pool(amount)\n            return\n        } \n        \n        if ('isColor' in target.value) {\n            const c = this.current as THREE.Color\n            const s = start as THREE.Color\n            const e = target.value as THREE.Color\n            const amount = Transitionable._c.copy(e).sub(s).lerp(Transitionable._cBlack, 1-alpha)\n            c.add(amount)\n            return\n        } \n        \n        if ('isBox3' in target.value) {\n            const c = this.current as THREE.Box3\n            const s = start as THREE.Box3\n            const e = target.value as THREE.Box3\n            const minAmount = vectors.get().copy(e.min).sub(s.min).lerp(V_000, 1-alpha)\n            const maxAmount = vectors.get().copy(e.max).sub(s.max).lerp(V_000, 1-alpha)\n            if (isFinite(c.min.x)) c.min.x = 0\n            if (isFinite(c.min.y)) c.min.y = 0\n            if (isFinite(c.min.z)) c.min.z = 0\n            if (isFinite(c.max.x)) c.max.x = 0\n            if (isFinite(c.max.y)) c.max.y = 0\n            if (isFinite(c.max.z)) c.max.z = 0\n            c.min.add(minAmount)\n            c.max.add(maxAmount)\n            return\n        }\n    }\n\n    _setCurrent(value:WidenLiteral<T>) {\n        if (typeof value === 'number') {\n            this.current = value\n        } else {\n            (this.current as any).copy(value)\n        }\n    }\n\n    _computePercentChange() {\n\n        const end = this.target as ValueType\n        const start = this.committedTarget || (this.targetQueue[0] && this.targetQueue[0].value) || this.current\n\n        if (typeof start === 'number') {\n            const s = start as number\n            const e = end as number\n            return Math.abs(e - s / ((this.range as number) || 1))\n        } \n\n        if ('isMatrix4' in start) {\n            const s = start as THREE.Matrix4\n            const e = end as THREE.Matrix4\n            const sPos = vectors.get()\n            const sQuat = quaternions.get()\n            const sScale = vectors.get()\n            s.decompose(sPos, sQuat, sScale)\n            const ePos = vectors.get()\n            const eQuat = quaternions.get()\n            const eScale = vectors.get()\n            e.decompose(ePos, eQuat, eScale)\n\n            const posPercent = sPos.equals(ePos) ? 0 : Infinity\n\n            const quatPercent = Math.abs(sQuat.angleTo(eQuat) / Math.PI)\n\n            const scalePercent = sScale.equals(eScale) ? 0 : Infinity\n            \n            vectors.pool(sPos)\n            quaternions.pool(sQuat)\n            vectors.pool(sScale)\n            vectors.pool(ePos)\n            quaternions.pool(eQuat)\n            vectors.pool(eScale)\n\n            return Math.max(posPercent, quatPercent, scalePercent)\n        }\n        \n        if ('isVector3' in start) {\n            const s = start as THREE.Vector3\n            const e = end as THREE.Vector3\n            if (!this.range) return e.equals(s) ? 0 : Infinity\n            const percent = vectors.get().subVectors(e, s).divide(this.range as THREE.Vector3)\n            const {x,y,z} = percent\n            vectors.pool(percent)\n            return Math.max(Math.abs(x||0),Math.abs(y||0),Math.abs(z||0))\n        } \n        \n        if ('isVector2' in start) {\n            const s = start as THREE.Vector2\n            const e = end as THREE.Vector2\n            if (!this.range) return e.equals(s) ? 0 : Infinity\n            const percent = vectors2.get().subVectors(e, s).divide(this.range as THREE.Vector2)\n            const {x,y} = percent\n            vectors2.pool(percent)\n            return Math.max(Math.abs(x||0),Math.abs(y||0))\n        } \n        \n        if ('isQuaternion' in start) {\n            const s = start as THREE.Quaternion\n            const e = end as THREE.Quaternion\n            return Math.abs(s.angleTo(e) / Math.PI)\n        } \n        \n        if ('isColor' in start) {\n            const s = start as THREE.Color\n            const e = end as THREE.Color\n            return Math.max(\n                Math.abs(e.r - s.r), \n                Math.abs(e.g - s.r), \n                Math.abs(e.b - s.r)\n            )\n        } \n        \n        if ('isBox3' in start) {\n            const s = start as THREE.Box3\n            const e = end as THREE.Box3\n            if (!this.range) return e.equals(s) ? 0 : Infinity\n            const size = this.range as ValueRange<THREE.Box3>\n            const minPercent = vectors.get().subVectors(e.min, s.min).divide(size)\n            const maxPercent = vectors.get().subVectors(e.max, s.max).divide(size)\n            const min = Math.max(Math.abs(minPercent.x||0), Math.abs(minPercent.y||0), Math.abs(minPercent.z||0))\n            const max = Math.max(Math.abs(maxPercent.x||0), Math.abs(maxPercent.y||0), Math.abs(maxPercent.z||0))\n            vectors.pool(minPercent)\n            vectors.pool(maxPercent)\n            return Math.max(min, max)\n        }\n\n        return Infinity\n    }\n\n    protected _config = {} as Required<TransitionableConfig>\n\n    protected _updateConfig(c?:TransitionableConfig) {\n        this._config.multiplier = defined(this.multiplier, c && c.multiplier, Transitioner.DEFAULT_CONFIG.multiplier)\n        this._config.duration = defined(this.duration, c && c.duration, Transitioner.DEFAULT_CONFIG.duration)\n        this._config.easing = defined(this.easing, c && c.easing, Transitioner.DEFAULT_CONFIG.easing)\n        this._config.threshold = defined(this.threshold, c && c.threshold, Transitioner.DEFAULT_CONFIG.threshold)\n        this._config.delay = defined(this.delay, c && c.delay, Transitioner.DEFAULT_CONFIG.delay)\n        this._config.debounce = defined(this.debounce, c && c.debounce, Transitioner.DEFAULT_CONFIG.debounce) \n        this._config.maxWait = defined(this.maxWait, c && c.maxWait, Transitioner.DEFAULT_CONFIG.maxWait)\n        return this._config\n    }\n\n}\n\nexport class LocalMatrixTransitionable extends Transitionable<THREE.Matrix4> {\n    constructor(public object:THREE.Object3D) {\n        super({ target: new THREE.Matrix4 })\n    }\n\n    position = new Transitionable({target: new THREE.Vector3})\n    quaternion = new Transitionable({target: new THREE.Quaternion})\n    scale = new Transitionable({target: new THREE.Vector3(1,1,1)})\n\n    autoRange = true\n    synchronizeComponents = true\n\n    update(deltaTime:number, c?:TransitionableConfig) {\n        this._updateConfig(c)\n        const {position, quaternion, scale, _config} = this\n\n        if (this.autoRange) {\n            if (!position.range) position.range = new THREE.Vector3\n            if (!scale.range) scale.range = new THREE.Vector3\n            this.object.layout.computedOuterBounds.getSize(position.range)\n            this.object.layout.computedOuterBounds.getSize(scale.range).divide(position.range)\n            if (!isFinite(scale.range.x) || scale.range.x === 0) scale.range.x = 1\n            if (!isFinite(scale.range.y) || scale.range.y === 0) scale.range.y = 1\n            if (!isFinite(scale.range.z) || scale.range.z === 0) scale.range.z = 1\n        }\n        \n        this.target.decompose(position.target, quaternion.target, scale.target)\n        this.current.decompose(position.current, quaternion.current, scale.current)\n        \n        let changePercent:number|undefined = undefined\n        if (this.synchronizeComponents) {\n            changePercent = Math.max(\n                position._computePercentChange(), \n                quaternion._computePercentChange(), \n                scale._computePercentChange()\n            )\n        }\n\n        position.update(deltaTime, _config, changePercent)\n        quaternion.update(deltaTime, _config, changePercent)\n        scale.update(deltaTime, _config, changePercent)\n        this.current.compose(position.current, quaternion.current, scale.current)\n    }\n}\n\n/**\n * Enables smooth interpolation of various kinds of values, with hysteresis\n */\nexport class Transitioner {\n\n    static disableAllTransitions = false\n\n    static DEFAULT_CONFIG:Required<TransitionableConfig> = {\n        multiplier: 1,\n        duration: 1.5,\n        easing: easing.easeInOut,\n        threshold: 1e-2,\n        delay: 0,\n        debounce: 0,\n        maxWait: 10\n    }\n\n    /**\n     * The amount of time (in milliseconds) it takes to smoothly \n     * damp towards the target.\n     * \n     * By defualt, based on a progress threshold of 0.96\n     * \n     * progress = 1 - Math.exp(-time)\n     * time = - Math.log(1-progress)\n     */\n    static NATURAL_DURATION = - Math.log(1 - 0.95)\n    \n    /**\n     * \n     */\n    set active(active:boolean) {\n        this._active = active\n    }\n    get active() {\n        return this._active && !Transitioner.disableAllTransitions\n    }\n    private _active = false\n\n    /**\n     * Specifies the desired parent coordinate system.\n     */\n    parentTarget : THREE.Object3D|null = null\n\n    /**\n     * The local matrix transitionable\n     */\n    matrixLocal:LocalMatrixTransitionable\n    \n    /**\n     * The target world matrix, automatically computed from pose/layout properties\n     */\n    matrixWorldTarget = new THREE.Matrix4\n\n    /**\n     * A multiplier to influence the speed of the transition\n     */\n    multiplier? : number = undefined\n    \n    /**\n     * The duration of the easing function\n     */\n    duration? : number = undefined\n\n    /**\n     * The easing function \n     */\n    easing? : (alpha:number) => number = undefined\n\n    /**\n     * The percentage that the `target` must differ from the `committedTarget`, \n     * the last target added to the `targetQueue`, or the `current` value  (in  that order)\n     * before it is considered \"changed\"\n     */\n    threshold? : number = undefined\n\n    /**\n     * The number of seconds in which the `target` value must remain \"changed\" before it\n     * becomes the `committedTarget`\n     */\n    delay? : number = undefined\n\n    /**\n     * The number of seconds in which the `committedTarget` must \n     * remain stable before it is pushed to the `targetQueue`\n     */\n    debounce? : number = undefined\n\n    /**\n     * The maximum number of seconds to wait before the `committedTarget`\n     * is pushed to the `targetQueue`\n     */\n    maxWait? : number = undefined\n\n    /**\n     * \n     */\n    customTransitionables = [] as Transitionable[]\n\n    /**\n     * \n     * @param object \n     */\n    constructor(public object:THREE.Object3D) {\n        this.matrixLocal = new LocalMatrixTransitionable(this.object)\n    }\n\n    /**\n     * Add a transitionable\n     * @param transitionable \n     */\n    add<T extends ValueType>(transitionable:TransitionerConstructOptions<T>|Transitionable<T>) : Transitionable<T> {\n        const t = transitionable instanceof Transitionable ? \n            transitionable : new Transitionable(transitionable)\n        this.customTransitionables.push(t)\n        return t\n    }\n\n    /**\n     * Transitions pose, layout, and/or custom properties associated with an Object3D instance.\n     * \n     * When the transitioner is active, the object's pose (`position`, `quaternion`, and `scale`)\n     * and layout (`layout.absolute`, `layout.relative`, etc.) properties are treated as \n     * target values, and their corresponding target matrices are maintained in the transitioner \n     * instance (e.g., `transitioner.matrix`, `transitioner.layoutMatrix`). Meanwhile, the object's \n     * pose/layout matrices (`matrix` and `layout.matrix`) will only be updated when this `update` \n     * method is called).\n     * \n     * If `targetParent` is set and differs from the current `object.parent`, \n     * this method will smoothly switch to the new coordinate system. \n     */\n    update(deltaTime:number, autoActive=true) {\n\n        if (!this.active && autoActive) this.active = true\n\n        if (!this.active) { \n            this.matrixLocal.current.copy(this.matrixLocal.target)\n            for (const t of this.customTransitionables) {\n                t._setCurrent(t.target)\n            }\n            return\n        }\n\n        // refresh matrix targets if necessary\n        if (autoActive) this.object.updateWorldMatrix(true, true)\n        this._setParent()\n\n        // update transitionables\n        deltaTime = Math.max(deltaTime, 1e-10) // in case multiplier is Infinity\n        this.matrixLocal.update(deltaTime, this)\n        for (const t of this.customTransitionables) {\n            t.update(deltaTime, this)\n        }\n\n        this.object.updateWorldMatrix(false, true)\n    }\n\n    /**\n     * Ensure that this `object` is attached to the `targetParent` Object3D instance. \n     * When the `transitioner` is active, this method ensures a smooth transition \n     * to another coordinate system. If the `object` is already attached to the \n     * `targetParent`, this method is effectively noop.\n     */\n    private _setParent() {\n        const parent = this.parentTarget\n        const o = this.object\n        if (!parent) return\n        if (o.parent !== parent) {\n            o.updateWorldMatrix(true, true)\n            const originalMatrixWorld = matrices.get().copy(o.matrixWorld)\n            o.parent && o.parent.remove(o)\n            parent && parent.add(o)\n            parent.updateWorldMatrix(true, true)\n            const inverseParentMatrixWorld = parent ? matrices.get().getInverse(parent.matrixWorld) : matrices.get().identity()\n            o.matrix.copy(inverseParentMatrixWorld.multiply(originalMatrixWorld))\n            // const transitioner = o.layout.transitioner\n            // if (transitioner.active) {\n            //     transitioner.layout.weight = 0\n            //     o.matrix.decompose(transitioner.position, transitioner.quaternion, transitioner.scale)\n            // } else {\n            // }\n            o.matrix.decompose(o.position, o.quaternion, o.scale)\n            matrices.pool(originalMatrixWorld)\n            matrices.pool(inverseParentMatrixWorld)\n        }\n    }\n}\n\n// function resolve(path:string, obj=self as any, separator='.') {\n//     var properties = Array.isArray(path) ? path : path.split(separator)\n//     return properties.reduce((prev, curr) => prev && prev[curr], obj)\n// }\n\n// function set(path:string, obj=self as any, value:any, separator='.') {\n//     var properties = Array.isArray(path) ? path : path.split(separator)\n//     var lastPropertKey = properties.pop()\n//     const property = properties.reduce((prev, curr) => prev && prev[curr], obj)\n//     property[lastPropertKey] = value\n// }","import { Vector3, Vector2, Triangle, DoubleSide, BackSide, Face3 } from 'three';\r\n\r\n// Ripped and modified From THREE.js Mesh raycast\r\n// https://github.com/mrdoob/three.js/blob/0aa87c999fe61e216c1133fba7a95772b503eddf/src/objects/Mesh.js#L115\r\nvar vA = new Vector3();\r\nvar vB = new Vector3();\r\nvar vC = new Vector3();\r\n\r\nvar uvA = new Vector2();\r\nvar uvB = new Vector2();\r\nvar uvC = new Vector2();\r\n\r\nvar intersectionPoint = new Vector3();\r\nvar intersectionPointWorld = new Vector3();\r\n\r\nfunction checkIntersection( object, material, raycaster, ray, pA, pB, pC, point ) {\r\n\r\n\tvar intersect;\r\n\tif ( material.side === BackSide ) {\r\n\r\n\t\tintersect = ray.intersectTriangle( pC, pB, pA, true, point );\r\n\r\n\t} else {\r\n\r\n\t\tintersect = ray.intersectTriangle( pA, pB, pC, material.side !== DoubleSide, point );\r\n\r\n\t}\r\n\r\n\tif ( intersect === null ) return null;\r\n\r\n\tintersectionPointWorld.copy( point );\r\n\tintersectionPointWorld.applyMatrix4( object.matrixWorld );\r\n\r\n\tvar distance = raycaster.ray.origin.distanceTo( intersectionPointWorld );\r\n\r\n\tif ( distance < raycaster.near || distance > raycaster.far ) return null;\r\n\r\n\treturn {\r\n\t\tdistance: distance,\r\n\t\tpoint: intersectionPointWorld.clone(),\r\n\t\tobject: object\r\n\t};\r\n\r\n}\r\n\r\nfunction checkBufferGeometryIntersection( object, raycaster, ray, position, uv, a, b, c ) {\r\n\r\n\tvA.fromBufferAttribute( position, a );\r\n\tvB.fromBufferAttribute( position, b );\r\n\tvC.fromBufferAttribute( position, c );\r\n\r\n\tvar intersection = checkIntersection( object, object.material, raycaster, ray, vA, vB, vC, intersectionPoint );\r\n\r\n\tif ( intersection ) {\r\n\r\n\t\tif ( uv ) {\r\n\r\n\t\t\tuvA.fromBufferAttribute( uv, a );\r\n\t\t\tuvB.fromBufferAttribute( uv, b );\r\n\t\t\tuvC.fromBufferAttribute( uv, c );\r\n\r\n\t\t\tintersection.uv = Triangle.getUV( intersectionPoint, vA, vB, vC, uvA, uvB, uvC, new Vector2( ) );\r\n\r\n\t\t}\r\n\r\n\t\tvar normal = new Vector3();\r\n\t\tintersection.face = new Face3( a, b, c, Triangle.getNormal( vA, vB, vC, normal ) );\r\n\t\tintersection.faceIndex = a;\r\n\r\n\t}\r\n\r\n\treturn intersection;\r\n\r\n}\r\n\r\n\r\n// https://github.com/mrdoob/three.js/blob/0aa87c999fe61e216c1133fba7a95772b503eddf/src/objects/Mesh.js#L258\r\nfunction intersectTri( mesh, geo, raycaster, ray, tri, intersections ) {\r\n\r\n\tconst triOffset = tri * 3;\r\n\tconst a = geo.index.getX( triOffset );\r\n\tconst b = geo.index.getX( triOffset + 1 );\r\n\tconst c = geo.index.getX( triOffset + 2 );\r\n\r\n\tconst intersection = checkBufferGeometryIntersection( mesh, raycaster, ray, geo.attributes.position, geo.attributes.uv, a, b, c );\r\n\r\n\tif ( intersection ) {\r\n\r\n\t\tintersection.faceIndex = tri;\r\n\t\tif ( intersections ) intersections.push( intersection );\r\n\t\treturn intersection;\r\n\r\n\t}\r\n\r\n\treturn null;\r\n\r\n};\r\n\r\nexport { intersectTri };\r\n","// Returns a Float32Array representing the bounds data for box.\r\nexport function boxToArray( bx ) {\r\n\r\n\tconst arr = new Float32Array( 6 );\r\n\r\n\tarr[ 0 ] = bx.min.x;\r\n\tarr[ 1 ] = bx.min.y;\r\n\tarr[ 2 ] = bx.min.z;\r\n\r\n\tarr[ 3 ] = bx.max.x;\r\n\tarr[ 4 ] = bx.max.y;\r\n\tarr[ 5 ] = bx.max.z;\r\n\r\n\treturn arr;\r\n\r\n}\r\n\r\nexport function arrayToBox( arr, target ) {\r\n\r\n\ttarget.min.x = arr[ 0 ];\r\n\ttarget.min.y = arr[ 1 ];\r\n\ttarget.min.z = arr[ 2 ];\r\n\r\n\ttarget.max.x = arr[ 3 ];\r\n\ttarget.max.y = arr[ 4 ];\r\n\ttarget.max.z = arr[ 5 ];\r\n\r\n\treturn target;\r\n\r\n}\r\n\r\nexport function getLongestEdgeIndex( bounds ) {\r\n\r\n\tlet splitDimIdx = - 1;\r\n\tlet splitDist = - Infinity;\r\n\r\n\tfor ( let i = 0; i < 3; i ++ ) {\r\n\r\n\t\tconst dist = bounds[ i + 3 ] - bounds[ i ];\r\n\t\tif ( dist > splitDist ) {\r\n\r\n\t\t\tsplitDist = dist;\r\n\t\t\tsplitDimIdx = i;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn splitDimIdx;\r\n\r\n}\r\n","import { Vector3 } from 'three';\r\n\r\nexport class SeparatingAxisBounds {\r\n\r\n\tconstructor() {\r\n\r\n\t\tthis.min = Infinity;\r\n\t\tthis.max = - Infinity;\r\n\r\n\t}\r\n\r\n\tsetFromPointsField( points, field ) {\r\n\r\n\t\tlet min = Infinity;\r\n\t\tlet max = - Infinity;\r\n\t\tfor ( let i = 0, l = points.length; i < l; i ++ ) {\r\n\r\n\t\t\tconst p = points[ i ];\r\n\t\t\tconst val = p[ field ];\r\n\t\t\tmin = Math.min( val, min );\r\n\t\t\tmax = Math.max( val, max );\r\n\r\n\t\t}\r\n\r\n\t\tthis.min = min;\r\n\t\tthis.max = max;\r\n\r\n\r\n\t}\r\n\r\n\tsetFromPoints( axis, points ) {\r\n\r\n\t\tlet min = Infinity;\r\n\t\tlet max = - Infinity;\r\n\t\tfor ( let i = 0, l = points.length; i < l; i ++ ) {\r\n\r\n\t\t\tconst p = points[ i ];\r\n\t\t\tconst val = axis.dot( p );\r\n\t\t\tmin = Math.min( val, min );\r\n\t\t\tmax = Math.max( val, max );\r\n\r\n\t\t}\r\n\r\n\t\tthis.min = min;\r\n\t\tthis.max = max;\r\n\r\n\t}\r\n\r\n\tisSeparated( other ) {\r\n\r\n\t\treturn this.min > other.max || other.min > this.max;\r\n\r\n\t}\r\n\r\n}\r\n\r\nSeparatingAxisBounds.prototype.setFromBox = ( function () {\r\n\r\n\tconst p = new Vector3();\r\n\treturn function setFromBox( axis, box ) {\r\n\r\n\t\tconst boxMin = box.min;\r\n\t\tconst boxMax = box.max;\r\n\t\tlet min = Infinity;\r\n\t\tlet max = - Infinity;\r\n\t\tfor ( let x = 0; x <= 1; x ++ ) {\r\n\r\n\t\t\tfor ( let y = 0; y <= 1; y ++ ) {\r\n\r\n\t\t\t\tfor ( let z = 0; z <= 1; z ++ ) {\r\n\r\n\t\t\t\t\tp.x = boxMin.x * x + boxMax.x * ( 1 - x );\r\n\t\t\t\t\tp.y = boxMin.y * y + boxMax.y * ( 1 - y );\r\n\t\t\t\t\tp.z = boxMin.z * z + boxMax.z * ( 1 - z );\r\n\r\n\t\t\t\t\tconst val = axis.dot( p );\r\n\t\t\t\t\tmin = Math.min( val, min );\r\n\t\t\t\t\tmax = Math.max( val, max );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tthis.min = min;\r\n\t\tthis.max = max;\r\n\r\n\t};\r\n\r\n} )();\r\n\r\nexport const areIntersecting = ( function () {\r\n\r\n\tconst cacheSatBounds = new SeparatingAxisBounds();\r\n\treturn function areIntersecting( shape1, shape2 ) {\r\n\r\n\t\tconst points1 = shape1.points;\r\n\t\tconst satAxes1 = shape1.satAxes;\r\n\t\tconst satBounds1 = shape1.satBounds;\r\n\r\n\t\tconst points2 = shape2.points;\r\n\t\tconst satAxes2 = shape2.satAxes;\r\n\t\tconst satBounds2 = shape2.satBounds;\r\n\r\n\t\t// check axes of the first shape\r\n\t\tfor ( let i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\tconst sb = satBounds1[ i ];\r\n\t\t\tconst sa = satAxes1[ i ];\r\n\t\t\tcacheSatBounds.setFromPoints( sa, points2 );\r\n\t\t\tif ( sb.isSeparated( cacheSatBounds ) ) return false;\r\n\r\n\t\t}\r\n\r\n\t\t// check axes of the second shape\r\n\t\tfor ( let i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\tconst sb = satBounds2[ i ];\r\n\t\t\tconst sa = satAxes2[ i ];\r\n\t\t\tcacheSatBounds.setFromPoints( sa, points1 );\r\n\t\t\tif ( sb.isSeparated( cacheSatBounds ) ) return false;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n} )();\r\n","import { Vector3, Vector2, Plane, Line3 } from 'three';\r\nexport const closestPointLineToLine = ( function () {\r\n\r\n\t// https://github.com/juj/MathGeoLib/blob/master/src/Geometry/Line.cpp#L56\r\n\tconst dir1 = new Vector3();\r\n\tconst dir2 = new Vector3();\r\n\tconst v02 = new Vector3();\r\n\treturn function closestPointLineToLine( l1, l2, result ) {\r\n\r\n\t\tconst v0 = l1.start;\r\n\t\tconst v10 = dir1;\r\n\t\tconst v2 = l2.start;\r\n\t\tconst v32 = dir2;\r\n\r\n\t\tv02.subVectors( v0, v2 );\r\n\t\tdir1.subVectors( l1.end, l2.start );\r\n\t\tdir2.subVectors( l2.end, l2.start );\r\n\r\n\t\t// float d0232 = v02.Dot(v32);\r\n\t\tconst d0232 = v02.dot( v32 );\r\n\r\n\t\t// float d3210 = v32.Dot(v10);\r\n\t\tconst d3210 = v32.dot( v10 );\r\n\r\n\t\t// float d3232 = v32.Dot(v32);\r\n\t\tconst d3232 = v32.dot( v32 );\r\n\r\n\t\t// float d0210 = v02.Dot(v10);\r\n\t\tconst d0210 = v02.dot( v10 );\r\n\r\n\t\t// float d1010 = v10.Dot(v10);\r\n\t\tconst d1010 = v10.dot( v10 );\r\n\r\n\t\t// float denom = d1010*d3232 - d3210*d3210;\r\n\t\tconst denom = d1010 * d3232 - d3210 * d3210;\r\n\r\n\t\tlet d, d2;\r\n\t\tif ( denom !== 0 ) {\r\n\r\n\t\t\td = ( d0232 * d3210 - d0210 * d3232 ) / denom;\r\n\r\n\t\t} else {\r\n\r\n\t\t\td = 0;\r\n\r\n\t\t}\r\n\r\n\t\td2 = ( d0232 + d * d3210 ) / d3232;\r\n\r\n\t\tresult.x = d;\r\n\t\tresult.y = d2;\r\n\r\n\t};\r\n\r\n} )();\r\n\r\nexport const closestPointsSegmentToSegment = ( function () {\r\n\r\n\t// https://github.com/juj/MathGeoLib/blob/master/src/Geometry/LineSegment.cpp#L187\r\n\tconst paramResult = new Vector2();\r\n\tconst temp1 = new Vector3();\r\n\tconst temp2 = new Vector3();\r\n\treturn function closestPointsSegmentToSegment( l1, l2, target1, target2 ) {\r\n\r\n\t\tclosestPointLineToLine( l1, l2, paramResult );\r\n\r\n\t\tlet d = paramResult.x;\r\n\t\tlet d2 = paramResult.y;\r\n\t\tif ( d >= 0 && d <= 1 && d2 >= 0 && d2 <= 1 ) {\r\n\r\n\t\t\tl1.at( d, target1 );\r\n\t\t\tl2.at( d2, target2 );\r\n\r\n\t\t\treturn;\r\n\r\n\t\t} else if ( d >= 0 && d <= 1 ) {\r\n\r\n\t\t\t// Only d2 is out of bounds.\r\n\t\t\tif ( d2 < 0 ) {\r\n\r\n\t\t\t\tl2.at( 0, target2 );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tl2.at( 1, target2 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tl1.closestPointToPoint( target2, true, target1 );\r\n\t\t\treturn;\r\n\r\n\t\t} else if ( d2 >= 0 && d2 <= 1 ) {\r\n\r\n\t\t\t// Only d is out of bounds.\r\n\t\t\tif ( d < 0 ) {\r\n\r\n\t\t\t\tl1.at( 0, target1 );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tl1.at( 1, target1 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tl2.closestPointToPoint( target1, true, target2 );\r\n\t\t\treturn;\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// Both u and u2 are out of bounds.\r\n\t\t\tlet p;\r\n\t\t\tif ( d < 0 ) {\r\n\r\n\t\t\t\tp = l1.start;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tp = l1.end;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tlet p2;\r\n\t\t\tif ( d2 < 0 ) {\r\n\r\n\t\t\t\tp2 = l2.start;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tp2 = l2.end;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst closestPoint = temp1;\r\n\t\t\tconst closestPoint2 = temp2;\r\n\t\t\tl1.closestPointToPoint( p2, true, temp1 );\r\n\t\t\tl2.closestPointToPoint( p, true, temp2 );\r\n\r\n\t\t\tif ( closestPoint.distanceToSquared( p2 ) <= closestPoint2.distanceToSquared( p ) ) {\r\n\r\n\t\t\t\ttarget1.copy( closestPoint );\r\n\t\t\t\ttarget2.copy( p2 );\r\n\t\t\t\treturn;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\ttarget1.copy( p );\r\n\t\t\t\ttarget2.copy( closestPoint2 );\r\n\t\t\t\treturn;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n} )();\r\n\r\n\r\nexport const sphereIntersectTriangle = ( function () {\r\n\r\n\t// https://stackoverflow.com/questions/34043955/detect-collision-between-sphere-and-triangle-in-three-js\r\n\tconst closestPointTemp = new Vector3();\r\n\tconst projectedPointTemp = new Vector3();\r\n\tconst planeTemp = new Plane();\r\n\tconst lineTemp = new Line3();\r\n\treturn function sphereIntersectTriangle( sphere, triangle ) {\r\n\r\n\t\tconst { radius, center } = sphere;\r\n\t\tconst { a, b, c } = triangle;\r\n\r\n\t\t// phase 1\r\n\t\tlineTemp.start = a;\r\n\t\tlineTemp.end = b;\r\n\t\tconst closestPoint1 = lineTemp.closestPointToPoint( center, true, closestPointTemp );\r\n\t\tif ( closestPoint1.distanceTo( center ) <= radius ) return true;\r\n\r\n\t\tlineTemp.start = a;\r\n\t\tlineTemp.end = c;\r\n\t\tconst closestPoint2 = lineTemp.closestPointToPoint( center, true, closestPointTemp );\r\n\t\tif ( closestPoint2.distanceTo( center ) <= radius ) return true;\r\n\r\n\t\tlineTemp.start = b;\r\n\t\tlineTemp.end = c;\r\n\t\tconst closestPoint3 = lineTemp.closestPointToPoint( center, true, closestPointTemp );\r\n\t\tif ( closestPoint3.distanceTo( center ) <= radius ) return true;\r\n\r\n\t\t// phase 2\r\n\t\tconst plane = triangle.getPlane( planeTemp );\r\n\t\tconst dp = Math.abs( plane.distanceToPoint( center ) );\r\n\t\tif ( dp <= radius ) {\r\n\r\n\t\t\tconst pp = plane.projectPoint( center, projectedPointTemp );\r\n\t\t\tconst cp = triangle.containsPoint( pp );\r\n\t\t\tif ( cp ) return true;\r\n\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\r\n\t};\r\n\r\n} )();\r\n","import { Triangle, Vector3, Line3, Sphere } from 'three';\r\nimport { SeparatingAxisBounds } from './SeparatingAxisBounds.js';\r\nimport { closestPointsSegmentToSegment } from './MathUtilities.js';\r\n\r\nexport class SeparatingAxisTriangle extends Triangle {\r\n\r\n\tconstructor( ...args ) {\r\n\r\n\t\tsuper( ...args );\r\n\r\n\t\tthis.isSeparatingAxisTriangle = true;\r\n\t\tthis.satAxes = new Array( 4 ).fill().map( () => new Vector3() );\r\n\t\tthis.satBounds = new Array( 4 ).fill().map( () => new SeparatingAxisBounds() );\r\n\t\tthis.points = [ this.a, this.b, this.c ];\r\n\t\tthis.sphere = new Sphere();\r\n\r\n\t}\r\n\r\n}\r\n\r\nSeparatingAxisTriangle.prototype.update = ( function () {\r\n\r\n\tconst arr = new Array( 3 );\r\n\treturn function update( ) {\r\n\r\n\t\tconst a = this.a;\r\n\t\tconst b = this.b;\r\n\t\tconst c = this.c;\r\n\r\n\t\tarr[ 0 ] = this.a;\r\n\t\tarr[ 1 ] = this.b;\r\n\t\tarr[ 2 ] = this.c;\r\n\r\n\t\tconst satAxes = this.satAxes;\r\n\t\tconst satBounds = this.satBounds;\r\n\r\n\t\tconst axis0 = satAxes[ 0 ];\r\n\t\tconst sab0 = satBounds[ 0 ];\r\n\t\tthis.getNormal( axis0 );\r\n\t\tsab0.setFromPoints( axis0, arr );\r\n\r\n\t\tconst axis1 = satAxes[ 1 ];\r\n\t\tconst sab1 = satBounds[ 1 ];\r\n\t\taxis1.subVectors( a, b );\r\n\t\tsab1.setFromPoints( axis1, arr );\r\n\r\n\t\tconst axis2 = satAxes[ 2 ];\r\n\t\tconst sab2 = satBounds[ 2 ];\r\n\t\taxis2.subVectors( b, c );\r\n\t\tsab2.setFromPoints( axis2, arr );\r\n\r\n\t\tconst axis3 = satAxes[ 3 ];\r\n\t\tconst sab3 = satBounds[ 3 ];\r\n\t\taxis3.subVectors( c, a );\r\n\t\tsab3.setFromPoints( axis3, arr );\r\n\r\n\t\tthis.sphere.setFromPoints( this.points );\r\n\r\n\t};\r\n\r\n} )();\r\n\r\nSeparatingAxisTriangle.prototype.intersectsTriangle = ( function () {\r\n\r\n\tconst saTri2 = new SeparatingAxisTriangle();\r\n\tconst arr1 = new Array( 3 );\r\n\tconst arr2 = new Array( 3 );\r\n\tconst cachedSatBounds = new SeparatingAxisBounds();\r\n\tconst cachedSatBounds2 = new SeparatingAxisBounds();\r\n\tconst cachedAxis = new Vector3();\r\n\treturn function intersectsTriangle( other ) {\r\n\r\n\t\tif ( ! other.isSeparatingAxisTriangle ) {\r\n\r\n\t\t\tsaTri2.copy( other );\r\n\t\t\tsaTri2.update();\r\n\t\t\tother = saTri2;\r\n\r\n\t\t}\r\n\r\n\t\tconst satBounds1 = this.satBounds;\r\n\t\tconst satAxes1 = this.satAxes;\r\n\t\tarr2[ 0 ] = other.a;\r\n\t\tarr2[ 1 ] = other.b;\r\n\t\tarr2[ 2 ] = other.c;\r\n\t\tfor ( let i = 0; i < 4; i ++ ) {\r\n\r\n\t\t\tconst sb = satBounds1[ i ];\r\n\t\t\tconst sa = satAxes1[ i ];\r\n\t\t\tcachedSatBounds.setFromPoints( sa, arr2 );\r\n\t\t\tif ( sb.isSeparated( cachedSatBounds ) ) return false;\r\n\r\n\t\t}\r\n\r\n\t\tconst satBounds2 = other.satBounds;\r\n\t\tconst satAxes2 = other.satAxes;\r\n\t\tarr1[ 0 ] = this.a;\r\n\t\tarr1[ 1 ] = this.b;\r\n\t\tarr1[ 2 ] = this.c;\r\n\t\tfor ( let i = 0; i < 4; i ++ ) {\r\n\r\n\t\t\tconst sb = satBounds2[ i ];\r\n\t\t\tconst sa = satAxes2[ i ];\r\n\t\t\tcachedSatBounds.setFromPoints( sa, arr1 );\r\n\t\t\tif ( sb.isSeparated( cachedSatBounds ) ) return false;\r\n\r\n\t\t}\r\n\r\n\t\t// check crossed axes\r\n\t\tfor ( let i = 0; i < 4; i ++ ) {\r\n\r\n\t\t\tconst sa1 = satAxes1[ i ];\r\n\t\t\tfor ( let i2 = 0; i2 < 4; i2 ++ ) {\r\n\r\n\t\t\t\tconst sa2 = satAxes2[ i2 ];\r\n\t\t\t\tcachedAxis.crossVectors( sa1, sa2 );\r\n\t\t\t\tcachedSatBounds.setFromPoints( cachedAxis, arr1 );\r\n\t\t\t\tcachedSatBounds2.setFromPoints( cachedAxis, arr2 );\r\n\t\t\t\tif ( cachedSatBounds.isSeparated( cachedSatBounds2 ) ) return false;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\r\n\t};\r\n\r\n} )();\r\n\r\n\r\nSeparatingAxisTriangle.prototype.distanceToPoint = ( function () {\r\n\r\n\tconst target = new Vector3();\r\n\treturn function distanceToPoint( point ) {\r\n\r\n\t\tthis.closestPointToPoint( point, target );\r\n\t\treturn point.distanceTo( target );\r\n\r\n\t};\r\n\r\n} )();\r\n\r\n\r\nSeparatingAxisTriangle.prototype.distanceToTriangle = ( function () {\r\n\r\n\tconst point = new Vector3();\r\n\tconst point2 = new Vector3();\r\n\tconst cornerFields = [ 'a', 'b', 'c' ];\r\n\tconst line1 = new Line3();\r\n\tconst line2 = new Line3();\r\n\r\n\treturn function distanceToTriangle( other, target1 = null, target2 = null ) {\r\n\r\n\t\tif ( this.intersectsTriangle( other ) ) {\r\n\r\n\t\t\t// TODO: This will not result in a point that lies on\r\n\t\t\t// the intersection line of the triangles\r\n\t\t\tif ( target1 || target2 ) {\r\n\r\n\t\t\t\tthis.getMidpoint( point );\r\n\t\t\t\tother.closestPointToPoint( point, point2 );\r\n\t\t\t\tthis.closestPointToPoint( point2, point );\r\n\r\n\t\t\t\tif ( target1 ) target1.copy( point );\r\n\t\t\t\tif ( target2 ) target2.copy( point2 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn 0;\r\n\r\n\t\t}\r\n\r\n\t\tlet closestDistanceSq = Infinity;\r\n\r\n\t\t// check all point distances\r\n\t\tfor ( let i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\tlet dist;\r\n\t\t\tconst field = cornerFields[ i ];\r\n\t\t\tconst otherVec = other[ field ];\r\n\t\t\tthis.closestPointToPoint( otherVec, point );\r\n\r\n\t\t\tdist = otherVec.distanceToSquared( point );\r\n\r\n\t\t\tif ( dist < closestDistanceSq ) {\r\n\r\n\t\t\t\tclosestDistanceSq = dist;\r\n\t\t\t\tif ( target1 ) target1.copy( point );\r\n\t\t\t\tif ( target2 ) target2.copy( otherVec );\r\n\r\n\t\t\t}\r\n\r\n\r\n\t\t\tconst thisVec = this[ field ];\r\n\t\t\tother.closestPointToPoint( thisVec, point );\r\n\r\n\t\t\tdist = thisVec.distanceToSquared( point );\r\n\r\n\t\t\tif ( dist < closestDistanceSq ) {\r\n\r\n\t\t\t\tclosestDistanceSq = dist;\r\n\t\t\t\tif ( target1 ) target1.copy( thisVec );\r\n\t\t\t\tif ( target2 ) target2.copy( point );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfor ( let i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\tconst f11 = cornerFields[ i ];\r\n\t\t\tconst f12 = cornerFields[ ( i + 1 ) % 3 ];\r\n\t\t\tline1.set( this[ f11 ], this[ f12 ] );\r\n\t\t\tfor ( let i2 = 0; i2 < 3; i2 ++ ) {\r\n\r\n\t\t\t\tconst f21 = cornerFields[ i2 ];\r\n\t\t\t\tconst f22 = cornerFields[ ( i2 + 1 ) % 3 ];\r\n\t\t\t\tline2.set( other[ f21 ], other[ f22 ] );\r\n\r\n\t\t\t\tclosestPointsSegmentToSegment( line1, line2, point, point2 );\r\n\r\n\t\t\t\tconst dist = point.distanceToSquared( point2 );\r\n\t\t\t\tif ( dist < closestDistanceSq ) {\r\n\r\n\t\t\t\t\tclosestDistanceSq = dist;\r\n\t\t\t\t\tif ( target1 ) target1.copy( point );\r\n\t\t\t\t\tif ( target2 ) target2.copy( point2 );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn Math.sqrt( closestDistanceSq );\r\n\r\n\t};\r\n\r\n} )();\r\n\r\n","import { Box3, Vector3, Matrix4, Sphere, Line3 } from 'three';\r\nimport { SeparatingAxisBounds } from './SeparatingAxisBounds.js';\r\nimport { SeparatingAxisTriangle } from './SeparatingAxisTriangle.js';\r\nimport { closestPointsSegmentToSegment } from './MathUtilities.js';\r\n\r\nexport class OrientedBox extends Box3 {\r\n\r\n\tconstructor( ...args ) {\r\n\r\n\t\tsuper( ...args );\r\n\r\n\t\tthis.isOrientedBox = true;\r\n\t\tthis.matrix = new Matrix4();\r\n\t\tthis.invMatrix = new Matrix4();\r\n\t\tthis.points = new Array( 8 ).fill().map( () => new Vector3() );\r\n\t\tthis.satAxes = new Array( 3 ).fill().map( () => new Vector3() );\r\n\t\tthis.satBounds = new Array( 3 ).fill().map( () => new SeparatingAxisBounds() );\r\n\t\tthis.alignedSatBounds = new Array( 3 ).fill().map( () => new SeparatingAxisBounds() );\r\n\t\tthis.sphere = new Sphere();\r\n\r\n\t}\r\n\r\n\tset( min, max, matrix ) {\r\n\r\n\t\tsuper.set( min, max );\r\n\t\tthis.matrix = matrix;\r\n\r\n\t}\r\n\r\n\tcopy( other ) {\r\n\r\n\t\tsuper.copy( other );\r\n\t\tthis.matrix.copy( other.matrix );\r\n\r\n\t}\r\n\r\n}\r\n\r\nOrientedBox.prototype.update = ( function () {\r\n\r\n\treturn function update() {\r\n\r\n\t\tconst matrix = this.matrix;\r\n\t\tconst min = this.min;\r\n\t\tconst max = this.max;\r\n\r\n\t\tconst points = this.points;\r\n\t\tfor ( let x = 0; x <= 1; x ++ ) {\r\n\r\n\t\t\tfor ( let y = 0; y <= 1; y ++ ) {\r\n\r\n\t\t\t\tfor ( let z = 0; z <= 1; z ++ ) {\r\n\r\n\t\t\t\t\tconst i = ( ( 1 << 0 ) * x ) | ( ( 1 << 1 ) * y ) | ( ( 1 << 2 ) * z );\r\n\t\t\t\t\tconst v = points[ i ];\r\n\t\t\t\t\tv.x = x ? max.x : min.x;\r\n\t\t\t\t\tv.y = y ? max.y : min.y;\r\n\t\t\t\t\tv.z = z ? max.z : min.z;\r\n\r\n\t\t\t\t\tv.applyMatrix4( matrix );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tthis.sphere.setFromPoints( this.points );\r\n\r\n\t\tconst satBounds = this.satBounds;\r\n\t\tconst satAxes = this.satAxes;\r\n\t\tconst minVec = points[ 0 ];\r\n\t\tfor ( let i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\tconst axis = satAxes[ i ];\r\n\t\t\tconst sb = satBounds[ i ];\r\n\t\t\tconst index = 1 << i;\r\n\t\t\tconst pi = points[ index ];\r\n\r\n\t\t\taxis.subVectors( minVec, pi );\r\n\t\t\tsb.setFromPoints( axis, points );\r\n\r\n\t\t}\r\n\r\n\t\tconst alignedSatBounds = this.alignedSatBounds;\r\n\t\talignedSatBounds[ 0 ].setFromPointsField( points, 'x' );\r\n\t\talignedSatBounds[ 1 ].setFromPointsField( points, 'y' );\r\n\t\talignedSatBounds[ 2 ].setFromPointsField( points, 'z' );\r\n\r\n\t\tthis.invMatrix.getInverse( this.matrix );\r\n\r\n\t};\r\n\r\n} )();\r\n\r\nOrientedBox.prototype.intersectsBox = ( function () {\r\n\r\n\tconst aabbBounds = new SeparatingAxisBounds();\r\n\treturn function intersectsBox( box ) {\r\n\r\n\t\tif ( ! box.intersectsSphere( this.sphere ) ) return false;\r\n\r\n\t\tconst min = box.min;\r\n\t\tconst max = box.max;\r\n\t\tconst satBounds = this.satBounds;\r\n\t\tconst satAxes = this.satAxes;\r\n\t\tconst alignedSatBounds = this.alignedSatBounds;\r\n\r\n\t\taabbBounds.min = min.x;\r\n\t\taabbBounds.max = max.x;\r\n\t\tif ( alignedSatBounds[ 0 ].isSeparated( aabbBounds ) ) return false;\r\n\r\n\t\taabbBounds.min = min.y;\r\n\t\taabbBounds.max = max.y;\r\n\t\tif ( alignedSatBounds[ 1 ].isSeparated( aabbBounds ) ) return false;\r\n\r\n\t\taabbBounds.min = min.z;\r\n\t\taabbBounds.max = max.z;\r\n\t\tif ( alignedSatBounds[ 2 ].isSeparated( aabbBounds ) ) return false;\r\n\r\n\t\tfor ( let i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\tconst axis = satAxes[ i ];\r\n\t\t\tconst sb = satBounds[ i ];\r\n\t\t\taabbBounds.setFromBox( axis, box );\r\n\t\t\tif ( sb.isSeparated( aabbBounds ) ) return false;\r\n\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\r\n\t};\r\n\r\n} )();\r\n\r\nOrientedBox.prototype.intersectsTriangle = ( function () {\r\n\r\n\tconst saTri = new SeparatingAxisTriangle();\r\n\tconst pointsArr = new Array( 3 );\r\n\tconst cachedSatBounds = new SeparatingAxisBounds();\r\n\tconst cachedSatBounds2 = new SeparatingAxisBounds();\r\n\tconst cachedAxis = new Vector3();\r\n\treturn function intersectsTriangle( triangle ) {\r\n\r\n\t\tif ( ! triangle.isSeparatingAxisTriangle ) {\r\n\r\n\t\t\tsaTri.copy( triangle );\r\n\t\t\tsaTri.update();\r\n\t\t\ttriangle = saTri;\r\n\r\n\t\t}\r\n\r\n\t\tconst satBounds = this.satBounds;\r\n\t\tconst satAxes = this.satAxes;\r\n\r\n\t\tpointsArr[ 0 ] = triangle.a;\r\n\t\tpointsArr[ 1 ] = triangle.b;\r\n\t\tpointsArr[ 2 ] = triangle.c;\r\n\r\n\t\tfor ( let i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\tconst sb = satBounds[ i ];\r\n\t\t\tconst sa = satAxes[ i ];\r\n\t\t\tcachedSatBounds.setFromPoints( sa, pointsArr );\r\n\t\t\tif ( sb.isSeparated( cachedSatBounds ) ) return false;\r\n\r\n\t\t}\r\n\r\n\t\tconst triSatBounds = triangle.satBounds;\r\n\t\tconst triSatAxes = triangle.satAxes;\r\n\t\tconst points = this.points;\r\n\t\tfor ( let i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\tconst sb = triSatBounds[ i ];\r\n\t\t\tconst sa = triSatAxes[ i ];\r\n\t\t\tcachedSatBounds.setFromPoints( sa, points );\r\n\t\t\tif ( sb.isSeparated( cachedSatBounds ) ) return false;\r\n\r\n\t\t}\r\n\r\n\t\t// check crossed axes\r\n\t\tfor ( let i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\tconst sa1 = satAxes[ i ];\r\n\t\t\tfor ( let i2 = 0; i2 < 4; i2 ++ ) {\r\n\r\n\t\t\t\tconst sa2 = triSatAxes[ i2 ];\r\n\t\t\t\tcachedAxis.crossVectors( sa1, sa2 );\r\n\t\t\t\tcachedSatBounds.setFromPoints( cachedAxis, pointsArr );\r\n\t\t\t\tcachedSatBounds2.setFromPoints( cachedAxis, points );\r\n\t\t\t\tif ( cachedSatBounds.isSeparated( cachedSatBounds2 ) ) return false;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\r\n\t};\r\n\r\n} )();\r\n\r\nOrientedBox.prototype.closestPointToPoint = ( function () {\r\n\r\n\treturn function closestPointToPoint( point, target1 ) {\r\n\r\n\t\ttarget1\r\n\t\t\t.copy( point )\r\n\t\t\t.applyMatrix4( this.invMatrix )\r\n\t\t\t.clamp( this.min, this.max )\r\n\t\t\t.applyMatrix4( this.matrix );\r\n\r\n\t\treturn target1;\r\n\r\n\t};\r\n\r\n} )();\r\n\r\nOrientedBox.prototype.distanceToPoint = ( function () {\r\n\r\n\tconst target = new Vector3();\r\n\treturn function distanceToPoint( point ) {\r\n\r\n\t\tthis.closestPointToPoint( point, target );\r\n\t\treturn point.distanceTo( target );\r\n\r\n\t};\r\n\r\n} )();\r\n\r\n\r\nOrientedBox.prototype.distanceToBox = ( function () {\r\n\r\n\tconst xyzFields = [ 'x', 'y', 'z' ];\r\n\tconst segments1 = new Array( 12 ).fill().map( () => new Line3() );\r\n\tconst segments2 = new Array( 12 ).fill().map( () => new Line3() );\r\n\r\n\tconst point1 = new Vector3();\r\n\tconst point2 = new Vector3();\r\n\r\n\treturn function distanceToBox( box, threshold = 0, target1 = null, target2 = null ) {\r\n\r\n\t\tif ( this.intersectsBox( box ) ) {\r\n\r\n\t\t\tif ( target1 || target2 ) {\r\n\r\n\t\t\t\tbox.getCenter( point2 );\r\n\t\t\t\tthis.closestPointToPoint( point2, point1 );\r\n\t\t\t\tbox.closestPointToPoint( point1, point2 );\r\n\r\n\t\t\t\tif ( target1 ) target1.copy( point1 );\r\n\t\t\t\tif ( target2 ) target2.copy( point2 );\r\n\r\n\t\t\t}\r\n\t\t\treturn 0;\r\n\r\n\t\t}\r\n\r\n\t\tconst threshold2 = threshold * threshold;\r\n\t\tconst min = box.min;\r\n\t\tconst max = box.max;\r\n\t\tconst points = this.points;\r\n\r\n\r\n\t\t// iterate over every edge and compare distances\r\n\t\tlet closestDistanceSq = Infinity;\r\n\r\n\t\t// check over all these points\r\n\t\tfor ( let i = 0; i < 8; i ++ ) {\r\n\r\n\t\t\tconst p = points[ i ];\r\n\t\t\tpoint2.copy( p ).clamp( min, max );\r\n\r\n\t\t\tconst dist = p.distanceToSquared( point2 );\r\n\t\t\tif ( dist < closestDistanceSq ) {\r\n\r\n\t\t\t\tclosestDistanceSq = dist;\r\n\t\t\t\tif ( target1 ) target1.copy( p );\r\n\t\t\t\tif ( target2 ) target2.copy( point2 );\r\n\r\n\t\t\t\tif ( dist < threshold2 ) return Math.sqrt( dist );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// generate and check all line segment distances\r\n\t\tlet count = 0;\r\n\t\tfor ( let i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\tfor ( let i1 = 0; i1 <= 1; i1 ++ ) {\r\n\r\n\t\t\t\tfor ( let i2 = 0; i2 <= 1; i2 ++ ) {\r\n\r\n\t\t\t\t\tconst nextIndex = ( i + 1 ) % 3;\r\n\t\t\t\t\tconst nextIndex2 = ( i + 2 ) % 3;\r\n\r\n\t\t\t\t\t// get obb line segments\r\n\t\t\t\t\tconst index = i1 << nextIndex | i2 << nextIndex2;\r\n\t\t\t\t\tconst index2 = 1 << i | i1 << nextIndex | i2 << nextIndex2;\r\n\t\t\t\t\tconst p1 = points[ index ];\r\n\t\t\t\t\tconst p2 = points[ index2 ];\r\n\t\t\t\t\tconst line1 = segments1[ count ];\r\n\t\t\t\t\tline1.set( p1, p2 );\r\n\r\n\r\n\t\t\t\t\t// get aabb line segments\r\n\t\t\t\t\tconst f1 = xyzFields[ i ];\r\n\t\t\t\t\tconst f2 = xyzFields[ nextIndex ];\r\n\t\t\t\t\tconst f3 = xyzFields[ nextIndex2 ];\r\n\t\t\t\t\tconst line2 = segments2[ count ];\r\n\t\t\t\t\tconst start = line2.start;\r\n\t\t\t\t\tconst end = line2.end;\r\n\r\n\t\t\t\t\tstart[ f1 ] = min[ f1 ];\r\n\t\t\t\t\tstart[ f2 ] = i1 ? min[ f2 ] : max[ f2 ];\r\n\t\t\t\t\tstart[ f3 ] = i2 ? min[ f3 ] : max[ f2 ];\r\n\r\n\t\t\t\t\tend[ f1 ] = max[ f1 ];\r\n\t\t\t\t\tend[ f2 ] = i1 ? min[ f2 ] : max[ f2 ];\r\n\t\t\t\t\tend[ f3 ] = i2 ? min[ f3 ] : max[ f2 ];\r\n\r\n\t\t\t\t\tcount ++;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// check all the other boxes point\r\n\t\tfor ( let x = 0; x <= 1; x ++ ) {\r\n\r\n\t\t\tfor ( let y = 0; y <= 1; y ++ ) {\r\n\r\n\t\t\t\tfor ( let z = 0; z <= 1; z ++ ) {\r\n\r\n\t\t\t\t\tpoint2.x = x ? max.x : min.x;\r\n\t\t\t\t\tpoint2.y = y ? max.y : min.y;\r\n\t\t\t\t\tpoint2.z = z ? max.z : min.z;\r\n\r\n\t\t\t\t\tthis.closestPointToPoint( point2, point1 );\r\n\t\t\t\t\tconst dist = point2.distanceToSquared( point1 );\r\n\t\t\t\t\tif ( dist < closestDistanceSq ) {\r\n\r\n\t\t\t\t\t\tclosestDistanceSq = dist;\r\n\t\t\t\t\t\tif ( target1 ) target1.copy( point1 );\r\n\t\t\t\t\t\tif ( target2 ) target2.copy( point2 );\r\n\r\n\t\t\t\t\t\tif ( dist < threshold2 ) return Math.sqrt( dist );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfor ( let i = 0; i < 12; i ++ ) {\r\n\r\n\t\t\tconst l1 = segments1[ i ];\r\n\t\t\tfor ( let i2 = 0; i2 < 12; i2 ++ ) {\r\n\r\n\t\t\t\tconst l2 = segments2[ i2 ];\r\n\t\t\t\tclosestPointsSegmentToSegment( l1, l2, point1, point2 );\r\n\t\t\t\tconst dist = point1.distanceToSquared( point2 );\r\n\t\t\t\tif ( dist < closestDistanceSq ) {\r\n\r\n\t\t\t\t\tclosestDistanceSq = dist;\r\n\t\t\t\t\tif ( target1 ) target1.copy( point1 );\r\n\t\t\t\t\tif ( target2 ) target2.copy( point2 );\r\n\r\n\t\t\t\t\tif ( dist < threshold2 ) return Math.sqrt( dist );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn Math.sqrt( closestDistanceSq );\r\n\r\n\t};\r\n\r\n} )();\r\n","\r\nimport * as THREE from 'three';\r\nimport { intersectTris, intersectClosestTri } from './Utils/RayIntersectTriUtlities.js';\r\nimport { arrayToBox } from './Utils/ArrayBoxUtilities.js';\r\nimport { OrientedBox } from './Utils/OrientedBox.js';\r\nimport { SeparatingAxisTriangle } from './Utils/SeparatingAxisTriangle.js';\r\nimport { sphereIntersectTriangle } from './Utils/MathUtilities.js';\r\n\r\nconst boundingBox = new THREE.Box3();\r\nconst boxIntersection = new THREE.Vector3();\r\nconst xyzFields = [ 'x', 'y', 'z' ];\r\n\r\nfunction setTriangle( tri, i, index, pos ) {\r\n\r\n\tconst ta = tri.a;\r\n\tconst tb = tri.b;\r\n\tconst tc = tri.c;\r\n\r\n\tlet i3 = index.getX( i );\r\n\tta.x = pos.getX( i3 );\r\n\tta.y = pos.getY( i3 );\r\n\tta.z = pos.getZ( i3 );\r\n\r\n\ti3 = index.getX( i + 1 );\r\n\ttb.x = pos.getX( i3 );\r\n\ttb.y = pos.getY( i3 );\r\n\ttb.z = pos.getZ( i3 );\r\n\r\n\ti3 = index.getX( i + 2 );\r\n\ttc.x = pos.getX( i3 );\r\n\ttc.y = pos.getY( i3 );\r\n\ttc.z = pos.getZ( i3 );\r\n\r\n}\r\n\r\nexport default\r\nclass MeshBVHNode {\r\n\r\n\tconstructor() {\r\n\r\n\t\t// internal nodes have boundingData, left, right, and splitAxis\r\n\t\t// leaf nodes have offset and count (referring to primitives in the mesh geometry)\r\n\r\n\t}\r\n\r\n\tintersectRay( ray, target ) {\r\n\r\n\t\tarrayToBox( this.boundingData, boundingBox );\r\n\r\n\t\treturn ray.intersectBox( boundingBox, target );\r\n\r\n\t}\r\n\r\n\traycast( mesh, raycaster, ray, intersects ) {\r\n\r\n\t\tif ( this.count ) intersectTris( mesh, mesh.geometry, raycaster, ray, this.offset, this.count, intersects );\r\n\t\telse {\r\n\r\n\t\t\tif ( this.left.intersectRay( ray, boxIntersection ) )\r\n\t\t\t\tthis.left.raycast( mesh, raycaster, ray, intersects );\r\n\t\t\tif ( this.right.intersectRay( ray, boxIntersection ) )\r\n\t\t\t\tthis.right.raycast( mesh, raycaster, ray, intersects );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\traycastFirst( mesh, raycaster, ray ) {\r\n\r\n\t\tif ( this.count ) {\r\n\r\n\t\t\treturn intersectClosestTri( mesh, mesh.geometry, raycaster, ray, this.offset, this.count );\r\n\r\n\t\t} else {\r\n\r\n\r\n\t\t\t// consider the position of the split plane with respect to the oncoming ray; whichever direction\r\n\t\t\t// the ray is coming from, look for an intersection among that side of the tree first\r\n\t\t\tconst splitAxis = this.splitAxis;\r\n\t\t\tconst xyzAxis = xyzFields[ splitAxis ];\r\n\t\t\tconst rayDir = ray.direction[ xyzAxis ];\r\n\t\t\tconst leftToRight = rayDir >= 0;\r\n\r\n\t\t\t// c1 is the child to check first\r\n\t\t\tlet c1, c2;\r\n\t\t\tif ( leftToRight ) {\r\n\r\n\t\t\t\tc1 = this.left;\r\n\t\t\t\tc2 = this.right;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tc1 = this.right;\r\n\t\t\t\tc2 = this.left;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst c1Intersection = c1.intersectRay( ray, boxIntersection );\r\n\t\t\tconst c1Result = c1Intersection ? c1.raycastFirst( mesh, raycaster, ray ) : null;\r\n\r\n\t\t\t// if we got an intersection in the first node and it's closer than the second node's bounding\r\n\t\t\t// box, we don't need to consider the second node because it couldn't possibly be a better result\r\n\t\t\tif ( c1Result ) {\r\n\r\n\t\t\t\t// check only along the split axis\r\n\t\t\t\tconst rayOrig = ray.origin[ xyzAxis ];\r\n\t\t\t\tconst toPoint = rayOrig - c1Result.point[ xyzAxis ];\r\n\t\t\t\tconst toChild1 = rayOrig - c2.boundingData[ splitAxis ];\r\n\t\t\t\tconst toChild2 = rayOrig - c2.boundingData[ splitAxis + 3 ];\r\n\r\n\t\t\t\tconst toPointSq = toPoint * toPoint;\r\n\t\t\t\tif ( toPointSq <= toChild1 * toChild1 && toPointSq <= toChild2 * toChild2 ) {\r\n\r\n\t\t\t\t\treturn c1Result;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// either there was no intersection in the first node, or there could still be a closer\r\n\t\t\t// intersection in the second, so check the second node and then take the better of the two\r\n\t\t\tconst c2Intersection = c2.intersectRay( ray, boxIntersection );\r\n\t\t\tconst c2Result = c2Intersection ? c2.raycastFirst( mesh, raycaster, ray ) : null;\r\n\r\n\t\t\tif ( c1Result && c2Result ) {\r\n\r\n\t\t\t\treturn c1Result.distance <= c2Result.distance ? c1Result : c2Result;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\treturn c1Result || c2Result || null;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\nMeshBVHNode.prototype.shapecast = ( function () {\r\n\r\n\tconst triangle = new SeparatingAxisTriangle();\r\n\tconst cachedBox1 = new THREE.Box3();\r\n\tconst cachedBox2 = new THREE.Box3();\r\n\treturn function shapecast( mesh, intersectsBoundsFunc, intersectsTriangleFunc = null, nodeScoreFunc = null ) {\r\n\r\n\t\tif ( this.count && intersectsTriangleFunc ) {\r\n\r\n\t\t\tconst geometry = mesh.geometry;\r\n\t\t\tconst index = geometry.index;\r\n\t\t\tconst pos = geometry.attributes.position;\r\n\t\t\tconst offset = this.offset;\r\n\t\t\tconst count = this.count;\r\n\r\n\t\t\tfor ( let i = offset * 3, l = ( count + offset ) * 3; i < l; i += 3 ) {\r\n\r\n\t\t\t\tsetTriangle( triangle, i, index, pos );\r\n\t\t\t\ttriangle.update();\r\n\r\n\t\t\t\tif ( intersectsTriangleFunc( triangle, i, i + 1, i + 2 ) ) {\r\n\r\n\t\t\t\t\treturn true;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn false;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tconst left = this.left;\r\n\t\t\tconst right = this.right;\r\n\t\t\tlet c1 = left;\r\n\t\t\tlet c2 = right;\r\n\r\n\t\t\tlet score1, score2;\r\n\t\t\tlet box1, box2;\r\n\t\t\tif ( nodeScoreFunc ) {\r\n\r\n\t\t\t\tbox1 = cachedBox1;\r\n\t\t\t\tbox2 = cachedBox2;\r\n\r\n\t\t\t\tarrayToBox( c1.boundingData, box1 );\r\n\t\t\t\tarrayToBox( c2.boundingData, box2 );\r\n\r\n\t\t\t\tscore1 = nodeScoreFunc( box1 );\r\n\t\t\t\tscore2 = nodeScoreFunc( box2 );\r\n\r\n\t\t\t\tif ( score2 < score1 ) {\r\n\r\n\t\t\t\t\tc1 = right;\r\n\t\t\t\t\tc2 = left;\r\n\r\n\t\t\t\t\tconst temp = score1;\r\n\t\t\t\t\tscore1 = score2;\r\n\t\t\t\t\tscore2 = temp;\r\n\r\n\t\t\t\t\tconst tempBox = box1;\r\n\t\t\t\t\tbox1 = box2;\r\n\t\t\t\t\tbox2 = tempBox;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( ! box1 ) {\r\n\r\n\t\t\t\tbox1 = cachedBox1;\r\n\t\t\t\tarrayToBox( c1.boundingData, box1 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst isC1Leaf = ! ! c1.count;\r\n\t\t\tconst c1Intersection =\r\n\t\t\t\tintersectsBoundsFunc( box1, isC1Leaf, score1, c1 ) &&\r\n\t\t\t\tc1.shapecast( mesh, intersectsBoundsFunc, intersectsTriangleFunc, nodeScoreFunc );\r\n\r\n\t\t\tif ( c1Intersection ) return true;\r\n\r\n\r\n\t\t\tif ( ! box2 ) {\r\n\r\n\t\t\t\tbox2 = cachedBox2;\r\n\t\t\t\tarrayToBox( c2.boundingData, box2 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst isC2Leaf = ! ! c2.count;\r\n\t\t\tconst c2Intersection =\r\n\t\t\t\tintersectsBoundsFunc( box2, isC2Leaf, score2, c2 ) &&\r\n\t\t\t\tc2.shapecast( mesh, intersectsBoundsFunc, intersectsTriangleFunc, nodeScoreFunc );\r\n\r\n\t\t\tif ( c2Intersection ) return true;\r\n\r\n\t\t\treturn false;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n} )();\r\n\r\nMeshBVHNode.prototype.intersectsGeometry = ( function () {\r\n\r\n\tconst triangle = new SeparatingAxisTriangle();\r\n\tconst triangle2 = new SeparatingAxisTriangle();\r\n\tconst cachedMesh = new THREE.Mesh();\r\n\tconst invertedMat = new THREE.Matrix4();\r\n\r\n\tconst obb = new OrientedBox();\r\n\tconst obb2 = new OrientedBox();\r\n\r\n\treturn function intersectsGeometry( mesh, geometry, geometryToBvh, cachedObb = null ) {\r\n\r\n\t\tif ( cachedObb === null ) {\r\n\r\n\t\t\tif ( ! geometry.boundingBox ) {\r\n\r\n\t\t\t\tgeometry.computeBoundingBox();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tobb.set( geometry.boundingBox.min, geometry.boundingBox.max, geometryToBvh );\r\n\t\t\tobb.update();\r\n\t\t\tcachedObb = obb;\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.count ) {\r\n\r\n\t\t\tconst thisGeometry = mesh.geometry;\r\n\t\t\tconst thisIndex = thisGeometry.index;\r\n\t\t\tconst thisPos = thisGeometry.attributes.position;\r\n\r\n\t\t\tconst index = geometry.index;\r\n\t\t\tconst pos = geometry.attributes.position;\r\n\r\n\t\t\tconst offset = this.offset;\r\n\t\t\tconst count = this.count;\r\n\r\n\t\t\t// get the inverse of the geometry matrix so we can transform our triangles into the\r\n\t\t\t// geometry space we're trying to test. We assume there are fewer triangles being checked\r\n\t\t\t// here.\r\n\t\t\tinvertedMat.getInverse( geometryToBvh );\r\n\r\n\t\t\tif ( geometry.boundsTree ) {\r\n\r\n\t\t\t\tfunction triangleCallback( tri ) {\r\n\r\n\t\t\t\t\ttri.a.applyMatrix4( geometryToBvh );\r\n\t\t\t\t\ttri.b.applyMatrix4( geometryToBvh );\r\n\t\t\t\t\ttri.c.applyMatrix4( geometryToBvh );\r\n\t\t\t\t\ttri.update();\r\n\r\n\t\t\t\t\tfor ( let i = offset * 3, l = ( count + offset ) * 3; i < l; i += 3 ) {\r\n\r\n\t\t\t\t\t\t// this triangle needs to be transformed into the current BVH coordinate frame\r\n\t\t\t\t\t\tsetTriangle( triangle2, i, thisIndex, thisPos );\r\n\t\t\t\t\t\ttriangle2.update();\r\n\t\t\t\t\t\tif ( tri.intersectsTriangle( triangle2 ) ) {\r\n\r\n\t\t\t\t\t\t\treturn true;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\treturn false;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tarrayToBox( this.boundingData, obb2 );\r\n\t\t\t\tobb2.matrix.copy( invertedMat );\r\n\t\t\t\tobb2.update();\r\n\r\n\t\t\t\tcachedMesh.geometry = geometry;\r\n\t\t\t\tconst res = geometry.boundsTree.shapecast( cachedMesh, box => obb2.intersectsBox( box ), triangleCallback );\r\n\t\t\t\tcachedMesh.geometry = null;\r\n\r\n\t\t\t\treturn res;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tfor ( let i = offset * 3, l = ( count + offset * 3 ); i < l; i += 3 ) {\r\n\r\n\t\t\t\t\t// this triangle needs to be transformed into the current BVH coordinate frame\r\n\t\t\t\t\tsetTriangle( triangle, i, thisIndex, thisPos );\r\n\t\t\t\t\ttriangle.a.applyMatrix4( invertedMat );\r\n\t\t\t\t\ttriangle.b.applyMatrix4( invertedMat );\r\n\t\t\t\t\ttriangle.c.applyMatrix4( invertedMat );\r\n\t\t\t\t\ttriangle.update();\r\n\r\n\t\t\t\t\tfor ( let i2 = 0, l2 = index.count; i2 < l2; i2 += 3 ) {\r\n\r\n\t\t\t\t\t\tsetTriangle( triangle2, i2, index, pos );\r\n\t\t\t\t\t\ttriangle2.update();\r\n\r\n\t\t\t\t\t\tif ( triangle.intersectsTriangle( triangle2 ) ) {\r\n\r\n\t\t\t\t\t\t\treturn true;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tconst left = this.left;\r\n\t\t\tconst right = this.right;\r\n\r\n\t\t\tarrayToBox( left.boundingData, boundingBox );\r\n\t\t\tconst leftIntersection =\r\n\t\t\t\tcachedObb.intersectsBox( boundingBox ) &&\r\n\t\t\t\tleft.intersectsGeometry( mesh, geometry, geometryToBvh, cachedObb );\r\n\r\n\t\t\tif ( leftIntersection ) return true;\r\n\r\n\r\n\t\t\tarrayToBox( right.boundingData, boundingBox );\r\n\t\t\tconst rightIntersection =\r\n\t\t\t\tcachedObb.intersectsBox( boundingBox ) &&\r\n\t\t\t\tright.intersectsGeometry( mesh, geometry, geometryToBvh, cachedObb );\r\n\r\n\t\t\tif ( rightIntersection ) return true;\r\n\r\n\t\t\treturn false;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n} )();\r\n\r\nMeshBVHNode.prototype.intersectsBox = ( function () {\r\n\r\n\tconst obb = new OrientedBox();\r\n\r\n\treturn function intersectsBox( mesh, box, boxToBvh ) {\r\n\r\n\t\tobb.set( box.min, box.max, boxToBvh );\r\n\t\tobb.update();\r\n\r\n\t\treturn this.shapecast(\r\n\t\t\tmesh,\r\n\t\t\tbox => obb.intersectsBox( box ),\r\n\t\t\ttri => obb.intersectsTriangle( tri )\r\n\t\t);\r\n\r\n\t};\r\n\r\n} )();\r\n\r\nMeshBVHNode.prototype.intersectsSphere = ( function () {\r\n\r\n\treturn function intersectsSphere( mesh, sphere ) {\r\n\r\n\t\treturn this.shapecast(\r\n\t\t\tmesh,\r\n\t\t\tbox => sphere.intersectsBox( box ),\r\n\t\t\ttri => sphereIntersectTriangle( sphere, tri )\r\n\t\t);\r\n\r\n\t};\r\n\r\n} )();\r\n\r\nMeshBVHNode.prototype.closestPointToPoint = ( function () {\r\n\r\n\t// early out if under minThreshold\r\n\t// skip checking if over maxThreshold\r\n\t// set minThreshold = maxThreshold to quickly check if a point is within a threshold\r\n\t// returns Infinity if no value found\r\n\r\n\tconst temp = new THREE.Vector3();\r\n\treturn function closestPointToPoint( mesh, point, target = null, minThreshold = 0, maxThreshold = Infinity ) {\r\n\r\n\t\tlet closestDistance = Infinity;\r\n\t\tthis.shapecast(\r\n\r\n\t\t\tmesh,\r\n\t\t\t( box, isLeaf, score ) => score < closestDistance && score < maxThreshold,\r\n\t\t\ttri => {\r\n\r\n\t\t\t\ttri.closestPointToPoint( point, temp );\r\n\t\t\t\tconst dist = point.distanceTo( temp );\r\n\t\t\t\tif ( dist < closestDistance ) {\r\n\r\n\t\t\t\t\tif ( target ) target.copy( temp );\r\n\t\t\t\t\tclosestDistance = dist;\r\n\r\n\t\t\t\t}\r\n\t\t\t\tif ( dist < minThreshold ) return true;\r\n\t\t\t\treturn false;\r\n\r\n\t\t\t},\r\n\t\t\tbox => box.distanceToPoint( point )\r\n\r\n\t\t);\r\n\r\n\t\treturn closestDistance;\r\n\r\n\t};\r\n\r\n} )();\r\n\r\nMeshBVHNode.prototype.closestPointToGeometry = ( function () {\r\n\r\n\t// early out if under minThreshold\r\n\t// skip checking if over maxThreshold\r\n\t// set minThreshold = maxThreshold to quickly check if a point is within a threshold\r\n\t// returns Infinity if no value found\r\n\r\n\tconst tri2 = new SeparatingAxisTriangle();\r\n\tconst obb = new OrientedBox();\r\n\r\n\tconst temp1 = new THREE.Vector3();\r\n\tconst temp2 = new THREE.Vector3();\r\n\treturn function closestPointToGeometry( mesh, geometry, geometryToBvh, target1 = null, target2 = null, minThreshold = 0, maxThreshold = Infinity ) {\r\n\r\n\t\tif ( ! geometry.boundingBox ) geometry.computeBoundingBox();\r\n\t\tobb.set( geometry.boundingBox.min, geometry.boundingBox.max, geometryToBvh );\r\n\t\tobb.update();\r\n\r\n\t\tconst pos = geometry.attributes.position;\r\n\t\tconst index = geometry.index;\r\n\r\n\t\tlet tempTarget1, tempTarget2;\r\n\t\tif ( target1 ) tempTarget1 = temp1;\r\n\t\tif ( target2 ) tempTarget2 = temp2;\r\n\r\n\t\tlet closestDistance = Infinity;\r\n\t\tthis.shapecast(\r\n\t\t\tmesh,\r\n\t\t\t( box, isLeaf, score ) => score < closestDistance && score < maxThreshold,\r\n\t\t\ttri => {\r\n\r\n\t\t\t\tconst sphere1 = tri.sphere;\r\n\t\t\t\tfor ( let i2 = 0, l2 = index.count; i2 < l2; i2 += 3 ) {\r\n\r\n\t\t\t\t\tsetTriangle( tri2, i2, index, pos );\r\n\t\t\t\t\ttri2.a.applyMatrix4( geometryToBvh );\r\n\t\t\t\t\ttri2.b.applyMatrix4( geometryToBvh );\r\n\t\t\t\t\ttri2.c.applyMatrix4( geometryToBvh );\r\n\t\t\t\t\ttri2.sphere.setFromPoints( tri2.points );\r\n\r\n\t\t\t\t\tconst sphere2 = tri2.sphere;\r\n\t\t\t\t\tconst sphereDist = sphere2.center.distanceTo( sphere1.center ) - sphere2.radius - sphere1.radius;\r\n\t\t\t\t\tif ( sphereDist > closestDistance ) continue;\r\n\r\n\t\t\t\t\ttri2.update();\r\n\r\n\t\t\t\t\tconst dist = tri.distanceToTriangle( tri2, tempTarget1, tempTarget2 );\r\n\t\t\t\t\tif ( dist < closestDistance ) {\r\n\r\n\t\t\t\t\t\tif ( target1 ) target1.copy( tempTarget1 );\r\n\t\t\t\t\t\tif ( target2 ) target2.copy( tempTarget2 );\r\n\t\t\t\t\t\tclosestDistance = dist;\r\n\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif ( dist < minThreshold ) return true;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn false;\r\n\r\n\t\t\t},\r\n\t\t\tbox => obb.distanceToBox( box, Math.min( closestDistance, maxThreshold ) )\r\n\r\n\t\t);\r\n\r\n\t\treturn closestDistance;\r\n\r\n\t};\r\n\r\n} )();\r\n","import { intersectTri } from './ThreeIntersectionUtilities.js';\r\n\r\nexport function intersectTris( mesh, geo, raycaster, ray, offset, count, intersections ) {\r\n\r\n\tfor ( let i = offset, end = offset + count; i < end; i ++ ) {\r\n\r\n\t\tintersectTri( mesh, geo, raycaster, ray, i, intersections );\r\n\r\n\t}\r\n\r\n};\r\n\r\nexport function intersectClosestTri( mesh, geo, raycaster, ray, offset, count ) {\r\n\r\n\tlet dist = Infinity;\r\n\tlet res = null;\r\n\tfor ( let i = offset, end = offset + count; i < end; i ++ ) {\r\n\r\n\t\tconst intersection = intersectTri( mesh, geo, raycaster, ray, i );\r\n\t\tif ( intersection && intersection.distance < dist ) {\r\n\r\n\t\t\tres = intersection;\r\n\t\t\tdist = intersection.distance;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn res;\r\n\r\n};\r\n","// Split strategy constants\r\nexport const CENTER = 0;\r\nexport const AVERAGE = 1;\r\nexport const SAH = 2;\r\n","import * as THREE from 'three';\r\nimport { arrayToBox, getLongestEdgeIndex } from './Utils/ArrayBoxUtilities.js';\r\nimport { CENTER, AVERAGE, SAH } from './Constants.js';\r\n\r\nconst xyzFields = [ 'x', 'y', 'z' ];\r\n\r\n// precomputes the bounding box for each triangle; required for quickly calculating tree splits.\r\n// result is an array of size tris.length * 6 where triangle i maps to a\r\n// [x_center, x_delta, y_center, y_delta, z_center, z_delta] tuple starting at index i * 6,\r\n// representing the center and half-extent in each dimension of triangle i\r\nfunction computeBounds( geo ) {\r\n\r\n\tconst verts = geo.attributes.position.array;\r\n\tconst index = geo.index.array;\r\n\tconst triCount = index.length / 3;\r\n\tconst bounds = new Float32Array( triCount * 6 );\r\n\r\n\tfor ( let tri = 0; tri < triCount; tri ++ ) {\r\n\r\n\t\tconst ai = index[ 3 * tri + 0 ] * 3;\r\n\t\tconst bi = index[ 3 * tri + 1 ] * 3;\r\n\t\tconst ci = index[ 3 * tri + 2 ] * 3;\r\n\r\n\t\tfor ( let el = 0; el < 3; el ++ ) {\r\n\r\n\t\t\tconst a = verts[ ai + el ];\r\n\t\t\tconst b = verts[ bi + el ];\r\n\t\t\tconst c = verts[ ci + el ];\r\n\t\t\tconst min = Math.min( a, b, c );\r\n\t\t\tconst max = Math.max( a, b, c );\r\n\t\t\tconst halfExtents = ( max - min ) / 2;\r\n\t\t\tbounds[ tri * 6 + el * 2 + 0 ] = min + halfExtents;\r\n\t\t\tbounds[ tri * 6 + el * 2 + 1 ] = halfExtents;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn bounds;\r\n\r\n}\r\n\r\nconst boxtemp = new THREE.Box3();\r\n\r\nexport default class BVHConstructionContext {\r\n\r\n\tconstructor( geo, options ) {\r\n\r\n\t\tthis.geo = geo;\r\n\t\tthis.options = options;\r\n\t\tthis.bounds = computeBounds( geo );\r\n\r\n\t\t// SAH Initialization\r\n\t\tthis.sahplanes = null;\r\n\t\tif ( options.strategy === SAH ) {\r\n\r\n\t\t\tconst triCount = geo.index.count / 3;\r\n\t\t\tthis.sahplanes = [ new Array( triCount ), new Array( triCount ), new Array( triCount ) ];\r\n\t\t\tfor ( let tri = 0; tri < triCount; tri ++ ) {\r\n\r\n\t\t\t\tfor ( let el = 0; el < 3; el ++ ) {\r\n\r\n\t\t\t\t\tthis.sahplanes[ el ][ tri ] = { p: this.bounds[ tri * 6 + el * 2 ], tri };\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// returns the average coordinate on the specified axis of the all the provided triangles\r\n\tgetAverage( offset, count, axis ) {\r\n\r\n\t\tlet avg = 0;\r\n\t\tconst bounds = this.bounds;\r\n\r\n\t\tfor ( let i = offset, end = offset + count; i < end; i ++ ) {\r\n\r\n\t\t\tavg += bounds[ i * 6 + axis * 2 ];\r\n\r\n\t\t}\r\n\r\n\t\treturn avg / count;\r\n\r\n\t}\r\n\r\n\t// computes the union of the bounds of all of the given triangles and puts the resulting box in target\r\n\tgetBounds( offset, count, target ) {\r\n\r\n\t\tlet minx = Infinity;\r\n\t\tlet miny = Infinity;\r\n\t\tlet minz = Infinity;\r\n\t\tlet maxx = - Infinity;\r\n\t\tlet maxy = - Infinity;\r\n\t\tlet maxz = - Infinity;\r\n\t\tconst bounds = this.bounds;\r\n\r\n\t\tfor ( let i = offset, end = offset + count; i < end; i ++ ) {\r\n\r\n\t\t\tconst cx = bounds[ i * 6 + 0 ];\r\n\t\t\tconst hx = bounds[ i * 6 + 1 ];\r\n\t\t\tminx = Math.min( minx, cx - hx );\r\n\t\t\tmaxx = Math.max( maxx, cx + hx );\r\n\t\t\tconst cy = bounds[ i * 6 + 2 ];\r\n\t\t\tconst hy = bounds[ i * 6 + 3 ];\r\n\t\t\tminy = Math.min( miny, cy - hy );\r\n\t\t\tmaxy = Math.max( maxy, cy + hy );\r\n\t\t\tconst cz = bounds[ i * 6 + 4 ];\r\n\t\t\tconst hz = bounds[ i * 6 + 5 ];\r\n\t\t\tminz = Math.min( minz, cz - hz );\r\n\t\t\tmaxz = Math.max( maxz, cz + hz );\r\n\r\n\t\t}\r\n\r\n\t\ttarget[ 0 ] = minx;\r\n\t\ttarget[ 1 ] = miny;\r\n\t\ttarget[ 2 ] = minz;\r\n\r\n\t\ttarget[ 3 ] = maxx;\r\n\t\ttarget[ 4 ] = maxy;\r\n\t\ttarget[ 5 ] = maxz;\r\n\r\n\t\treturn target;\r\n\r\n\t}\r\n\r\n\t// reorders `tris` such that for `count` elements after `offset`, elements on the left side of the split\r\n\t// will be on the left and elements on the right side of the split will be on the right. returns the index\r\n\t// of the first element on the right side, or offset + count if there are no elements on the right side.\r\n\tpartition( offset, count, split ) {\r\n\r\n\t\tlet left = offset;\r\n\t\tlet right = offset + count - 1;\r\n\t\tconst pos = split.pos;\r\n\t\tconst axisOffset = split.axis * 2;\r\n\t\tconst index = this.geo.index.array;\r\n\t\tconst bounds = this.bounds;\r\n\t\tconst sahplanes = this.sahplanes;\r\n\r\n\t\t// hoare partitioning, see e.g. https://en.wikipedia.org/wiki/Quicksort#Hoare_partition_scheme\r\n\t\twhile ( true ) {\r\n\r\n\t\t\twhile ( left <= right && bounds[ left * 6 + axisOffset ] < pos ) {\r\n\r\n\t\t\t\tleft ++;\r\n\r\n\t\t\t}\r\n\r\n\t\t\twhile ( left <= right && bounds[ right * 6 + axisOffset ] >= pos ) {\r\n\r\n\t\t\t\tright --;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( left < right ) {\r\n\r\n\t\t\t\t// we need to swap all of the information associated with the triangles at index\r\n\t\t\t\t// left and right; that's the verts in the geometry index, the bounds,\r\n\t\t\t\t// and perhaps the SAH planes\r\n\r\n\t\t\t\tfor ( let i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\t\t\tlet t0 = index[ left * 3 + i ];\r\n\t\t\t\t\tindex[ left * 3 + i ] = index[ right * 3 + i ];\r\n\t\t\t\t\tindex[ right * 3 + i ] = t0;\r\n\t\t\t\t\tlet t1 = bounds[ left * 6 + i * 2 + 0 ];\r\n\t\t\t\t\tbounds[ left * 6 + i * 2 + 0 ] = bounds[ right * 6 + i * 2 + 0 ];\r\n\t\t\t\t\tbounds[ right * 6 + i * 2 + 0 ] = t1;\r\n\t\t\t\t\tlet t2 = bounds[ left * 6 + i * 2 + 1 ];\r\n\t\t\t\t\tbounds[ left * 6 + i * 2 + 1 ] = bounds[ right * 6 + i * 2 + 1 ];\r\n\t\t\t\t\tbounds[ right * 6 + i * 2 + 1 ] = t2;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( sahplanes ) {\r\n\r\n\t\t\t\t\tfor ( let i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\t\t\t\tlet t = sahplanes[ i ][ left ];\r\n\t\t\t\t\t\tsahplanes[ i ][ left ] = sahplanes[ i ][ right ];\r\n\t\t\t\t\t\tsahplanes[ i ][ right ] = t;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tleft ++;\r\n\t\t\t\tright --;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\treturn left;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tgetOptimalSplit( bounds, offset, count, strategy ) {\r\n\r\n\t\tlet axis = - 1;\r\n\t\tlet pos = 0;\r\n\r\n\t\t// Center\r\n\t\tif ( strategy === CENTER ) {\r\n\r\n\t\t\taxis = getLongestEdgeIndex( bounds );\r\n\t\t\tif ( axis !== - 1 ) {\r\n\r\n\t\t\t\tpos = ( bounds[ axis + 3 ] + bounds[ axis ] ) / 2;\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( strategy === AVERAGE ) {\r\n\r\n\t\t\taxis = getLongestEdgeIndex( bounds );\r\n\t\t\tif ( axis !== - 1 ) {\r\n\r\n\t\t\t\tpos = this.getAverage( offset, count, axis );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( strategy === SAH ) {\r\n\r\n\t\t\t// Surface Area Heuristic\r\n\t\t\t// In order to make this code more terse, the x, y, and z\r\n\t\t\t// variables of various structures have been stuffed into\r\n\t\t\t// 0, 1, and 2 array indices so they can be easily computed\r\n\t\t\t// and accessed within array iteration\r\n\r\n\t\t\t// Cost values defineed for operations. We're using bounds for traversal, so\r\n\t\t\t// the cost of traversing one more layer is more than intersecting a triangle.\r\n\t\t\tconst TRAVERSAL_COST = 3;\r\n\t\t\tconst INTERSECTION_COST = 1;\r\n\t\t\tconst bb = arrayToBox( bounds, boxtemp );\r\n\r\n\t\t\t// Define the width, height, and depth of the bounds as a box\r\n\t\t\tconst dim = [\r\n\t\t\t\tbb.max.x - bb.min.x,\r\n\t\t\t\tbb.max.y - bb.min.y,\r\n\t\t\t\tbb.max.z - bb.min.z\r\n\t\t\t];\r\n\t\t\tconst sa = 2 * ( dim[ 0 ] * dim[ 1 ] + dim[ 0 ] * dim[ 2 ] + dim[ 1 ] * dim[ 2 ] );\r\n\r\n\t\t\t// Get the precalculated planes based for the triangles we're\r\n\t\t\t// testing here\r\n\t\t\tconst filteredLists = [[], [], []];\r\n\t\t\tfor ( let i = offset, end = offset + count; i < end; i ++ ) {\r\n\r\n\t\t\t\tfor ( let v = 0; v < 3; v ++ ) {\r\n\r\n\t\t\t\t\tfilteredLists[ v ].push( this.sahplanes[ v ][ i ] );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\t\t\tfilteredLists.forEach( planes => planes.sort( ( a, b ) => a.p - b.p ) );\r\n\r\n\t\t\t// this bounds surface area, left bound SA, left triangles, right bound SA, right triangles\r\n\t\t\tconst getCost = ( sa, sal, nl, sar, nr ) =>\r\n\t\t\t\t  TRAVERSAL_COST + INTERSECTION_COST * ( ( sal / sa ) * nl + ( sar / sa ) * nr );\r\n\r\n\t\t\t// the cost of _not_ splitting into smaller bounds\r\n\t\t\tconst noSplitCost = INTERSECTION_COST * count;\r\n\r\n\t\t\taxis = - 1;\r\n\t\t\tlet bestCost = noSplitCost;\r\n\t\t\tfor ( let i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\t\t// o1 and o2 represent the _other_ two axes in the\r\n\t\t\t\t// the space. So if we're checking the x (0) dimension,\r\n\t\t\t\t// then o1 and o2 would be y and z (1 and 2)\r\n\t\t\t\tconst o1 = ( i + 1 ) % 3;\r\n\t\t\t\tconst o2 = ( i + 2 ) % 3;\r\n\r\n\t\t\t\tconst bmin = bb.min[ xyzFields[ i ] ];\r\n\t\t\t\tconst bmax = bb.max[ xyzFields[ i ] ];\r\n\t\t\t\tconst planes = filteredLists[ i ];\r\n\r\n\t\t\t\t// The number of left and right triangles on either side\r\n\t\t\t\t// given the current split\r\n\t\t\t\tlet nl = 0;\r\n\t\t\t\tlet nr = count;\r\n\t\t\t\tfor ( let p = 0; p < planes.length; p ++ ) {\r\n\r\n\t\t\t\t\tconst pinfo = planes[ p ];\r\n\r\n\t\t\t\t\t// As the plane moves, we have to increment or decrement the\r\n\t\t\t\t\t// number of triangles on either side of the plane\r\n\t\t\t\t\tnl ++;\r\n\t\t\t\t\tnr --;\r\n\r\n\t\t\t\t\t// the distance from the plane to the edge of the broader bounds\r\n\t\t\t\t\tconst ldim = pinfo.p - bmin;\r\n\t\t\t\t\tconst rdim = bmax - pinfo.p;\r\n\r\n\t\t\t\t\t// same for the other two dimensions\r\n\t\t\t\t\tlet ldimo1 = dim[ o1 ], rdimo1 = dim[ o1 ];\r\n\t\t\t\t\tlet ldimo2 = dim[ o2 ], rdimo2 = dim[ o2 ];\r\n\r\n\t\t\t\t\t/*\r\n\t\t\t\t\t// compute the other bounding planes for the box\r\n\t\t\t\t\t// if only the current triangles are considered to\r\n\t\t\t\t\t// be in the box\r\n\t\t\t\t\t// This is really slow and probably not really worth it\r\n\t\t\t\t\tconst o1planes = this.sahplanes[o1];\r\n\t\t\t\t\tconst o2planes = this.sahplanes[o2];\r\n\t\t\t\t\tlet lmin = Infinity, lmax = -Infinity;\r\n\t\t\t\t\tlet rmin = Infinity, rmax = -Infinity;\r\n\t\t\t\t\tplanes.forEach((p, i) => {\r\n\t\t\t\t\tconst tri2 = p.tri * 2;\r\n\t\t\t\t\tconst inf1 = o1planes[tri2 + 0];\r\n\t\t\t\t\tconst inf2 = o1planes[tri2 + 1];\r\n\t\t\t\t\tif (i <= nl) {\r\n\t\t\t\t\tlmin = Math.min(inf1.p, inf2.p, lmin);\r\n\t\t\t\t\tlmax = Math.max(inf1.p, inf2.p, lmax);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (i >= nr) {\r\n\t\t\t\t\trmin = Math.min(inf1.p, inf2.p, rmin);\r\n\t\t\t\t\trmax = Math.max(inf1.p, inf2.p, rmax);\r\n\t\t\t\t\t}\r\n\t\t\t\t\t})\r\n\t\t\t\t\tldimo1 = Math.min(lmax - lmin, ldimo1);\r\n\t\t\t\t\trdimo1 = Math.min(rmax - rmin, rdimo1);\r\n\r\n\t\t\t\t\tplanes.forEach((p, i) => {\r\n\t\t\t\t\tconst tri2 = p.tri * 2;\r\n\t\t\t\t\tconst inf1 = o2planes[tri2 + 0];\r\n\t\t\t\t\tconst inf2 = o2planes[tri2 + 1];\r\n\t\t\t\t\tif (i <= nl) {\r\n\t\t\t\t\tlmin = Math.min(inf1.p, inf2.p, lmin);\r\n\t\t\t\t\tlmax = Math.max(inf1.p, inf2.p, lmax);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (i >= nr) {\r\n\t\t\t\t\trmin = Math.min(inf1.p, inf2.p, rmin);\r\n\t\t\t\t\trmax = Math.max(inf1.p, inf2.p, rmax);\r\n\t\t\t\t\t}\r\n\t\t\t\t\t})\r\n\t\t\t\t\tldimo2 = Math.min(lmax - lmin, ldimo2);\r\n\t\t\t\t\trdimo2 = Math.min(rmax - rmin, rdimo2);\r\n\t\t\t\t\t*/\r\n\r\n\t\t\t\t\t// surface areas and cost\r\n\t\t\t\t\tconst sal = 2 * ( ldimo1 * ldimo2 + ldimo1 * ldim + ldimo2 * ldim );\r\n\t\t\t\t\tconst sar = 2 * ( rdimo1 * rdimo2 + rdimo1 * rdim + rdimo2 * rdim );\r\n\t\t\t\t\tconst cost = getCost( sa, sal, nl, sar, nr );\r\n\r\n\t\t\t\t\tif ( cost < bestCost ) {\r\n\r\n\t\t\t\t\t\taxis = i;\r\n\t\t\t\t\t\tpos = pinfo.p;\r\n\t\t\t\t\t\tbestCost = cost;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn { axis, pos };\r\n\r\n\t}\r\n\r\n}\r\n","import * as THREE from 'three';\r\nimport MeshBVHNode from './MeshBVHNode.js';\r\nimport BVHConstructionContext from './BVHConstructionContext.js';\r\nimport { arrayToBox, boxToArray } from './Utils/ArrayBoxUtilities.js';\r\nimport { CENTER } from './Constants.js';\r\n\r\nexport default class MeshBVH {\r\n\r\n\tconstructor( geo, options = {} ) {\r\n\r\n\t\tif ( ! geo.isBufferGeometry ) {\r\n\r\n\t\t\tthrow new Error( 'MeshBVH: Only BufferGeometries are supported.' );\r\n\r\n\t\t} else if ( geo.attributes.position.isInterleavedBufferAttribute ) {\r\n\r\n\t\t\tthrow new Error( 'MeshBVH: InterleavedBufferAttribute is not supported for the position attribute.' );\r\n\r\n\t\t} else if ( geo.index && geo.index.isInterleavedBufferAttribute ) {\r\n\r\n\t\t\tthrow new Error( 'MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.' );\r\n\r\n\t\t}\r\n\r\n\t\t// default options\r\n\t\toptions = Object.assign( {\r\n\r\n\t\t\tstrategy: CENTER,\r\n\t\t\tmaxDepth: 40,\r\n\t\t\tmaxLeafTris: 10,\r\n\t\t\tverbose: true\r\n\r\n\t\t}, options );\r\n\t\toptions.strategy = Math.max( 0, Math.min( 2, options.strategy ) );\r\n\r\n\t\tthis._roots = this._buildTree( geo, options );\r\n\r\n\r\n\t}\r\n\r\n\t/* Private Functions */\r\n\r\n\t_ensureIndex( geo ) {\r\n\r\n\t\tif ( ! geo.index ) {\r\n\r\n\t\t\tconst vertexCount = geo.attributes.position.count;\r\n\t\t\tconst index = new ( vertexCount > 65535 ? Uint32Array : Uint16Array )( vertexCount );\r\n\t\t\tgeo.setIndex( new THREE.BufferAttribute( index, 1 ) );\r\n\r\n\t\t\tfor ( let i = 0; i < vertexCount; i ++ ) {\r\n\r\n\t\t\t\tindex[ i ] = i;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// Computes the set of { offset, count } ranges which need independent BVH roots. Each\r\n\t// region in the geometry index that belongs to a different set of material groups requires\r\n\t// a separate BVH root, so that triangles indices belonging to one group never get swapped\r\n\t// with triangle indices belongs to another group. For example, if the groups were like this:\r\n\t//\r\n\t// [-------------------------------------------------------------]\r\n\t// |__________________|\r\n\t//   g0 = [0, 20]  |______________________||_____________________|\r\n\t//                      g1 = [16, 40]           g2 = [41, 60]\r\n\t//\r\n\t// we would need four BVH roots: [0, 15], [16, 20], [21, 40], [41, 60].\r\n\t//\r\n\t_getRootIndexRanges( geo ) {\r\n\r\n\t\tif ( ! geo.groups || ! geo.groups.length ) {\r\n\r\n\t\t\treturn [ { offset: 0, count: geo.index.count / 3 } ];\r\n\r\n\t\t}\r\n\r\n\t\tconst ranges = [];\r\n\t\tconst rangeBoundaries = new Set();\r\n\t\tfor ( const group of geo.groups ) {\r\n\r\n\t\t\trangeBoundaries.add( group.start );\r\n\t\t\trangeBoundaries.add( group.start + group.count );\r\n\r\n\t\t}\r\n\r\n\t\t// note that if you don't pass in a comparator, it sorts them lexicographically as strings :-(\r\n\t\tconst sortedBoundaries = Array.from( rangeBoundaries.values() ).sort( ( a, b ) => a - b );\r\n\t\tfor ( let i = 0; i < sortedBoundaries.length - 1; i ++ ) {\r\n\r\n\t\t\tconst start = sortedBoundaries[ i ], end = sortedBoundaries[ i + 1 ];\r\n\t\t\tranges.push( { offset: ( start / 3 ), count: ( end - start ) / 3 } );\r\n\r\n\t\t}\r\n\t\treturn ranges;\r\n\r\n\t}\r\n\r\n\t_buildTree( geo, options ) {\r\n\r\n\t\tthis._ensureIndex( geo );\r\n\r\n\t\tconst ctx = new BVHConstructionContext( geo, options );\r\n\t\tlet reachedMaxDepth = false;\r\n\r\n\t\t// either recursively splits the given node, creating left and right subtrees for it, or makes it a leaf node,\r\n\t\t// recording the offset and count of its triangles and writing them into the reordered geometry index.\r\n\t\tconst splitNode = ( node, offset, count, depth = 0 ) => {\r\n\r\n\t\t\tif ( depth >= options.maxDepth ) {\r\n\r\n\t\t\t\treachedMaxDepth = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// early out if we've met our capacity\r\n\t\t\tif ( count <= options.maxLeafTris || depth >= options.maxDepth ) {\r\n\r\n\t\t\t\tnode.offset = offset;\r\n\t\t\t\tnode.count = count;\r\n\t\t\t\treturn node;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Find where to split the volume\r\n\t\t\tconst split = ctx.getOptimalSplit( node.boundingData, offset, count, options.strategy );\r\n\t\t\tif ( split.axis === - 1 ) {\r\n\r\n\t\t\t\tnode.offset = offset;\r\n\t\t\t\tnode.count = count;\r\n\t\t\t\treturn node;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst splitOffset = ctx.partition( offset, count, split );\r\n\r\n\t\t\t// create the two new child nodes\r\n\t\t\tif ( splitOffset === offset || splitOffset === offset + count ) {\r\n\r\n\t\t\t\tnode.offset = offset;\r\n\t\t\t\tnode.count = count;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tnode.splitAxis = split.axis;\r\n\r\n\t\t\t\t// create the left child and compute its bounding box\r\n\t\t\t\tconst left = node.left = new MeshBVHNode();\r\n\t\t\t\tconst lstart = offset, lcount = splitOffset - offset;\r\n\t\t\t\tleft.boundingData = ctx.getBounds( lstart, lcount, new Float32Array( 6 ) );\r\n\t\t\t\tsplitNode( left, lstart, lcount, depth + 1 );\r\n\r\n\t\t\t\t// repeat for right\r\n\t\t\t\tconst right = node.right = new MeshBVHNode();\r\n\t\t\t\tconst rstart = splitOffset, rcount = count - lcount;\r\n\t\t\t\tright.boundingData = ctx.getBounds( rstart, rcount, new Float32Array( 6 ) );\r\n\t\t\t\tsplitNode( right, rstart, rcount, depth + 1 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn node;\r\n\r\n\t\t};\r\n\r\n\t\tconst roots = [];\r\n\t\tconst ranges = this._getRootIndexRanges( geo );\r\n\r\n\t\tif ( ranges.length === 1 ) {\r\n\r\n\t\t\tconst root = new MeshBVHNode();\r\n\t\t\tconst range = ranges[ 0 ];\r\n\r\n\t\t\tif ( geo.boundingBox != null ) {\r\n\r\n\t\t\t\troot.boundingData = boxToArray( geo.boundingBox );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\troot.boundingData = ctx.getBounds( range.offset, range.count, new Float32Array( 6 ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tsplitNode( root, range.offset, range.count );\r\n\t\t\troots.push( root );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tfor ( let range of ranges ) {\r\n\r\n\t\t\t\tconst root = new MeshBVHNode();\r\n\t\t\t\troot.boundingData = ctx.getBounds( range.offset, range.count, new Float32Array( 6 ) );\r\n\t\t\t\tsplitNode( root, range.offset, range.count );\r\n\t\t\t\troots.push( root );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( reachedMaxDepth && options.verbose ) {\r\n\r\n\t\t\tconsole.warn( `MeshBVH: Max depth of ${ options.maxDepth } reached when generating BVH. Consider increasing maxDepth.` );\r\n\t\t\tconsole.warn( this, geo );\r\n\r\n\t\t}\r\n\r\n\t\t// if the geometry doesn't have a bounding box, then let's politely populate it using\r\n\t\t// the work we did to determine the BVH root bounds\r\n\r\n\t\tif ( geo.boundingBox == null ) {\r\n\r\n\t\t\tconst rootBox = new THREE.Box3();\r\n\t\t\tgeo.boundingBox = new THREE.Box3();\r\n\r\n\t\t\tfor ( let root of roots ) {\r\n\r\n\t\t\t\tgeo.boundingBox.union( arrayToBox( root.boundingData, rootBox ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn roots;\r\n\r\n\t}\r\n\r\n\traycast( mesh, raycaster, ray, intersects ) {\r\n\r\n\t\tfor ( const root of this._roots ) {\r\n\r\n\t\t\troot.raycast( mesh, raycaster, ray, intersects );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\traycastFirst( mesh, raycaster, ray ) {\r\n\r\n\t\tlet closestResult = null;\r\n\r\n\t\tfor ( const root of this._roots ) {\r\n\r\n\t\t\tconst result = root.raycastFirst( mesh, raycaster, ray );\r\n\t\t\tif ( result != null && ( closestResult == null || result.distance < closestResult.distance ) ) {\r\n\r\n\t\t\t\tclosestResult = result;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn closestResult;\r\n\r\n\t}\r\n\r\n\tintersectsGeometry( mesh, geometry, geomToMesh ) {\r\n\r\n\t\tfor ( const root of this._roots ) {\r\n\r\n\t\t\tif ( root.intersectsGeometry( mesh, geometry, geomToMesh ) ) return true;\r\n\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\r\n\t}\r\n\r\n\tshapecast( mesh, intersectsBoundsFunc, intersectsTriangleFunc = null, orderNodesFunc = null ) {\r\n\r\n\t\tfor ( const root of this._roots ) {\r\n\r\n\t\t\tif ( root.shapecast( mesh, intersectsBoundsFunc, intersectsTriangleFunc, orderNodesFunc ) ) return true;\r\n\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\r\n\t}\r\n\r\n\tintersectsBox( mesh, box, boxToMesh ) {\r\n\r\n\t\tfor ( const root of this._roots ) {\r\n\r\n\t\t\tif ( root.intersectsBox( mesh, box, boxToMesh ) ) return true;\r\n\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\r\n\t}\r\n\r\n\tintersectsSphere( mesh, sphere ) {\r\n\r\n\t\tfor ( const root of this._roots ) {\r\n\r\n\t\t\tif ( root.intersectsSphere( mesh, sphere ) ) return true;\r\n\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\r\n\t}\r\n\r\n\tclosestPointToGeometry( mesh, geom, matrix, target1, target2, minThreshold, maxThreshold ) {\r\n\r\n\t\tlet closestDistance = Infinity;\r\n\t\tfor ( const root of this._roots ) {\r\n\r\n\t\t\tconst dist = root.closestPointToGeometry( mesh, geom, matrix, target1, target2, minThreshold, maxThreshold );\r\n\t\t\tif ( dist < closestDistance ) closestDistance = dist;\r\n\t\t\tif ( dist < minThreshold ) return dist;\r\n\r\n\t\t}\r\n\r\n\t\treturn closestDistance;\r\n\r\n\t}\r\n\r\n\tdistanceToGeometry( mesh, geom, matrix, minThreshold, maxThreshold ) {\r\n\r\n\t\treturn this.closestPointToGeometry( mesh, geom, matrix, null, null, minThreshold, maxThreshold );\r\n\r\n\t}\r\n\r\n\tclosestPointToPoint( mesh, point, target, minThreshold, maxThreshold ) {\r\n\r\n\t\tlet closestDistance = Infinity;\r\n\t\tfor ( const root of this._roots ) {\r\n\r\n\t\t\tconst dist = root.closestPointToPoint( mesh, point, target, minThreshold, maxThreshold );\r\n\t\t\tif ( dist < closestDistance ) closestDistance = dist;\r\n\t\t\tif ( dist < minThreshold ) return dist;\r\n\r\n\t\t}\r\n\r\n\t\treturn closestDistance;\r\n\r\n\t}\r\n\r\n\tdistanceToPoint( mesh, point, minThreshold, maxThreshold ) {\r\n\r\n\t\treturn this.closestPointToPoint( mesh, point, null, minThreshold, maxThreshold );\r\n\r\n\t}\r\n\r\n}\r\n","import * as THREE from 'three';\r\nimport { arrayToBox } from './Utils/ArrayBoxUtilities.js';\r\n\r\nconst wiremat = new THREE.LineBasicMaterial( { color: 0x00FF88, transparent: true, opacity: 0.3 } );\r\nconst boxGeom = new THREE.Box3Helper().geometry;\r\nlet boundingBox = new THREE.Box3();\r\n\r\nclass MeshBVHRootVisualizer extends THREE.Object3D {\r\n\r\n\tconstructor( mesh, depth = 10, group = 0 ) {\r\n\r\n\t\tsuper( 'MeshBVHRootVisualizer' );\r\n\r\n\t\tthis.depth = depth;\r\n\t\tthis._oldDepth = - 1;\r\n\t\tthis._mesh = mesh;\r\n\t\tthis._boundsTree = null;\r\n\t\tthis._group = group;\r\n\r\n\t\tthis.update();\r\n\r\n\t}\r\n\r\n\tupdate() {\r\n\r\n\t\tif ( this._mesh.geometry.boundsTree !== this._boundsTree || this._oldDepth !== this.depth ) {\r\n\r\n\t\t\tthis._oldDepth = this.depth;\r\n\t\t\tthis._boundsTree = this._mesh.geometry.boundsTree;\r\n\r\n\t\t\tlet requiredChildren = 0;\r\n\t\t\tif ( this._boundsTree ) {\r\n\r\n\t\t\t\tconst recurse = ( n, d ) => {\r\n\r\n\t\t\t\t\tlet isLeaf = 'count' in n;\r\n\r\n\t\t\t\t\tif ( d === this.depth ) return;\r\n\r\n\t\t\t\t\tif ( d === this.depth - 1 || isLeaf ) {\r\n\r\n\t\t\t\t\t\tlet m = requiredChildren < this.children.length ? this.children[ requiredChildren ] : null;\r\n\t\t\t\t\t\tif ( ! m ) {\r\n\r\n\t\t\t\t\t\t\tm = new THREE.LineSegments( boxGeom, wiremat );\r\n\t\t\t\t\t\t\tm.raycast = () => [];\r\n\t\t\t\t\t\t\tthis.add( m );\r\n\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\trequiredChildren ++;\r\n\t\t\t\t\t\tarrayToBox( n.boundingData, boundingBox );\r\n\t\t\t\t\t\tboundingBox.getCenter( m.position );\r\n\t\t\t\t\t\tm.scale.subVectors( boundingBox.max, boundingBox.min ).multiplyScalar( 0.5 );\r\n\r\n\t\t\t\t\t\tif ( m.scale.x === 0 ) m.scale.x = Number.EPSILON;\r\n\t\t\t\t\t\tif ( m.scale.y === 0 ) m.scale.y = Number.EPSILON;\r\n\t\t\t\t\t\tif ( m.scale.z === 0 ) m.scale.z = Number.EPSILON;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( ! isLeaf ) {\r\n\r\n\t\t\t\t\t\trecurse( n.left, d + 1 );\r\n\t\t\t\t\t\trecurse( n.right, d + 1 );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t};\r\n\r\n\t\t\t\trecurse( this._boundsTree._roots[ this._group ], 0 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\twhile ( this.children.length > requiredChildren ) this.remove( this.children.pop() );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\nclass MeshBVHVisualizer extends THREE.Object3D {\r\n\r\n\tconstructor( mesh, depth = 10 ) {\r\n\r\n\t\tsuper( 'MeshBVHVisualizer' );\r\n\r\n\t\tthis.depth = depth;\r\n\t\tthis._mesh = mesh;\r\n\t\tthis._roots = [];\r\n\r\n\t\tthis.update();\r\n\r\n\t}\r\n\r\n\tupdate() {\r\n\r\n\t\tconst bvh = this._mesh.geometry.boundsTree;\r\n\t\tconst totalRoots = bvh ? bvh._roots.length : 0;\r\n\t\twhile ( this._roots.length > totalRoots ) {\r\n\r\n\t\t\tthis._roots.pop();\r\n\r\n\t\t}\r\n\r\n\t\tfor ( let i = 0; i < totalRoots; i ++ ) {\r\n\r\n\t\t\tif ( i >= this._roots.length ) {\r\n\r\n\t\t\t\tconst root = new MeshBVHRootVisualizer( this._mesh, this.depth, i );\r\n\t\t\t\tthis.add( root );\r\n\t\t\t\tthis._roots.push( root );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tlet root = this._roots[ i ];\r\n\t\t\t\troot.depth = this.depth;\r\n\t\t\t\troot.update();\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tthis.position.copy( this._mesh.position );\r\n\t\tthis.rotation.copy( this._mesh.rotation );\r\n\t\tthis.scale.copy( this._mesh.scale );\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\nexport default MeshBVHVisualizer;\r\n","import * as THREE from 'three';\r\nimport MeshBVH from './MeshBVH.js';\r\nimport Visualizer from './MeshBVHVisualizer.js';\r\nimport { CENTER, AVERAGE, SAH } from './Constants.js';\r\n\r\nconst ray = new THREE.Ray();\r\nconst tmpInverseMatrix = new THREE.Matrix4();\r\nconst origMeshRaycastFunc = THREE.Mesh.prototype.raycast;\r\n\r\nfunction acceleratedRaycast( raycaster, intersects ) {\r\n\r\n\tif ( this.geometry.boundsTree ) {\r\n\r\n\t\tif ( this.material === undefined ) return;\r\n\r\n\t\ttmpInverseMatrix.getInverse( this.matrixWorld );\r\n\t\tray.copy( raycaster.ray ).applyMatrix4( tmpInverseMatrix );\r\n\r\n\t\tif ( raycaster.firstHitOnly === true ) {\r\n\r\n\t\t\tconst res = this.geometry.boundsTree.raycastFirst( this, raycaster, ray );\r\n\t\t\tif ( res ) intersects.push( res );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.geometry.boundsTree.raycast( this, raycaster, ray, intersects );\r\n\r\n\t\t}\r\n\r\n\t} else {\r\n\r\n\t\torigMeshRaycastFunc.call( this, raycaster, intersects );\r\n\r\n\t}\r\n\r\n}\r\n\r\nfunction computeBoundsTree( options ) {\r\n\r\n\tthis.boundsTree = new MeshBVH( this, options );\r\n\treturn this.boundsTree;\r\n\r\n}\r\n\r\nfunction disposeBoundsTree() {\r\n\r\n\tthis.boundsTree = null;\r\n\r\n}\r\n\r\nexport {\r\n\tMeshBVH, Visualizer,\r\n\tacceleratedRaycast, computeBoundsTree, disposeBoundsTree,\r\n\tCENTER, AVERAGE, SAH\r\n};\r\n","import * as THREE from 'three'\nimport {Layout} from './layout/Layout'\nimport {Transitioner} from './layout/Transitioner'\n\n// accelerated raycasting\nimport { computeBoundsTree, disposeBoundsTree, acceleratedRaycast } from 'three-mesh-bvh'\nTHREE.BufferGeometry.prototype.computeBoundsTree = computeBoundsTree\nTHREE.BufferGeometry.prototype.disposeBoundsTree = disposeBoundsTree\nTHREE.Mesh.prototype.raycast = acceleratedRaycast\ndeclare module 'three/src/core/BufferGeometry' {\n    interface BufferGeometry {\n        computeBoundsTree() : void\n        disposeBoundsTree() : void\n        boundsTree?: any\n    }\n}\n\ndeclare module 'three/src/core/Object3D' {\n    interface Object3D {\n        /**\n         * Layout properties\n         */\n        layout: Layout\n        /**\n         * When active, enables pose (position, quaternion, scale) \n         * and layout (align, origin, size) properties to be used \n         * as transition targets for smooth interpolation.\n         */\n        transitioner: Transitioner\n        updateWorldMatrix(updateParents:boolean, updateChildren:boolean, updateLayout?:boolean) : void\n    }\n}\n\nlet _s = new THREE.Vector3\nTHREE.Object3D.prototype.updateMatrix = function(this:THREE.Object3D) {\n    const {position, quaternion, scale} = this\n    _s.copy(scale) // allow scale of 0 by making it very small\n    if (_s.x === 0) _s.x = 1e-10\n    if (_s.y === 0) _s.y = 1e-10\n    if (_s.z === 0) _s.z = 1e-10\n    this.matrix.compose(position, quaternion, scale)\n}\n\n// modify updateMatrixWorld to rely on updateWorldMatrix method\nTHREE.Object3D.prototype.updateMatrixWorld = function(force) {\n    if (this._inUpdateWorldMatrix) return\n    this.updateWorldMatrix(false, true, true)\n}\n\n// modify Object3D.updateWorldMatrix to apply layout\nTHREE.Object3D.prototype.updateWorldMatrix = function(this:THREE.Object3D, updateParents:boolean, updateChildren:boolean, updateLayout=true) {\n\n    const parent = this.parent\n\n    // update parents\n\n    if ( updateParents === true && parent !== null ) {\n\n        parent.updateWorldMatrix( true, false, true )\n\n    }\n\n    // update without layout\n\n    if ( this.matrixAutoUpdate ) this.updateMatrix()\n\n    if ( this.parent === null ) {\n\n        this.matrixWorld.copy( this.matrix )\n\n    } else {\n\n        this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix )\n\n    }\n\n    // update children without layout\n\n    const children = this.children;\n\n    if ( updateChildren === true ) {\n\n        for ( var i = 0, l = children.length; i < l; i ++ ) {\n\n            children[ i ].updateWorldMatrix( false, true, false )\n\n        }\n    }\n\n    // update and apply layout\n\n    if ( updateLayout === true ) {\n\n        updateChildren && this.layout.invalidateBounds() // only invalidate when traversing down\n        this.layout.updateMatrix()\n        const layoutMatrix = this.layout.matrix\n        const transitioner = this.transitioner as Transitioner\n        // const {matrixTarget, layoutMatrixTarget} = transitioner\n        \n        transitioner.matrixLocal.target.multiplyMatrices( this.layout.matrix, this.matrix )\n        const matrixLocal = transitioner.active ? transitioner.matrixLocal.current : transitioner.matrixLocal.target\n\n        if ( parent === null ) {\n            transitioner.matrixWorldTarget.copy(transitioner.matrixLocal.target)\n            this.matrixWorld.copy(matrixLocal)\n            // this.matrixWorld.multiplyMatrices( layoutMatrix, this.matrix )\n            // transitioner.targetMatrixWorld.multiplyMatrices( layoutMatrixTarget, matrixTarget )\n            \n        } else {\n\n            transitioner.matrixWorldTarget.multiplyMatrices( parent.transitioner.matrixWorldTarget, transitioner.matrixLocal.target)\n            this.matrixWorld.multiplyMatrices( parent.matrixWorld, matrixLocal )\n            // this.matrixWorld.multiplyMatrices( parent.matrixWorld, layoutMatrix ).multiply(this.matrix)\n            // transitioner.targetMatrixWorld.multiplyMatrices( parent.transitioner.targetMatrixWorld, layoutMatrixTarget).multiply( matrixTarget )\n\n        }\n\n        // update children with layout\n\n        if ( updateChildren === true ) {\n\n            for ( var i = 0, l = children.length; i < l; i ++ ) {\n\n                children[ i ].updateWorldMatrix( false, true, true );\n        \n            }\n\n        }\n\n    }\n    \n    this['_inUpdateWorldMatrix'] = true\n    this.updateMatrixWorld() // some three.js Object3D subclasses have special behavior here\n    this['_inUpdateWorldMatrix'] = false\n\n}\n\n// create a SpatialLayout instance on first access of the `layout` property \nObject.defineProperty(THREE.Object3D.prototype, 'layout', {\n    get: function getLayout(this:THREE.Object3D) {\n        if (this === THREE.Object3D.prototype) return undefined\n        Object.defineProperty(this, 'layout', {\n            value: new Layout(this),\n            writable: true,\n            enumerable: true\n        })\n        return this.layout\n    }\n})\n\n// create a SpatialTransitioner instance on first access of the `transitioner` property \nObject.defineProperty(THREE.Object3D.prototype, 'transitioner', {\n    get: function getTransitioner(this:THREE.Object3D) {\n        if (this === THREE.Object3D.prototype) return undefined\n        Object.defineProperty(this, 'transitioner', {\n            value: new Transitioner(this),\n            writable: true,\n            enumerable: true\n        })\n        return this.transitioner\n    }\n})","import * as THREE from 'three'\nimport { Box3Helper } from 'three'\n\nexport class LayoutHelper extends THREE.Object3D {\n\n    private _transitional = new THREE.Object3D \n    private _transitionalBoxHelper = new Box3Helper(this._transitional.layout.inner)\n    private _target = new THREE.Object3D \n    private _targetBoxHelper = new Box3Helper(this._target.layout.inner)\n\n    constructor() {\n        super()\n        this.add(this._transitional)\n        this._transitional.layout.innerAutoUpdate = false\n        this._transitional.layout.forceBoundsExclusion = true\n        this._transitional.add(this._transitionalBoxHelper)\n        this._transitionalBoxHelper.layout.forceBoundsExclusion = true\n        this.add(this._target)\n        this._target.layout.innerAutoUpdate = false\n        this._target.layout.forceBoundsExclusion = true\n        this._target.add(this._targetBoxHelper)\n        this._targetBoxHelper.layout.forceBoundsExclusion = true\n        ;(this._targetBoxHelper.material as THREE.LineBasicMaterial).color.setStyle('magenta')\n    }\n\n    updateWorldMatrix(parents:boolean, children:boolean, layout?:boolean) {\n        super.updateWorldMatrix(parents, children, layout)\n        if (this.parent) {\n            this._target.layout.inner.copy(this.parent.layout.computedInnerBounds)\n            this._target.matrixWorld.copy(this.parent.transitioner.matrixWorldTarget)\n            this._targetBoxHelper.updateMatrixWorld()\n            this._transitional.layout.inner.copy(this.parent.layout.computedInnerBounds)\n            this._transitional.updateMatrixWorld()\n        }\n    }\n\n}","export abstract class Behavior {\n    object:THREE.Object3D\n    init?(this:Behavior)\n    update?(this:Behavior, deltaTime:number)\n    postUpdate?(this:Behavior, deltaTime:number)\n}","import { Behavior } from './Behavior'\nimport { SpatialMetrics } from '../metrics/SpatialMetrics'\nimport { Transitioner } from '../layout/Transitioner'\n\ntype FunctionPropertyNames<T> = { [K in keyof T]: T[K] extends Function ? K : never }[keyof T]\ntype FunctionProperties<T> = Pick<T, FunctionPropertyNames<Required<T>>>\n\n/**\n * When many objects in a scene-graph have behaviors that adapt to the\n * behavior of other objects, it is crucial that these chains of adaptive \n * behavior update in a way that minimizes unecessary scene-graph calculations \n * while also not adapting in the wrong order (which would cause some behaviors\n * to be permanently lagging behind one or more frames as they adapt to stale state). \n * \n * This class supports efficient execution of adaptive behaviors\n * in an optimal order such that all behaviors are adapting to fresh state \n * with minimal traversal of the scene-graph. \n */\nexport class AdaptivityManager {\n\n    private static _getBehaviors = Symbol('getBehaviors')\n\n    private static _didUpdate = Symbol('didUpdate')\n\n    static addBehavior(object:THREE.Object3D, behavior:FunctionProperties<Behavior>|NonNullable<typeof Behavior.prototype.update>) {\n        const behaviors = object[AdaptivityManager._getBehaviors] = object[AdaptivityManager._getBehaviors] || []\n        let b:Behavior\n        if (typeof behavior === 'function') b = {object, update:behavior} \n        else b = <Behavior>behavior\n        b.object = object\n        b.init && b.init()\n        behaviors.push(b)\n    }\n\n    static getBehaviors(object:THREE.Object3D) {\n        return object[AdaptivityManager._getBehaviors] as Behavior[]\n    }\n    \n    static currentScene:THREE.Scene\n    static currentCamera:THREE.Camera\n    static currentDeltaTime:number\n\n    static update(scene:THREE.Scene, camera:THREE.Camera, deltaTime:number) {\n        AdaptivityManager.currentScene = scene\n        AdaptivityManager.currentCamera = camera\n        AdaptivityManager.currentDeltaTime = deltaTime\n        scene.updateWorldMatrix(true, true)\n        AdaptivityManager.ensureUpdate(camera)\n        scene.traverse(AdaptivityManager.ensureUpdate)\n        AdaptivityManager.currentScene = undefined as any\n        AdaptivityManager.currentCamera = undefined as any\n        AdaptivityManager.currentDeltaTime = undefined as any\n        Promise.resolve(scene).then(AdaptivityManager.clearUpdateFlag)\n    }\n\n    static clearUpdateFlag(scene:THREE.Scene) {\n        scene.traverse((obj) => obj[AdaptivityManager._didUpdate] = false)\n    }\n\n    static ensureUpdate(obj:THREE.Object3D) {\n        if (!AdaptivityManager.currentScene) throw new Error('AdaptivityManager.ensureUpdate: must be called inside a Behavior callback')\n        if (obj[AdaptivityManager._didUpdate]) return\n        obj[AdaptivityManager._didUpdate] = true\n        obj.parent && AdaptivityManager.ensureUpdate(obj.parent)\n        const behaviors = AdaptivityManager.getBehaviors(obj)\n        Transitioner.disableAllTransitions = true\n        if (behaviors) for (const b of behaviors) {\n            if (b.update) {\n                b.update(AdaptivityManager.currentDeltaTime!)\n                obj.updateWorldMatrix(false, true)\n            }\n        }\n        Transitioner.disableAllTransitions = false\n        obj.transitioner.update(AdaptivityManager.currentDeltaTime!, false)\n        if (behaviors) for (const b of behaviors) {\n            if (b.postUpdate) {\n                b.postUpdate(AdaptivityManager.currentDeltaTime!)\n                obj.updateWorldMatrix(false, true)\n            }\n        }\n    }\n}","import * as THREE from 'three'\nimport { Behavior } from './Behavior'\nimport { SpatialMetrics, Box3 } from '../metrics/SpatialMetrics'\nimport { vectors } from '../utils'\nimport { AdaptivityManager } from './AdaptivityManager'\nimport { Transitionable } from '../layout/Transitioner'\n\n// TODO: take occluder velocity into account, ignore fast moving occluders\n// TODO: clip change threshold to minimize small corrections\n\nexport class AdaptiveClippingBehavior extends Behavior {\n\n    private _boxA = new Box3\n    private _boxB = new Box3\n\n    occluders = [] as THREE.Object3D[]\n\n    occluderInfluenceDelay = 0.5\n\n    occlusionTime = new WeakMap<THREE.Object3D, number>()\n\n    update(deltaTime:number) {\n        const camera = AdaptivityManager.currentCamera\n        const cameraMetrics = SpatialMetrics.get(camera)\n\n        const object = this.object\n        object.layout.clip.makeEmpty()\n        object.updateWorldMatrix(true, true)\n        const objectMetrics = SpatialMetrics.get(object)\n        const objectDistance = cameraMetrics.getDistanceOf(object)\n        const objectBounds = this._boxA.copy(object.layout.computedInnerBounds)\n        objectBounds.min.z = -Infinity\n        objectBounds.max.z = Infinity\n\n        const clip = object.layout.clip\n        // const clip = this.clipTarget.target.makeEmpty()\n\n        // for each occluder, need to crop the layout by at most \n        // a single cut that minimizes the lost space \n        for (let i = 0; i < this.occluders.length; i++) {\n            const occluder = this.occluders[i]\n\n            // todo: add priority rule to allow adaptation to background (rather than foreground) objects\n            const occluderDistance = cameraMetrics.getDistanceOf(occluder)\n            if (occluderDistance > objectDistance) {\n                this.occlusionTime.set(occluder, 0)\n                continue\n            }\n\n            // make sure potential occluder behaviors have already executed\n            AdaptivityManager.ensureUpdate(occluder)\n\n            const occluderBounds = objectMetrics.getBoundsOf(occluder, this._boxB)\n            occluderBounds.min.z = -Infinity\n            occluderBounds.max.z = Infinity\n\n            if (!objectBounds.intersectsBox(occluderBounds)) {\n                this.occlusionTime.set(occluder, 0)\n                continue\n            }\n\n            let occlusionTime = (this.occlusionTime.get(occluder) || 0) + deltaTime\n            this.occlusionTime.set(occluder, occlusionTime)\n\n            if (occlusionTime < this.occluderInfluenceDelay) {\n                continue\n            }\n\n            const occluderCenter = occluderBounds.getCenter(vectors.get())\n            if (occluderCenter.x > 0) clip.max.x = isFinite(clip.max.x) ? Math.min(occluderBounds.min.x, clip.max.x) : occluderBounds.min.x\n            if (occluderCenter.x < 0) clip.min.x = isFinite(clip.min.x) ? Math.max(occluderBounds.max.x, clip.min.x) : occluderBounds.max.x\n            if (occluderCenter.y > 0) clip.max.y = isFinite(clip.max.y) ? Math.min(occluderBounds.min.y, clip.max.y) : occluderBounds.min.y\n            if (occluderCenter.y < 0) clip.min.y = isFinite(clip.min.y) ? Math.max(occluderBounds.max.y, clip.min.y) : occluderBounds.max.y\n        }\n    }\n\n    postUpdate() {\n        // this.object.layout.clip.copy(this.clipTarget.current)\n        // this.object.updateWorldMatrix(true, true)\n    }\n}"],"names":["V_00","Object","freeze","THREE","V_11","V_000","V_100","V_010","V_001","V_111","Q_IDENTITY","next","Promise","resolve","Pool","constructor","_factory","_reset","Set","_nextAutoPool","undefined","_poolAll","get","object","this","_pool","pop","_unpooled","add","then","_autoPool","pool","o","push","delete","size","vectors2","vec","set","vectors","vectors4","quaternions","quat","matrices3","mat","identity","matrices","traverse","each","bind","call","children","line3","plane","closestPoint","triangle","Visible","v1","QuickHull","tolerance","faces","newFaces","assigned","VertexList","unassigned","vertices","Face","normal","midpoint","area","constant","outside","mark","edge","HalfEdge","vertex","face","prev","twin","VertexNode","point","head","tail","assign","prototype","setFromPoints","points","Array","isArray","console","error","length","makeEmpty","i","l","compute","setFromObject","updateMatrixWorld","node","geometry","isGeometry","clone","applyMatrix4","matrixWorld","isBufferGeometry","attribute","attributes","position","count","fromBufferAttribute","containsPoint","distanceToPoint","intersectRay","ray","target","tNear","Infinity","tFar","vN","origin","vD","dot","direction","t","Math","min","max","at","intersectsRay","addVertexToFace","append","insertBefore","removeVertexFromFace","remove","removeAllVerticesFromFace","start","end","removeSubList","deleteFaceVertices","absorbingFace","faceVertices","appendChain","nextVertex","resolveUnassignedPoints","isEmpty","first","maxDistance","maxFace","distance","computeExtremes","j","minVertices","maxVertices","copy","getComponent","setComponent","Number","EPSILON","abs","x","y","z","computeInitialHull","v0","v2","v3","extremes","index","closestPointToPoint","distanceToSquared","setFromCoplanarPoints","create","getEdge","setTwin","reindexFaces","activeFaces","nextVertexToAdd","eyeVertex","eyeFace","computeHorizon","eyePoint","crossEdge","horizon","twinEdge","oppositeFace","addAdjoiningFace","horizonEdge","addNewFaces","firstSideEdge","previousSideEdge","sideEdge","addVertexToHull","clear","cleanup","a","b","c","e0","e1","e2","getNormal","getMidpoint","getArea","distanceTo","lengthSquared","last","insertAfter","ConvexGeometry","fromBufferGeometry","ConvexBufferGeometry","mergeVertices","normals","addAttribute","SimplifyModifier","cb","ab","removeFromArray","array","k","indexOf","splice","computeEdgeCollapseCost","u","v","edgelength","curvature","sideFaces","il","hasVertex","minCurvature","dotProd","computeEdgeCostAtVertex","neighbors","collapseNeighbor","collapseCost","minCost","totalCost","costCount","removeVertex","assert","removeFace","f","vs","removeIfNonNeighbor","collapse","tmpVertices","replaceVertex","minimumCostEdge","least","Triangle","computeNormal","addUniqueNeighbor","Vertex","id","vA","vB","subVectors","cross","normalize","oldv","newv","n","offset","modify","oldVertices","oldFaces","log","simplifiedGeometry","setIndex","SimplifiedHull","maxPoints","bufferGeometry","type","normalGeometry","hulls","modifier","hull","simplified","WeakMap","Box3","SpatialMetrics","objectFilter","_onObjectTraverse","_objectExpandFunction","objectExpansion","expandByObjectGeometry","expandByObjectHull","expandByObjectBox","vector","_vector","mesh","updateWorldMatrix","_getCoordinateSystemTransform","expandByPoint","getAttribute","itemSize","getX","getY","getZ","box","_box","boundingBox","computeBoundingBox","union","mat4","_mat4","coordinateSystem","getInverse","transitioner","matrixWorldTarget","multiply","relativeToAbsolute","relativePosition","out","multiplyScalar","center","_center","_size","getCenter","getSize","absoluteToRelative","absolutePosition","sub","divide","isFinite","rotateY180","setFromAxisAngle","PI","VisualFrustum","prototypeAccessors","left","leftClamped","minClamped","top","topClamped","maxClamped","right","rightClamped","bottom","bottomClamped","near","nearClamped","far","farClamped","horizontal","horizontalClamped","vertical","verticalClamped","depth","depthClamped","diagonal","minDirection","getCartesianForSphericalDirection","maxDirection","angleTo","RAD2DEG","diagonalClamped","getClampedCenter","getClampedSize","getPositionForOffset","getClampedPositionForOffset","setFromPerspectiveProjectionMatrix","projectionMatrix","inverseProjection","_applyClamping","m","isMesh","vertexPosition","_vec3","localToReferenceFrame","metrics","vertexVisualPosition","getVisualPositionForCartesianPosition","_boxPoints","const","p","minClamp","maxClamp","_metrics","has","sphericalDirection","visualElevationRadians","DEG2RAD","visualAzimuthRadians","sin","cos","getSphericalDirectionForCartesian","cartesian","asin","atan2","getSphericalPositionForCartesian","getCartesianForSphericalPosition","sphericalPosition","visualDirection","getMatrixWorld","matrixWorldGetter","getCartesianForVisualDirection","isCamera","applyQuaternion","getVisualDirectionForCartesian","cartesianPosition","getCartesianForVisualPosition","visualPosition","getPositionOf","setFromMatrixPosition","invMatrixWorld","getDistanceOf","result","getDirectionOf","lengthSq","getWorldDirectionOf","transformDirection","getClosestOrthogonalOrientationOf","closestForwardDirection","closestUpDirection","viewToObjectMat","extractRotation","orientation","setFromRotationMatrix","forwardDirection","upDirection","distForward","distUp","directions","dir","dist","lookAt","getOrientationOf","rotMat","targetWorldOrientation","inverseThisWorldOrientation","inverse","multiplyQuaternions","getVisualDirectionOf","getVisualAngleOf","getBoundsOf","getVisualFrustumOf","_visualFrustum","getVisualOffsetOf","layout","isBoundingContext","LayoutFit","contain","contain3d","cover","cover3d","fill","fill3d","Layout","computedInnerBounds","fit","_fit","fitTargets","invalidateBounds","_boundsValid","resetLayout","absolute","relative","resetPose","setScalar","quaternion","scale","reset","isPassive","forceBoundsExclusion","updateMatrix","bounds","computedBounds","matrix","updateInnerBounds","updateOuterBounds","computedOuterBounds","clip","clipMax","clipMin","minSize","minRelativeSize","minAbsoluteSize","innerSize","layoutScale","adjustScaleForFit","finalSize","multiplyVectors","orient","makeRotationFromQuaternion","halfFinalSize","divideScalar","layoutAlignOffset","fitAlign","innerAlignOffset","layoutPosition","compose","inner","parentBounds","parent","cameraParent","projectionMatrixInverse","projectionZ","sizeScale","fitScale","_fitScale","clamp","ax","ay","az","lerp","reversed","easing","mirrored","createReversedEasing","createMirroredEasing","createExpoIn","power","pow","createBackIn","createAnticipateEasing","backEasing","easeIn","easeOut","easeInOut","circIn","acos","circOut","circInOut","backIn","bounceOut","p2","FLOAT_32_SUPPORTED","Float32Array","a1","a2","getSlope","calcBezier","mX1","mY1","mX2","mY2","sampleValues","calcSampleValues","aX","guessForT","initialSlope","intervalStart","currentSample","K_SPLINE_TABLE_SIZE","aGuessT","currentSlope","newtonRaphsonIterate","aA","aB","currentX","currentT","binarySubdivide","getTForX","defined","obj","TransitionTarget","value","duration","Transitionable","config","current","update","deltaTime","changePercent","_updateConfig","queue","targetQueue","_changePercent","_computePercentChange","multiplier","threshold","_delayTime","delay","committedTarget","_debounceTime","_waitTime","debounce","maxWait","elapsed","shift","_setCurrent","previousTarget","_addTargetInfluence","alpha","s","e","pos","decompose","sPos","sQuat","sScale","tPos","tQuat","tScale","slerp","amount","_c","_cBlack","minAmount","maxAmount","range","ePos","eQuat","eScale","posPercent","equals","quatPercent","scalePercent","percent","r","g","minPercent","maxPercent","_config","Transitioner","DEFAULT_CONFIG","LocalMatrixTransitionable","autoRange","synchronizeComponents","matrixLocal","active","_active","disableAllTransitions","transitionable","customTransitionables","autoActive","_setParent","parentTarget","originalMatrixWorld","inverseParentMatrixWorld","Vector3","vC","uvA","Vector2","uvB","uvC","intersectionPoint","intersectionPointWorld","intersectTri","geo","raycaster","tri","intersections","triOffset","intersection","uv","material","pA","pB","pC","side","BackSide","intersectTriangle","DoubleSide","checkIntersection","getUV","Face3","faceIndex","checkBufferGeometryIntersection","arrayToBox","arr","getLongestEdgeIndex","splitDimIdx","splitDist","SeparatingAxisBounds","[object Object]","field","val","axis","other","setFromBox","boxMin","boxMax","closestPointLineToLine","dir1","dir2","v02","l1","l2","v10","v32","d0232","d3210","d3232","d0210","denom","d","d2","closestPointsSegmentToSegment","paramResult","temp1","temp2","target1","target2","closestPoint2","sphereIntersectTriangle","closestPointTemp","projectedPointTemp","planeTemp","Plane","lineTemp","Line3","sphere","radius","getPlane","pp","projectPoint","SeparatingAxisTriangle","args","super","isSeparatingAxisTriangle","satAxes","map","satBounds","Sphere","axis0","sab0","axis1","sab1","axis2","sab2","axis3","sab3","intersectsTriangle","saTri2","arr1","arr2","cachedSatBounds","cachedSatBounds2","cachedAxis","satBounds1","satAxes1","sb","isSeparated","satBounds2","satAxes2","sa1","i2","crossVectors","distanceToTriangle","point2","cornerFields","line1","line2","closestDistanceSq","otherVec","thisVec","sqrt","OrientedBox","isOrientedBox","Matrix4","invMatrix","alignedSatBounds","minVec","setFromPointsField","intersectsBox","aabbBounds","intersectsSphere","saTri","pointsArr","triSatBounds","triSatAxes","distanceToBox","xyzFields","segments1","segments2","point1","threshold2","i1","nextIndex","nextIndex2","f1","f2","f3","THREE.Box3","boxIntersection","THREE.Vector3","setTriangle","ta","tb","tc","i3","MeshBVHNode","boundingData","intersectBox","intersects","intersectTris","raycast","res","intersectClosestTri","splitAxis","xyzAxis","c1","c2","c1Result","raycastFirst","rayOrig","toPoint","toChild1","toChild2","toPointSq","c2Result","shapecast","cachedBox1","cachedBox2","intersectsBoundsFunc","intersectsTriangleFunc","nodeScoreFunc","score1","score2","box1","box2","temp","tempBox","intersectsGeometry","triangle2","cachedMesh","THREE.Mesh","invertedMat","THREE.Matrix4","obb","obb2","geometryToBvh","cachedObb","thisGeometry","thisIndex","thisPos","boundsTree","boxToBvh","minThreshold","maxThreshold","closestDistance","isLeaf","score","closestPointToGeometry","tri2","tempTarget1","tempTarget2","sphere1","sphere2","CENTER","AVERAGE","SAH","boxtemp","BVHConstructionContext","options","verts","triCount","ai","bi","ci","el","halfExtents","computeBounds","sahplanes","strategy","avg","minx","miny","minz","maxx","maxy","maxz","cx","hx","cy","hy","cz","hz","split","axisOffset","t0","t1","t2","getAverage","TRAVERSAL_COST","INTERSECTION_COST","bb","dim","sa","filteredLists","forEach","planes","sort","getCost","sal","nl","sar","nr","bestCost","o1","o2","bmin","bmax","pinfo","ldim","rdim","ldimo1","rdimo1","ldimo2","rdimo2","cost","MeshBVH","Error","isInterleavedBufferAttribute","maxDepth","maxLeafTris","verbose","_roots","_buildTree","vertexCount","Uint32Array","Uint16Array","THREE.BufferAttribute","groups","ranges","rangeBoundaries","group","sortedBoundaries","from","values","_ensureIndex","ctx","reachedMaxDepth","splitNode","getOptimalSplit","splitOffset","partition","lstart","lcount","getBounds","rstart","rcount","roots","_getRootIndexRanges","root","bx","boxToArray","warn","rootBox","closestResult","geomToMesh","orderNodesFunc","boxToMesh","geom","THREE.LineBasicMaterial","color","transparent","opacity","THREE.Box3Helper","THREE.Ray","tmpInverseMatrix","origMeshRaycastFunc","computeBoundsTree","disposeBoundsTree","firstHitOnly","let","_s","force","_inUpdateWorldMatrix","updateParents","updateChildren","updateLayout","matrixAutoUpdate","multiplyMatrices","defineProperty","writable","enumerable","LayoutHelper","Box3Helper","_transitional","_target","innerAutoUpdate","_transitionalBoxHelper","_targetBoxHelper","setStyle","parents","Behavior","AdaptivityManager","addBehavior","behavior","behaviors","_getBehaviors","init","getBehaviors","scene","camera","currentScene","currentCamera","currentDeltaTime","ensureUpdate","clearUpdateFlag","_didUpdate","postUpdate","Symbol","AdaptiveClippingBehavior","cameraMetrics","objectMetrics","objectDistance","objectBounds","_boxA","occluders","occluder","occlusionTime","occluderBounds","_boxB","occluderInfluenceDelay","occluderCenter"],"mappings":"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"}